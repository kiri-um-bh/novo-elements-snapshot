import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ComponentFactoryResolver, ContentChildren, Directive, ElementRef, EventEmitter, HostBinding, HostListener, Inject, Injectable, InjectionToken, Input, LOCALE_ID, NgModule, NgZone, Optional, Output, PLATFORM_ID, Pipe, ReflectiveInjector, Renderer2, TemplateRef, ViewChild, ViewContainerRef, ViewEncapsulation, animate, forwardRef, state, style, transition, trigger } from '@angular/core';
import { CommonModule, DOCUMENT, isPlatformBrowser } from '@angular/common';
import { addDays, addHours, addMinutes, addMonths, addSeconds, addWeeks, differenceInDays, differenceInMinutes, differenceInSeconds, endOfDay, endOfMonth, endOfWeek, getDate, getDay, getHours, getMilliseconds, getMinutes, getMonth, getSeconds, getYear, isAfter, isBefore, isSameDay, isSameMonth, isSameSecond, isToday, setDate, setHours, setMilliseconds, setMinutes, setMonth, setSeconds, setYear, startOfDay, startOfMinute, startOfMonth, startOfToday, startOfTomorrow, startOfWeek, subMonths } from 'date-fns';
import { FormBuilder, FormControl, FormGroup, FormsModule, NG_VALUE_ACCESSOR, ReactiveFormsModule, Validators } from '@angular/forms';
import { Observable as Observable$1 } from 'rxjs/Observable';
import 'rxjs/add/observable/fromPromise';
import { Overlay, OverlayConfig, OverlayModule } from '@angular/cdk/overlay';
import { TemplatePortal } from '@angular/cdk/portal';
import { merge as merge$1 } from 'rxjs/observable/merge';
import { filter as filter$1 } from 'rxjs/operators/filter';
import { fromEvent as fromEvent$1 } from 'rxjs/observable/fromEvent';
import { of as of$1 } from 'rxjs/observable/of';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import 'rxjs/add/observable/fromEvent';
import 'rxjs/add/operator/debounceTime';
import 'rxjs/add/operator/distinctUntilChanged';
import { ENTER, ESCAPE, TAB } from '@angular/cdk/keycodes';
import * as dragulaImported from 'dragula';
import { ReplaySubject as ReplaySubject$1 } from 'rxjs/ReplaySubject';
import { TextMaskModule } from 'angular2-text-mask';
import { animate as animate$1, state as state$1, style as style$1, transition as transition$1, trigger as trigger$1 } from '@angular/animations';
import { Http, HttpModule } from '@angular/http';
import 'rxjs/add/operator/map';
import { DomSanitizer } from '@angular/platform-browser';
import { CDK_ROW_TEMPLATE, CDK_TABLE_TEMPLATE, CdkCell, CdkCellDef, CdkColumnDef, CdkHeaderCell, CdkHeaderCellDef, CdkHeaderRow, CdkHeaderRowDef, CdkRow, CdkRowDef, CdkTable, CdkTableModule, DataSource } from '@angular/cdk/table';
import 'rxjs/add/operator/switchMap';
import 'rxjs/add/operator/startWith';
import 'rxjs/add/observable/merge';
import 'rxjs/add/observable/of';
import 'rxjs/add/operator/catch';
import 'rxjs/add/operator/toPromise';

// NG2
// Rule storage - pluralize and singularize need to be run sequentially,
// while other rules can be optimized using an object for instant lookups.
let pluralRules = [];
let singularRules = [];
let uncountables = {};
let irregularPlurals = {};
let irregularSingles = {};
/**
 * Title case a string.
 * @param {?} str
 * @return {?}
 */
function toTitleCase(str) {
    return str.charAt(0).toUpperCase() + str.substr(1).toLowerCase();
}
/**
 * Sanitize a pluralization rule to a usable regular expression.
 * @param {?} rule
 * @return {?}
 */
function sanitizeRule(rule) {
    if (typeof rule === 'string') {
        return new RegExp('^' + rule + '$', 'i');
    }
    return rule;
}
/**
 * Pass in a word token to produce a function that can replicate the case on
 * another word.
 * @param {?} word
 * @param {?} token
 * @return {?}
 */
function restoreCase(word, token) {
    // Upper cased words. E.g. "HELLO".
    if (word === word.toUpperCase()) {
        return token.toUpperCase();
    }
    // Title cased words. E.g. "Title".
    if (word[0] === word[0].toUpperCase()) {
        return toTitleCase(token);
    }
    // Lower cased words. E.g. "test".
    return token.toLowerCase();
}
/**
 * Interpolate a regexp string.
 * @param {?} str
 * @param {?} args
 * @return {?}
 */
function interpolate(str, args) {
    return str.replace(/\$(\d{1,2})/g, (match, index) => {
        return args[index] || '';
    });
}
/**
 * Sanitize a word by passing in the word and sanitization rules.
 * @param {?} token
 * @param {?} word
 * @param {?} collection
 * @return {?}
 */
function sanitizeWord(token, word, collection) {
    // Empty string or doesn't need fixing.
    if (!token.length || uncountables.hasOwnProperty(token)) {
        return word;
    }
    let /** @type {?} */ len = collection.length;
    // Iterate over the sanitization rules and use the first one to match.
    while (len--) {
        let /** @type {?} */ rule = collection[len];
        // If the rule passes, return the replacement.
        if (rule[0].test(word)) {
            return word.replace(rule[0], (match, index, words) => {
                let /** @type {?} */ result = interpolate(rule[1], [match, index, words]);
                if (match === '') {
                    return restoreCase(words[index - 1], result);
                }
                return restoreCase(match, result);
            });
        }
    }
    return word;
}
/**
 * Replace a word with the updated word.
 * @param {?} replaceMap
 * @param {?} keepMap
 * @param {?} rules
 * @return {?}
 */
function replaceWord(replaceMap, keepMap, rules) {
    return (word) => {
        // Get the correct token and case restoration functions.
        let /** @type {?} */ token = word.toLowerCase();
        // Check against the keep object map.
        if (keepMap.hasOwnProperty(token)) {
            return restoreCase(word, token);
        }
        // Check against the replacement map for a direct word replacement.
        if (replaceMap.hasOwnProperty(token)) {
            return restoreCase(word, replaceMap[token]);
        }
        // Run all the rules against the word.
        return sanitizeWord(token, word, rules);
    };
}
class Pluralize {
    /**
     * @param {?} word
     * @param {?=} count
     * @param {?=} inclusive
     * @return {?}
     */
    static pluralize(word, count = 1, inclusive) {
        let /** @type {?} */ pluralized = count === 1 ? Pluralize.singular(word) : Pluralize.plural(word);
        return (inclusive ? `${count} ` : '') + pluralized;
    }
    /**
     * @param {?} word
     * @return {?}
     */
    static singular(word) {
        return replaceWord(irregularSingles, irregularPlurals, pluralRules)(word);
    }
    /**
     * @param {?} word
     * @return {?}
     */
    static plural(word) {
        return replaceWord(irregularPlurals, irregularSingles, singularRules)(word);
    }
    /**
     * @param {?} rule
     * @param {?} replacement
     * @return {?}
     */
    static addPluralRule(rule, replacement) {
        pluralRules.push([sanitizeRule(rule), replacement]);
    }
    /**
     * @param {?} rule
     * @param {?} replacement
     * @return {?}
     */
    static addSingularRule(rule, replacement) {
        singularRules.push([sanitizeRule(rule), replacement]);
    }
    /**
     * @param {?} word
     * @return {?}
     */
    static addUncountableRule(word) {
        if (typeof word === 'string') {
            uncountables[word.toLowerCase()] = true;
            return;
        }
        // Set singular and plural references for the word.
        Pluralize.addPluralRule(word, '$0');
        Pluralize.addSingularRule(word, '$0');
    }
    /**
     * @param {?} single
     * @param {?} plural
     * @return {?}
     */
    static addIrregularRule(single, plural) {
        let /** @type {?} */ one = plural.toLowerCase();
        let /** @type {?} */ many = single.toLowerCase();
        irregularSingles[one] = many;
        irregularPlurals[many] = one;
    }
    ;
}
/**
 * Irregular rules.
 */
[
    // Pronouns.
    ['I', 'we'],
    ['me', 'us'],
    ['he', 'they'],
    ['she', 'they'],
    ['them', 'them'],
    ['myself', 'ourselves'],
    ['yourself', 'yourselves'],
    ['itself', 'themselves'],
    ['herself', 'themselves'],
    ['himself', 'themselves'],
    ['themself', 'themselves'],
    ['is', 'are'],
    ['this', 'these'],
    ['that', 'those'],
    // Words ending in with a consonant and `o`.
    ['echo', 'echoes'],
    ['dingo', 'dingoes'],
    ['volcano', 'volcanoes'],
    ['tornado', 'tornadoes'],
    ['torpedo', 'torpedoes'],
    // Ends with `us`.
    ['genus', 'genera'],
    ['viscus', 'viscera'],
    // Ends with `ma`.
    ['stigma', 'stigmata'],
    ['stoma', 'stomata'],
    ['dogma', 'dogmata'],
    ['lemma', 'lemmata'],
    ['schema', 'schemata'],
    ['anathema', 'anathemata'],
    // Other irregular rules.
    ['ox', 'oxen'],
    ['axe', 'axes'],
    ['die', 'dice'],
    ['yes', 'yeses'],
    ['foot', 'feet'],
    ['eave', 'eaves'],
    ['goose', 'geese'],
    ['tooth', 'teeth'],
    ['quiz', 'quizzes'],
    ['human', 'humans'],
    ['proof', 'proofs'],
    ['carve', 'carves'],
    ['valve', 'valves'],
    ['thief', 'thieves'],
    ['genie', 'genies'],
    ['groove', 'grooves'],
    ['pickaxe', 'pickaxes'],
    ['whiskey', 'whiskies']
].forEach((rule) => {
    return Pluralize.addIrregularRule(rule[0], rule[1]);
});
/**
 * Pluralization rules.
 */
[
    [/s?$/i, 's'],
    [/([^aeiou]ese)$/i, '$1'],
    [/(ax|test)is$/i, '$1es'],
    [/(alias|[^aou]us|tlas|gas|ris)$/i, '$1es'],
    [/(e[mn]u)s?$/i, '$1s'],
    [/([^l]ias|[aeiou]las|[emjzr]as|[iu]am)$/i, '$1'],
    [/(alumn|syllab|octop|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, '$1i'],
    [/(alumn|alg|vertebr)(?:a|ae)$/i, '$1ae'],
    [/(seraph|cherub)(?:im)?$/i, '$1im'],
    [/(her|at|gr)o$/i, '$1oes'],
    [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|automat|quor)(?:a|um)$/i, '$1a'],
    [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)(?:a|on)$/i, '$1a'],
    [/sis$/i, 'ses'],
    [/(?:(kni|wi|li)fe|(ar|l|ea|eo|oa|hoo)f)$/i, '$1$2ves'],
    [/([^aeiouy]|qu)y$/i, '$1ies'],
    [/([^ch][ieo][ln])ey$/i, '$1ies'],
    [/(x|ch|ss|sh|zz)$/i, '$1es'],
    [/(matr|cod|mur|sil|vert|ind|append)(?:ix|ex)$/i, '$1ices'],
    [/(m|l)(?:ice|ouse)$/i, '$1ice'],
    [/(pe)(?:rson|ople)$/i, '$1ople'],
    [/(child)(?:ren)?$/i, '$1ren'],
    [/eaux$/i, '$0'],
    [/m[ae]n$/i, 'men'],
    ['thou', 'you']
].forEach((rule) => {
    return Pluralize.addPluralRule(rule[0], rule[1]);
});
/**
 * Singularization rules.
 */
[
    [/s$/i, ''],
    [/(ss)$/i, '$1'],
    [/((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)(?:sis|ses)$/i, '$1sis'],
    [/(^analy)(?:sis|ses)$/i, '$1sis'],
    [/(wi|kni|(?:after|half|high|low|mid|non|night|[^\w]|^)li)ves$/i, '$1fe'],
    [/(ar|(?:wo|[ae])l|[eo][ao])ves$/i, '$1f'],
    [/([^aeiouy]|qu)ies$/i, '$1y'],
    [/(^[pl]|zomb|^(?:neck)?t|[aeo][lt]|cut)ies$/i, '$1ie'],
    [/(\b(?:mon|smil))ies$/i, '$1ey'],
    [/(m|l)ice$/i, '$1ouse'],
    [/(seraph|cherub)im$/i, '$1'],
    [/(x|ch|ss|sh|zz|tto|go|cho|alias|[^aou]us|tlas|gas|(?:her|at|gr)o|ris)(?:es)?$/i, '$1'],
    [/(e[mn]u)s?$/i, '$1'],
    [/(movie|twelve)s$/i, '$1'],
    [/(cris|test|diagnos)(?:is|es)$/i, '$1is'],
    [/(alumn|syllab|octop|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, '$1us'],
    [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|quor)a$/i, '$1um'],
    [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)a$/i, '$1on'],
    [/(alumn|alg|vertebr)ae$/i, '$1a'],
    [/(cod|mur|sil|vert|ind)ices$/i, '$1ex'],
    [/(matr|append)ices$/i, '$1ix'],
    [/(pe)(rson|ople)$/i, '$1rson'],
    [/(child)ren$/i, '$1'],
    [/(eau)x?$/i, '$1'],
    [/men$/i, 'man']
].forEach((rule) => {
    return Pluralize.addSingularRule(rule[0], rule[1]);
});
/**
 * Uncountable rules.
 */
[
    // Singular words with no plurals.
    'advice',
    'adulthood',
    'agenda',
    'aid',
    'alcohol',
    'ammo',
    'athletics',
    'bison',
    'blood',
    'bream',
    'buffalo',
    'butter',
    'carp',
    'cash',
    'chassis',
    'chess',
    'clothing',
    'commerce',
    'cod',
    'cooperation',
    'corps',
    'digestion',
    'debris',
    'diabetes',
    'energy',
    'equipment',
    'elk',
    'excretion',
    'expertise',
    'flounder',
    'fun',
    'gallows',
    'garbage',
    'graffiti',
    'headquarters',
    'health',
    'herpes',
    'highjinks',
    'homework',
    'housework',
    'information',
    'jeans',
    'justice',
    'kudos',
    'labour',
    'literature',
    'machinery',
    'mackerel',
    'media',
    'mews',
    'moose',
    'music',
    'news',
    'pike',
    'plankton',
    'pliers',
    'pollution',
    'premises',
    'rain',
    'research',
    'rice',
    'salmon',
    'scissors',
    'series',
    'sewage',
    'shambles',
    'shrimp',
    'species',
    'staff',
    'swine',
    'trout',
    'traffic',
    'transporation',
    'tuna',
    'wealth',
    'welfare',
    'whiting',
    'wildebeest',
    'wildlife',
    'you',
    // Regexes.
    /pox$/i,
    /ois$/i,
    /deer$/i,
    /fish$/i,
    /sheep$/i,
    /measles$/i,
    /[^aeiou]ese$/i // "chinese", "japanese"
].forEach(Pluralize.addUncountableRule);
class PluralPipe {
    /**
     * @param {?} value
     * @return {?}
     */
    transform(value) {
        return Pluralize.pluralize(value);
    }
}
PluralPipe.decorators = [
    { type: Pipe, args: [{ name: 'plural' },] },
    { type: Injectable },
];
/**
 * @nocollapse
 */
PluralPipe.ctorParameters = () => [];

class Helpers {
    /**
     * Swallows an event to stop further execution
     * @param {?} event
     * @return {?}
     */
    static swallowEvent(event) {
        if (event) {
            event.stopPropagation();
            event.preventDefault();
        }
    }
    /**
     * Interpolates a string with vars passed to it
     * @param {?} str
     * @param {?} props
     * @return {?}
     */
    static interpolate(str, props) {
        return str.replace(/\$([\w\.]+)/g, (original, key) => {
            let /** @type {?} */ keys = key.split('.');
            let /** @type {?} */ value = props[keys.shift()];
            while (keys.length && value !== undefined) {
                let /** @type {?} */ k = keys.shift();
                value = k ? value[k] : `${value}.`;
            }
            return value !== undefined ? value : original;
        });
    }
    /**
     * Verifies that an object has every property expected by a string to interpolate
     * @param {?} str
     * @param {?} props
     * @return {?}
     */
    static validateInterpolationProps(str, props) {
        let /** @type {?} */ keys = str.match(/\$([\w\.]+)/g);
        return keys.every(key => {
            return props.hasOwnProperty(key.substr(1));
        });
    }
    /**
     * @param {?} item
     * @return {?}
     */
    static isObject(item) {
        return (item && typeof item === 'object' && !Array.isArray(item) && item !== null);
    }
    /**
     * Checks to see if the object is a string
     * @param {?} obj
     * @return {?}
     */
    static isString(obj) {
        return typeof obj === 'string';
    }
    /**
     * Checks to see if the object is a undefined or null
     * @param {?} obj
     * @return {?}
     */
    static isBlank(obj) {
        return obj === undefined || obj === null;
    }
    /**
     * Checks to see if the object is a undefined or null
     * @param {?} obj
     * @return {?}
     */
    static isEmpty(obj) {
        return Helpers.isBlank(obj) || obj === '' || (Array.isArray(obj) && obj.length === 0);
    }
    /**
     * Checks to see if the object is a function
     * @param {?} obj
     * @return {?}
     */
    static isFunction(obj) {
        return !!(obj && obj.constructor && obj.call && obj.apply);
    }
    /**
     * Checks to see if the object is a Date
     * @param {?} obj
     * @return {?}
     */
    static isDate(obj) {
        return obj instanceof Date;
    }
    /**
     * @param {?} fields
     * @param {?=} reverse
     * @return {?}
     */
    static sortByField(fields, reverse = false) {
        return (previous, current) => {
            if (Helpers.isFunction(fields)) {
                return fields((reverse) ? 'desc' : 'asc', previous, current);
            }
            if (!Array.isArray(fields)) {
                fields = [fields];
            }
            for (let /** @type {?} */ i = 0; i < fields.length; i++) {
                let /** @type {?} */ field = fields[i];
                let /** @type {?} */ first = previous[field] || '';
                let /** @type {?} */ second = current[field] || '';
                if (Helpers.isDate(first) && Helpers.isDate(second)) {
                    // Dates
                    first = first.getTime();
                    second = second.getTime();
                }
                else if (Helpers.isString(first) && Helpers.isString(second)) {
                    // Basic strings
                    first = first.toLowerCase();
                    second = second.toLowerCase();
                }
                else {
                    // Numbers
                    first = isNaN(Number(first)) ? first : Number(first);
                    second = isNaN(Number(second)) ? second : Number(second);
                }
                if (first > second) {
                    return (reverse) ? -1 : 1;
                }
                else if (first < second) {
                    return (reverse) ? 1 : -1;
                }
            }
            return 0;
        };
    }
    /**
     * @param {?} key
     * @param {?} value
     * @return {?}
     */
    static filterByField(key, value) {
        return (item) => {
            let /** @type {?} */ results = [];
            let /** @type {?} */ field = can(item).have(key);
            if (value instanceof Function) {
                results.push(value(field, item));
            }
            else if (Array.isArray(value)) {
                results.push(value.includes(field));
            }
            else if (value instanceof Object) {
                if (field instanceof Date) {
                    field = field.getTime();
                }
                if (value.min) {
                    results.push(field > value.min);
                }
                if (value.max) {
                    results.push(field < value.max);
                }
                if (value.any && Array.isArray(value.any)) {
                    if (Array.isArray(field)) {
                        results.push(value.any.some(v => field.includes(v)));
                    }
                    else {
                        results.push(value.any.includes(field));
                    }
                }
                if (value.all && Array.isArray(value.all)) {
                    results.push(value.all.every(v => field.includes(v)));
                }
                if (value.not) {
                    results.push(!Helpers.filterByField(key, value.not)(item));
                }
                for (let /** @type {?} */ subkey in value) {
                    if (['min', 'max', 'any', 'all', 'not'].indexOf(subkey) < 0) {
                        let /** @type {?} */ subvalue = value[subkey];
                        results.push(Helpers.filterByField(`${key}.${subkey}`, subvalue)(item));
                    }
                }
            }
            else {
                results.push(JSON.stringify(field).match(new RegExp(value, 'gi')));
            }
            return results.every(x => x);
        };
    }
    /**
     * @param {?} position
     * @param {?} element
     * @param {?} side
     * @return {?}
     */
    static calcPositionOffset(position, element, side) {
        if (!position) {
            return;
        }
        let /** @type {?} */ supportPageOffset = window.pageXOffset !== undefined;
        let /** @type {?} */ isCSS1Compat = ((document.compatMode || '') === 'CSS1Compat');
        let /** @type {?} */ x = supportPageOffset ? window.pageXOffset : isCSS1Compat ?
            document.documentElement.scrollLeft : document.body.scrollLeft;
        let /** @type {?} */ y = supportPageOffset ? window.pageYOffset : isCSS1Compat ?
            document.documentElement.scrollTop : document.body.scrollTop;
        let /** @type {?} */ sideOffset = 0;
        if (side === 'right') {
            sideOffset = position.width - element.clientWidth;
        }
        let /** @type {?} */ top = `${position.top + y + position.height + 10}px`;
        let /** @type {?} */ left = `${position.left + x + sideOffset}px`;
        let /** @type {?} */ width = `${position.width}px`;
        const /** @type {?} */ clientWidth = element.clientWidth, /** @type {?} */ clientHeight = element.clientHeight, /** @type {?} */ marginFromBottom = parseInt(top) + clientHeight, /** @type {?} */ marginFromRight = parseInt(left) + clientWidth, /** @type {?} */ windowScrollHeight = window.innerHeight + window.scrollY, /** @type {?} */ windowScrollWidth = window.innerWidth + window.scrollX;
        // Force open up
        if (marginFromBottom >= windowScrollHeight) {
            top = `${parseInt(top.replace('px', '')) - clientHeight - position.height - 20}px`;
        }
        // Force open right
        if (marginFromRight >= windowScrollWidth) {
            left = `${parseInt(left.replace('px', '')) - clientWidth + position.width}px`;
        }
        // Force open middle
        if (parseInt(top.replace('px', '')) <= window.scrollY) {
            top = `${parseInt(top.replace('px', '')) + (clientHeight / 2) + (position.height / 2) + 10}px`;
        }
        // Force open left
        if (parseInt(left.replace('px', '')) <= window.scrollX) {
            left = `${parseInt(left.replace('px', '')) + (clientWidth / 2) + (position.width * 2) - 4}px`;
        }
        return { top, left, width };
    }
    /**
     * @param {?} element
     * @param {?} selector
     * @return {?}
     */
    static findAncestor(element, selector) {
        while ((element = element.parentElement) && !(element.matches.call(element, selector)))
            ; // tslint:disable-line
        return element;
    }
    /**
     * @param {?} item
     * @return {?}
     */
    static deepClone(item) {
        if (Array.isArray(item)) {
            let /** @type {?} */ newArr = [];
            for (let /** @type {?} */ i = item.length; i-- > 0;) {
                newArr[i] = Helpers.deepClone(item[i]);
            }
            return newArr;
        }
        if (typeof item === 'function' && !(/\(\) \{ \[native/).test(item.toString())) {
            let /** @type {?} */ obj;
            eval('obj = ' + item.toString()); // tslint:disable-line
            for (let /** @type {?} */ k in item) {
                if (k in item) {
                    obj[k] = Helpers.deepClone(item[k]);
                }
            }
            return obj;
        }
        if (item && typeof item === 'object') {
            let /** @type {?} */ obj = {};
            for (let /** @type {?} */ k in item) {
                if (k in item) {
                    obj[k] = Helpers.deepClone(item[k]);
                }
            }
            return obj;
        }
        return item;
    }
    /**
     * @param {...?} objs
     * @return {?}
     */
    static deepAssign(...objs) {
        if (objs.length < 2) {
            throw new Error('Need two or more objects to merge');
        }
        const /** @type {?} */ target = Object.assign({}, objs[0]);
        for (let /** @type {?} */ i = 1; i < objs.length; i++) {
            const /** @type {?} */ source = Object.assign({}, objs[i]);
            Object.keys(source).forEach(prop => {
                const /** @type {?} */ value = source[prop];
                if (Helpers.isObject(value)) {
                    if (target.hasOwnProperty(prop) && Helpers.isObject(target[prop])) {
                        target[prop] = Helpers.deepAssign(target[prop], value);
                    }
                    else {
                        target[prop] = value;
                    }
                }
                else if (Array.isArray(value)) {
                    if (target.hasOwnProperty(prop) && Array.isArray(target[prop])) {
                        const /** @type {?} */ targetArray = target[prop];
                        value.forEach((sourceItem, itemIndex) => {
                            if (itemIndex < targetArray.length) {
                                const /** @type {?} */ targetItem = targetArray[itemIndex];
                                if (Object.is(targetItem, sourceItem)) {
                                    return;
                                }
                                if (Helpers.isObject(targetItem) && Helpers.isObject(sourceItem)) {
                                    targetArray[itemIndex] = Helpers.deepAssign(targetItem, sourceItem);
                                }
                                else if (Array.isArray(targetItem) && Array.isArray(sourceItem)) {
                                    targetArray[itemIndex] = Helpers.deepAssign(targetItem, sourceItem);
                                }
                                else {
                                    targetArray[itemIndex] = sourceItem;
                                }
                            }
                            else {
                                targetArray.push(sourceItem);
                            }
                        });
                    }
                    else {
                        target[prop] = value;
                    }
                }
                else {
                    target[prop] = value;
                }
            });
        }
        return target;
    }
    /**
     * Workaround for Edge browser since Element:nextElementSibling is undefined inside of template directives
     * @param {?} element any document element
     * @return {?} the next sibling node that is of type: Element
     */
    static getNextElementSibling(element) {
        if (element.nextElementSibling) {
            return element.nextElementSibling;
        }
        else {
            let /** @type {?} */ e = element.nextSibling;
            while (e && 1 !== e.nodeType) {
                e = e.nextSibling;
            }
            return e;
        }
    }
}
class Can {
    /**
     * @param {?} obj
     */
    constructor(obj) {
        this.obj = obj;
    }
    /**
     * @param {?} key
     * @return {?}
     */
    have(key) {
        let /** @type {?} */ props = key.split('.');
        let /** @type {?} */ item = this.obj;
        for (let /** @type {?} */ i = 0; i < props.length; i++) {
            item = item[props[i]];
            if (this.check(item) === false) {
                return item;
            }
        }
        return item;
    }
    /**
     * @param {?} thing
     * @return {?}
     */
    check(thing) {
        return thing !== void 0;
    }
}
/**
 * @param {?} obj
 * @return {?}
 */
function can(obj) {
    return new Can(obj);
}

// NG2
// App
class DecodeURIPipe {
    /**
     * @param {?} encodedString
     * @return {?}
     */
    transform(encodedString) {
        let /** @type {?} */ decodedString = '';
        if (!Helpers.isBlank(encodedString) && typeof encodedString === 'string') {
            decodedString = decodeURIComponent(encodedString);
        }
        return decodedString;
    }
}
DecodeURIPipe.decorators = [
    { type: Pipe, args: [{ name: 'decodeURI' },] },
    { type: Injectable },
];
/**
 * @nocollapse
 */
DecodeURIPipe.ctorParameters = () => [];

class GroupByPipe {
    /**
     * @param {?} input
     * @param {?} prop
     * @return {?}
     */
    transform(input, prop) {
        if (!Array.isArray(input)) {
            return input;
        }
        const /** @type {?} */ arr = {};
        for (const /** @type {?} */ value of input) {
            const /** @type {?} */ field = can(value).have(prop);
            if (Helpers.isBlank(arr[field])) {
                arr[field] = [];
            }
            arr[field].push(value);
        }
        return Object.keys(arr).map(key => ({ key, 'value': arr[key] }));
    }
}
GroupByPipe.decorators = [
    { type: Pipe, args: [{
                name: 'groupBy'
            },] },
];
/**
 * @nocollapse
 */
GroupByPipe.ctorParameters = () => [];

// NG2
// APP
class NovoPipesModule {
}
NovoPipesModule.decorators = [
    { type: NgModule, args: [{
                declarations: [PluralPipe, DecodeURIPipe, GroupByPipe],
                exports: [PluralPipe, DecodeURIPipe, GroupByPipe]
            },] },
];
/**
 * @nocollapse
 */
NovoPipesModule.ctorParameters = () => [];

// NG2
class NovoButtonElement {
    constructor() {
        this.leftSide = false;
        this.rightSide = true;
    }
    /**
     * @param {?=} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this.iconClass = (this.icon && !this.loading) ? `bhi-${this.icon}` : '';
        this.flex = this.theme ? 'flex-wrapper' : '';
        if (this.side !== null && this.theme !== 'primary') {
            this.leftSide = (this.side === 'left');
            this.rightSide = !this.leftSide;
        }
    }
}
NovoButtonElement.decorators = [
    { type: Component, args: [{
                selector: 'button[theme]',
                host: {
                    '[attr.theme]': 'theme',
                    '[attr.color]': 'color',
                    '[attr.icon]': 'icon',
                    '[attr.loading]': 'loading'
                },
                template: `
        <!--Flex wrapper for cross-browser support-->
        <div [class]="flex">
            <!--Left Icon-->
            <i *ngIf="icon && iconClass && leftSide" [ngClass]="iconClass"></i>
            <!--Transcluded Content-->
            <ng-content></ng-content>
            <!--Right Icon-->
            <i *ngIf="icon && iconClass && rightSide" [ngClass]="iconClass"></i>
            <i *ngIf="loading" class="loading">
                <svg version="1.1"
                 xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:a="http://ns.adobe.com/AdobeSVGViewerExtensions/3.0/"
                 x="0px" y="0px" width="18.2px" height="18.5px" viewBox="0 0 18.2 18.5" style="enable-background:new 0 0 18.2 18.5;"
                 xml:space="preserve">
                <style type="text/css">
                    .spinner { fill:#FFFFFF; }
                </style>
                    <path class="spinner" d="M9.2,18.5C4.1,18.5,0,14.4,0,9.2S4.1,0,9.2,0c0.9,0,1.9,0.1,2.7,0.4c0.8,0.2,1.2,1.1,1,1.9
                        c-0.2,0.8-1.1,1.2-1.9,1C10.5,3.1,9.9,3,9.2,3C5.8,3,3,5.8,3,9.2s2.8,6.2,6.2,6.2c2.8,0,5.3-1.9,6-4.7c0.2-0.8,1-1.3,1.8-1.1
                        c0.8,0.2,1.3,1,1.1,1.8C17.1,15.7,13.4,18.5,9.2,18.5z"/>
                </svg>
            </i>
        </div>
    `
            },] },
];
/**
 * @nocollapse
 */
NovoButtonElement.ctorParameters = () => [];
NovoButtonElement.propDecorators = {
    'icon': [{ type: Input },],
    'color': [{ type: Input },],
    'side': [{ type: Input },],
    'theme': [{ type: Input },],
    'loading': [{ type: Input },],
};

// NG2
// APP
class NovoButtonModule {
}
NovoButtonModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                declarations: [NovoButtonElement],
                exports: [NovoButtonElement]
            },] },
];
/**
 * @nocollapse
 */
NovoButtonModule.ctorParameters = () => [];

// NG2
class NovoLoadingElement {
}
NovoLoadingElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-loading',
                host: {
                    '[class]': 'theme || ""'
                },
                template: `
        <span class="dot"></span>
        <span class="dot"></span>
        <span class="dot"></span>
        <span class="dot"></span>
        <span class="dot"></span>
    `
            },] },
];
/**
 * @nocollapse
 */
NovoLoadingElement.ctorParameters = () => [];
NovoLoadingElement.propDecorators = {
    'theme': [{ type: Input },],
};
class NovoSpinnerElement {
}
NovoSpinnerElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-spinner',
                template: `
        <svg class="bullhornSpinner" [ngClass]="theme" height="100" width="100" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" [attr.inverse]="inverse">
            <title>Bullhorn Spinner Animation</title>
            <desc>Spinner animation indicating loading</desc>
            <defs>
                <style>
                    .bullhornSpinner g.circleGroup {
                        -webkit-filter: url("{{baseHref || ''}}#gooEffect");
                        filter: url("{{baseHref || ''}}#gooEffect");
                    }
                    _:-webkit-full-screen:not(:root:root), .bullhornSpinner g.circleGroup {
                        -webkit-filter: none;
                        filter: none;
                    }
                    @supports (-webkit-text-size-adjust:none) and (not (-ms-accelerator:true)) and (not (-moz-appearance:none)) {
                        .bullhornSpinner g.circleGroup {
                            -webkit-filter: none;
                            filter: none;
                        }
                    }
                    @supports (-webkit-text-size-adjust:none) and (not (-ms-accelerator:true)) and (not (-moz-appearance:none)) {
                        .bullhornSpinner g.circleGroup {
                            -webkit-filter: none;
                            filter: none;
                        }
                    }
                </style>
                <filter id="gooEffect">
                    <feGaussianBlur in="SourceGraphic" stdDeviation="5" result="blur" />
                    <feColorMatrix in="blur" mode="matrix" values="
                            1.3 0 0 0 0
                            0 1.3 0 0 0
                            0 0 1.3 0 0
                            0 0 0 19 -7" result="gooEffect" />
                    <feComposite in="SourceGraphic" in2="gooEffect" operator="atop" />
                </filter>
            </defs>
            <path d="M 43 43 L 54 45 L 80 40 L 43 43" stroke="none" fill="none" id="firstLinePath"/>
            <path d="M 43 43 L 48 41 L 48 18 L 43 43" stroke="none" fill="none" id="secondLinePath"/>
            <path d="M 43 43 L 42 45 L 15 40 L 43 43" stroke="none" fill="none" id="thirdLinePath"/>
            <path d="M 43 43 L 44 52 L 29 78 L 43 43" stroke="none" fill="none" id="fourthLinePath"/>
            <path d="M 43 43 L 52 52 L 68 78 L 43 43" stroke="none" fill="none" id="fifthLinePath"/>
            <g class="circleGroup" transform="translate(7, 7)">
                <circle r="6" cx="0" cy="0">
                    <!-- Define the motion path animation -->
                    <animateMotion dur="3.4" repeatCount="indefinite">
                        <mpath xlink:href="#firstLinePath"/>
                    </animateMotion>
                </circle>
                <circle r="6" cx="0" cy="0">
                    <!-- Define the motion path animation -->
                    <animateMotion dur="3.4" repeatCount="indefinite">
                        <mpath xlink:href="#secondLinePath"/>
                    </animateMotion>
                </circle>
                <circle r="6" cx="0" cy="0">
                    <!-- Define the motion path animation -->
                    <animateMotion dur="3.4" repeatCount="indefinite">
                        <mpath xlink:href="#thirdLinePath"/>
                    </animateMotion>
                </circle>
                <circle r="6" cx="0" cy="0">
                    <!-- Define the motion path animation -->
                    <animateMotion dur="3.4" repeatCount="indefinite">
                        <mpath xlink:href="#fourthLinePath"/>
                    </animateMotion>
                </circle>
                <circle r="6" cx="0" cy="0">
                    <!-- Define the motion path animation -->
                    <animateMotion dur="3.4" repeatCount="indefinite">
                        <mpath xlink:href="#fifthLinePath"/>
                    </animateMotion>
                </circle>
            </g>
        </svg>
    `
            },] },
];
/**
 * @nocollapse
 */
NovoSpinnerElement.ctorParameters = () => [];
NovoSpinnerElement.propDecorators = {
    'theme': [{ type: Input },],
    'inverse': [{ type: Input },],
    'baseHref': [{ type: Input },],
};

// NG2
// APP
class NovoLoadingModule {
}
NovoLoadingModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                declarations: [NovoLoadingElement, NovoSpinnerElement],
                exports: [NovoLoadingElement, NovoSpinnerElement]
            },] },
];
/**
 * @nocollapse
 */
NovoLoadingModule.ctorParameters = () => [];

// NG2
class TooltipDirective {
    constructor() {
        this.position = 'top';
    }
    /**
     * @param {?} position
     * @return {?}
     */
    isPosition(position) {
        return position.toLowerCase() === (this.position || '').toLowerCase();
    }
    /**
     * @param {?} type
     * @return {?}
     */
    isType(type) {
        return type.toLowerCase() === (this.type || '').toLowerCase();
    }
    /**
     * @param {?} size
     * @return {?}
     */
    isSize(size) {
        return size.toLowerCase() === (this.size || '').toLowerCase();
    }
}
TooltipDirective.decorators = [
    { type: Directive, args: [{
                selector: '[tooltip]',
                host: {
                    '[class.hint--top]': 'tooltip && isPosition("top")',
                    '[class.hint--left]': 'tooltip && isPosition("left")',
                    '[class.hint--right]': 'tooltip && isPosition("right")',
                    '[class.hint--bottom]': 'tooltip && isPosition("bottom")',
                    '[class.hint--top-left]': 'tooltip && isPosition("top-left")',
                    '[class.hint--top-right]': 'tooltip && isPosition("top-right")',
                    '[class.hint--bottom-left]': 'tooltip && isPosition("bottom-left")',
                    '[class.hint--bottom-right]': 'tooltip && isPosition("bottom-right")',
                    '[class.hint--error]': 'tooltip && isType("error")',
                    '[class.hint--info]': 'tooltip && isType("info")',
                    '[class.hint--warning]': 'tooltip && isType("warning")',
                    '[class.hint--success]': 'tooltip && isType("success")',
                    '[class.hint--always]': 'tooltip && always',
                    '[class.hint--rounded]': 'tooltip && rounded',
                    '[class.hint--no-animate]': 'tooltip && noAnimate',
                    '[class.hint--bounce]': 'tooltip && bounce',
                    '[class.hint--hidden]': 'active === false',
                    '[class.hint--preline]': 'preline',
                    '[class.hint--small]': 'tooltip && isSize("small")',
                    '[class.hint--medium]': 'tooltip && isSize("medium")',
                    '[class.hint--large]': 'tooltip && isSize("large")',
                    '[attr.data-hint]': 'tooltip'
                }
            },] },
];
/**
 * @nocollapse
 */
TooltipDirective.ctorParameters = () => [];
TooltipDirective.propDecorators = {
    'tooltip': [{ type: Input },],
    'position': [{ type: Input, args: ['tooltipPosition',] },],
    'type': [{ type: Input, args: ['tooltipType',] },],
    'size': [{ type: Input, args: ['tooltipSize',] },],
    'bounce': [{ type: Input, args: ['tooltipBounce',] },],
    'noAnimate': [{ type: Input, args: ['tooltipNoAnimate',] },],
    'rounded': [{ type: Input, args: ['tooltipRounded',] },],
    'always': [{ type: Input, args: ['tooltipAlways',] },],
    'active': [{ type: Input, args: ['tooltipActive',] },],
    'preline': [{ type: Input, args: ['tooltipPreline',] },],
};

// NG2
// APP
class NovoTooltipModule {
}
NovoTooltipModule.decorators = [
    { type: NgModule, args: [{
                declarations: [TooltipDirective],
                exports: [TooltipDirective]
            },] },
];
/**
 * @nocollapse
 */
NovoTooltipModule.ctorParameters = () => [];

// NG2
class NovoLabelService {
    constructor() {
        this.filters = 'Filter';
        this.clear = 'Clear';
        this.sort = 'Sort';
        this.emptyTableMessage = 'No Records to display...';
        this.noMatchingRecordsMessage = 'No Matching Records';
        this.erroredTableMessage = 'Oops! An error occurred.';
        this.pickerError = 'Oops! An error occurred.';
        this.pickerEmpty = 'No results to display...';
        this.quickNoteError = 'Oops! An error occurred.';
        this.quickNoteEmpty = 'No results to display...';
        this.required = 'Required';
        this.numberTooLarge = 'Number is too large';
        this.save = 'Save';
        this.cancel = 'Cancel';
        this.next = 'Next';
        this.itemsPerPage = 'Items per page:';
        this.select = 'Select...';
        this.selected = 'Selected';
        this.selectAllOnPage = 'Select all on page';
        this.deselectAll = 'Deselect all';
        this.refresh = 'Refresh';
        this.close = 'Close';
        this.move = 'Move';
        this.startDate = 'Start Date';
        this.endDate = 'End Date';
        this.more = 'more';
        this.clearAll = 'CLEAR ALL';
        this.today = 'Today';
        this.now = 'Now';
        this.isRequired = 'is required';
        this.notValidYear = 'is not a valid year';
        this.isTooLarge = 'is too large';
        this.invalidAddress = 'requires at least one field filled out';
        this.invalidEmail = 'requires a valid email (ex. abc@123.com)';
        this.invalidMaxLength = 'Sorry, you have exceeded the maximum character count of for this field';
        this.maxLengthMet = 'Sorry, you have reached the maximum character count of for this field';
        this.minLength = 'is required to be a minimum length of';
        this.past1Day = 'Past 1 Day';
        this.past7Days = 'Past 7 Days';
        this.past30Days = 'Past 30 Days';
        this.past90Days = 'Past 90 Days';
        this.past1Year = 'Past 1 Year';
        this.next1Day = 'Next 1 Day';
        this.next7Days = 'Next 7 Days';
        this.next30Days = 'Next 30 Days';
        this.next90Days = 'Next 90 Days';
        this.next1Year = 'Next 1 Year';
        this.customDateRange = 'Custom Date Range';
        this.backToPresetFilters = 'Back to Preset Filters';
        this.okGotIt = 'Ok, Got it';
        this.address = 'Address';
        this.apt = 'Apt';
        this.city = 'City / Locality';
        this.state = 'State / Region';
        this.zipCode = 'Postal Code';
        this.country = 'Country';
        this.or = 'or';
        this.clickToBrowse = 'click to browse';
        this.chooseAFile = 'Choose a file';
        this.no = 'No';
        this.yes = 'Yes';
        this.search = 'SEARCH';
        this.noItems = 'There are no items';
        this.dateFormat = 'MM/dd/yyyy';
        this.dateFormatPlaceholder = 'MM/DD/YYYY';
        this.timeFormatPlaceholderAM = 'hh:mm AM';
        this.timeFormatPlaceholder24Hour = 'HH:mm';
        this.timeFormatAM = 'AM';
        this.timeFormatPM = 'PM';
        this.confirmChangesModalMessage = 'Are you sure you want to change this field?';
        this.promptModalMessage = 'Do you want to perform the following changes?';
        this.asyncFailure = 'Async validation was not called within the 10s threshold, you might want to reload the page to try again';
        this.previous = 'Previous';
        this.actions = 'Actions';
        this.all = 'All';
        this.groupedMultiPickerEmpty = 'No items to display';
        this.groupedMultiPickerSelectCategory = 'Select a category from the right to get started';
        this.add = 'Add';
        this.encryptedFieldTooltip = 'This data has been stored at the highest level of security';
    }
    /**
     * @param {?} toMany
     * @return {?}
     */
    getToManyPlusMore(toMany) {
        return `+${toMany.quantity} more`;
    }
    /**
     * @param {?} selected
     * @return {?}
     */
    selectedRecords(selected) {
        return `Only ${selected} records selected.`;
    }
    /**
     * @param {?} total
     * @return {?}
     */
    totalRecords(total) {
        return `Select all ${total} matching records.`;
    }
    /**
     * @param {?} value
     * @param {?} format
     * @return {?}
     */
    formatDateWithFormat(value, format) {
        let /** @type {?} */ date = value instanceof Date ? value : new Date(value);
        if (date.getTime() !== date.getTime()) {
            return value;
        }
        return new Intl.DateTimeFormat('en-US', format).format(date);
    }
    /**
     * @return {?}
     */
    getWeekdays() {
        /**
         * @param {?} dayOfWeek
         * @return {?}
         */
        function getDay$$1(dayOfWeek) {
            let /** @type {?} */ dt = new Date();
            return dt.setDate(dt.getDate() - dt.getDay() + dayOfWeek);
        }
        
        return [getDay$$1(0), getDay$$1(1), getDay$$1(2), getDay$$1(3), getDay$$1(4), getDay$$1(5), getDay$$1(6)]
            .reduce((weekdays, dt) => {
            weekdays.push(new Intl.DateTimeFormat('en-US', { weekday: 'long' }).format(dt));
            return weekdays;
        }, []);
    }
    /**
     * @return {?}
     */
    getMonths() {
        /**
         * @param {?} month
         * @return {?}
         */
        function getMonth$$1(month) {
            let /** @type {?} */ dt = new Date();
            return dt.setMonth(month, 1);
        }
        
        return [getMonth$$1(0), getMonth$$1(1), getMonth$$1(2), getMonth$$1(3), getMonth$$1(4), getMonth$$1(5), getMonth$$1(6),
            getMonth$$1(7), getMonth$$1(8), getMonth$$1(9), getMonth$$1(10), getMonth$$1(11)]
            .reduce((months, dt) => {
            months.push(new Intl.DateTimeFormat('en-US', { month: 'long' }).format(dt));
            return months;
        }, []);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    getProperty(value) {
        return this[value];
    }
    /**
     * @param {?} page
     * @param {?} pageSize
     * @param {?} length
     * @param {?} short
     * @return {?}
     */
    getRangeText(page, pageSize, length, short) {
        if (length === 0 || pageSize === 0) {
            return `Displaying 0 of ${length}`;
        }
        length = Math.max(length, 0);
        const /** @type {?} */ startIndex = page * pageSize;
        // If the start index exceeds the list length, do not try and fix the end index to the end.
        const /** @type {?} */ endIndex = startIndex < length ?
            Math.min(startIndex + pageSize, length) :
            startIndex + pageSize;
        return short ? `${startIndex + 1} - ${endIndex}/${length}` : `Displaying ${startIndex + 1} - ${endIndex} of ${length}`;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    formatCurrency(value) {
        let /** @type {?} */ options = { style: 'currency', currency: 'USD' };
        return new Intl.NumberFormat('en-US', options).format(value);
    }
    /**
     * @param {?} value
     * @param {?} options
     * @return {?}
     */
    formatNumber(value, options) {
        return new Intl.NumberFormat('en-US', options).format(value);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    formatDateShort(value) {
        let /** @type {?} */ options = {
            month: '2-digit',
            day: '2-digit',
            year: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
        };
        let /** @type {?} */ _value = value === null || value === undefined || value === '' ? new Date() : new Date(value);
        return new Intl.DateTimeFormat('en-US', options).format(_value);
    }
}
NovoLabelService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
NovoLabelService.ctorParameters = () => [];

// NG2
// APP
class CardActionsElement {
}
CardActionsElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-card-actions',
                template: '<ng-content></ng-content>'
            },] },
];
/**
 * @nocollapse
 */
CardActionsElement.ctorParameters = () => [];
class CardElement {
    /**
     * @param {?} labels
     */
    constructor(labels) {
        this.padding = true;
        this.config = {};
        this.onClose = new EventEmitter();
        this.onRefresh = new EventEmitter();
        this.labels = labels;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.config = this.config || {};
    }
    /**
     * @param {?=} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this.config = this.config || {};
        this.cardAutomationId = `${(this.title || this.config.title || 'no-title').toLowerCase().replace(/\s/g, '-')}-card`;
        let /** @type {?} */ newIcon = this.icon || this.config.icon;
        let /** @type {?} */ newMessageIcon = this.messageIcon || this.config.messageIcon;
        this.iconClass = newIcon ? `bhi-${newIcon}` : null;
        this.messageIconClass = newMessageIcon ? `bhi-${newMessageIcon}` : null;
    }
    /**
     * @return {?}
     */
    toggleClose() {
        if (!this.config.onClose) {
            this.onClose.next();
        }
        else {
            this.config.onClose();
        }
    }
    /**
     * @return {?}
     */
    toggleRefresh() {
        if (!this.config.onRefresh) {
            this.onRefresh.next();
        }
        else {
            this.config.onRefresh();
        }
    }
}
CardElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-card',
                template: `
        <div class="novo-card" [attr.data-automation-id]="cardAutomationId" [ngClass]="{'no-padding': !padding}">
            <!--Card Header-->
            <header>
                <div class="title">
                    <!--Grabber Icon-->
                    <span tooltip="{{ labels.move }}" tooltipPosition="bottom"><i *ngIf="move || config.move" class="bhi-move" [attr.data-automation-id]="cardAutomationId + '-move'"></i></span>
                    <!--Card Title-->
                    <h3 [attr.data-automation-id]="cardAutomationId + '-title'"><i *ngIf="icon" [ngClass]="iconClass"></i> {{title || config.title}}</h3>
                </div>
                <!--Card Actions-->
                <div class="actions" [attr.data-automation-id]="cardAutomationId + '-actions'">
                    <ng-content select="novo-card-actions"></ng-content>
                    <button theme="icon" icon="refresh-o"  (click)="toggleRefresh()" *ngIf="refresh || config.refresh" [attr.data-automation-id]="cardAutomationId + '-refresh'" tooltip="{{ labels.refresh }}" tooltipPosition="bottom"></button>
                    <button theme="icon" icon="close-o" (click)="toggleClose()" *ngIf="close || config.close" [attr.data-automation-id]="cardAutomationId + '-close'" tooltip="{{ labels.close }}" tooltipPosition="bottom"></button>
                </div>
            </header>
            <!--Card Main-->
            <main>
                <!--Content (transcluded)-->
                <ng-content *ngIf="!(loading || config.loading) && !(message || config.message)"></ng-content>
                <!--Error/Empty Message-->
                <p class="card-message" *ngIf="!(loading || config.loading) && (message || config.message)" [attr.data-automation-id]="cardAutomationId + '-message'"><i *ngIf="messageIconClass" [ngClass]="messageIconClass"></i> <span [innerHtml]="message || config.message"></span></p>
                <!--Loading-->
                <novo-loading *ngIf="loading || config.loading" theme="line"  [attr.data-automation-id]="cardAutomationId + '-loading'"></novo-loading>
            </main>
            <!--Card Footer-->
            <ng-content *ngIf="!(loading || config.loading) && !(message || config.message)" select="footer"></ng-content>
        </div>
    `
            },] },
];
/**
 * @nocollapse
 */
CardElement.ctorParameters = () => [
    { type: NovoLabelService, },
];
CardElement.propDecorators = {
    'padding': [{ type: Input },],
    'config': [{ type: Input },],
    'title': [{ type: Input },],
    'message': [{ type: Input },],
    'messageIcon': [{ type: Input },],
    'icon': [{ type: Input },],
    'refresh': [{ type: Input },],
    'close': [{ type: Input },],
    'move': [{ type: Input },],
    'loading': [{ type: Input },],
    'onClose': [{ type: Output },],
    'onRefresh': [{ type: Output },],
};

// NG2
class CardBestTimeElement {
    /**
     * @param {?=} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (this.time) {
            let /** @type {?} */ timeIconAndStyle = this.getTimeOfDayStyleAndIcon(this.time);
            this.timeIcon = timeIconAndStyle.icon;
            this.timeStyle = timeIconAndStyle.style;
            this.dayLowerCase = (this.day || '').toLowerCase();
            this.dataAutomationId = this.label ? this.label.replace(/\s+/g, '-').toLowerCase() : '';
        }
    }
    /**
     * @param {?} time
     * @return {?}
     */
    getTimeOfDayStyleAndIcon(time) {
        let /** @type {?} */ icon = null;
        let /** @type {?} */ style$$1 = null;
        let /** @type {?} */ transformedTime = time.replace(/\s+/g, '-').toUpperCase();
        const /** @type {?} */ TIMES = {
            morningTimes: {
                times: ['5-AM', '6-AM', '7-AM', '8-AM', '9-AM', '10-AM'],
                icon: 'bhi-coffee'
            },
            dayTimes: {
                times: ['11-AM', '12-PM', '1-PM', '2-PM', '3-PM', '4-PM', '5-PM', '6-PM'],
                icon: 'bhi-day'
            },
            eveningTimes: {
                times: ['7-PM', '8-PM', '9-PM', '10-PM', '11-PM', '12-AM', '1-AM', '2-AM', '3-AM', '4-AM'],
                icon: 'bhi-evening'
            }
        };
        for (let /** @type {?} */ prop in TIMES) {
            if (TIMES[prop].times.indexOf(transformedTime) > -1) {
                icon = TIMES[prop].icon;
                if (icon === 'bhi-coffee') {
                    style$$1 = 'morning';
                }
                else if (icon === 'bhi-day') {
                    style$$1 = 'day';
                }
                else if (icon === 'bhi-evening') {
                    style$$1 = 'evening';
                }
            }
        }
        return { icon, style: style$$1 };
    }
}
CardBestTimeElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-card-best-time',
                template: `
        <label *ngIf="!hideLabel" [attr.data-automation-id]="dataAutomationId + '-label'">{{ label }}</label>
        <div class="best-time">
            <i [attr.data-automation-id]="dataAutomationId + '-icon'" [ngClass]="[timeIcon, timeStyle]"></i>
            <div class="time-and-day">
                <span class="time" [ngClass]="timeStyle" [attr.data-automation-id]="dataAutomationId + '-time'">{{ time }}</span>
                <div class="days" [attr.data-automation-id]="dataAutomationId + '-days'">
                    <span class="day" [class.active]="dayLowerCase === 'sunday'" [attr.data-automation-id]="'sunday'">S</span>
                    <span class="day" [class.active]="dayLowerCase === 'monday'" [attr.data-automation-id]="'monday'">M</span>
                    <span class="day" [class.active]="dayLowerCase === 'tuesday'" [attr.data-automation-id]="'tuesday'">T</span>
                    <span class="day" [class.active]="dayLowerCase === 'wednesday'" [attr.data-automation-id]="'wednesday'">W</span>
                    <span class="day" [class.active]="dayLowerCase === 'thursday'" [attr.data-automation-id]="'thursday'">T</span>
                    <span class="day" [class.active]="dayLowerCase === 'friday'" [attr.data-automation-id]="'friday'">F</span>
                    <span class="day" [class.active]="dayLowerCase === 'saturday'" [attr.data-automation-id]="'saturday'">S</span>
                </div>
            </div>
        </div>
    `
            },] },
];
/**
 * @nocollapse
 */
CardBestTimeElement.ctorParameters = () => [];
CardBestTimeElement.propDecorators = {
    'label': [{ type: Input },],
    'time': [{ type: Input },],
    'day': [{ type: Input },],
    'hideLabel': [{ type: Input },],
};

// NG2
class CardDonutChartElement {
    /**
     * @param {?} element
     */
    constructor(element) {
        this.element = element;
        // Geometric number that represents 100% of the chart area
        this.chartFillMax = 629;
        // Unique ID for instance
        this.uid = Math.round(Math.random() * 1000);
        // Prevent Collision
        this.isChartDrawing = false;
    }
    /**
     * @param {?=} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (!this.isChartDrawing) {
            this.drawChart();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.isChartDrawing) {
            this.drawChart();
        }
        this.color = this.color || '#662255';
    }
    /**
     * @return {?}
     */
    drawChart() {
        this.isChartDrawing = true;
        setTimeout(() => {
            let /** @type {?} */ chartContainer = this.element.nativeElement.querySelector(`#chart-percent-${this.uid}`);
            let /** @type {?} */ fillElements = this.element.nativeElement.querySelectorAll('.fill');
            for (let /** @type {?} */ i = 0; i < fillElements.length; i++) {
                fillElements[i].setAttribute('stroke', this.color);
            }
            // Set fill amount
            this.element.nativeElement.querySelector(`#chart-fill-${this.uid}`).setAttribute('stroke-dashoffset', (this.chartFillMax * this.value).toString());
            // Set Text Color
            chartContainer.style.color = this.color;
            // Set percentage for chart
            chartContainer.setAttribute('data-percent', `${(Math.round(this.value * 100)).toString()}%`);
            // Set Label
            chartContainer.setAttribute('data-name', this.label);
            this.isChartDrawing = false;
        });
    }
}
CardDonutChartElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-card-chart-donut',
                template: `
        <aside id="chart-percent-{{ uid }}">
            <!-- COLORED FILL -->
            <svg viewBox="-10 -10 220 220">
                <g fill="none" stroke-width="20" transform="translate(100,100)">
                    <path class="fill" d="M 0,-100 A 100,100 0 0,1 86.6,-50" />
                    <path class="fill" d="M 86.6,-50 A 100,100 0 0,1 86.6,50" />
                    <path class="fill" d="M 86.6,50 A 100,100 0 0,1 0,100" />
                    <path class="fill" d="M 0,100 A 100,100 0 0,1 -86.6,50" />
                    <path class="fill" d="M -86.6,50 A 100,100 0 0,1 -86.6,-50" />
                    <path class="fill" d="M -86.6,-50 A 100,100 0 0,1 0,-100" />
                </g>
            </svg>
            <!-- GREY BEZEL -->
            <svg viewBox="-10 -10 220 220">
                <path id="chart-fill-{{uid}}" d="M200,100 C200,44.771525 155.228475,0 100,0 C44.771525,0 0,44.771525 0,100 C0,155.228475 44.771525,200 100,200 C155.228475,200 200,155.228475 200,100 Z"></path>
            </svg>
        </aside>
    `
            },] },
];
/**
 * @nocollapse
 */
CardDonutChartElement.ctorParameters = () => [
    { type: ElementRef, },
];
CardDonutChartElement.propDecorators = {
    'value': [{ type: Input },],
    'label': [{ type: Input },],
    'color': [{ type: Input },],
};

// NG2
class CardTimelineElement {
    constructor() {
        this.now = new Date().getFullYear();
    }
    /**
     * @param {?=} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this.length = ((this.end - this.start) / (this.now - this.created)) * 100;
        this.offset = ((this.start - this.created) * (100 / (this.now - this.created)));
    }
}
CardTimelineElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-card-timeline',
                template: `
        <div class="timeline-container">
            <div class="timeline-background">
                <div class="timeline" [style.width]="length + '%'" [style.margin-left]="offset + '%'" data-automation-id="timeline">
                    <div class="first annotate" [class.one]="start == end" [class.reverse]="start != end && ((end - start) < 3 || length < 22)" [class.overlap]="length < 22" data-automation-id="timeline-first">{{start}}</div>
                    <div class="last annotate" *ngIf="start != end" [class.reverse]="(end - start) < 3 && end != now && length >= 22" [class.smoosh]="length < 22" data-automation-id="timeline-last">{{end}}</div>
                    <div class="hidden-width" data-automation-id="timeline-hidden">{{length}}</div>
                </div>
            </div>
        </div>
    `
            },] },
];
/**
 * @nocollapse
 */
CardTimelineElement.ctorParameters = () => [];
CardTimelineElement.propDecorators = {
    'start': [{ type: Input },],
    'end': [{ type: Input },],
    'created': [{ type: Input },],
};

// NG2
// APP
class NovoCardModule {
}
NovoCardModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, NovoButtonModule, NovoLoadingModule, NovoTooltipModule],
                declarations: [CardElement, CardActionsElement, CardBestTimeElement, CardDonutChartElement, CardTimelineElement],
                exports: [CardElement, CardActionsElement, CardBestTimeElement, CardDonutChartElement, CardTimelineElement]
            },] },
];
/**
 * @nocollapse
 */
NovoCardModule.ctorParameters = () => [];

class NovoEventTypeLegendElement {
    constructor() {
        this.eventTypeClicked = new EventEmitter();
    }
}
NovoEventTypeLegendElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-event-type-legend',
                template: `
    <ng-template #defaultTemplate>
      <div class="cal-event-legend">
        <div class="cal-event-type"
          *ngFor="let type of events | groupBy : 'type'"
          (click)="$event.stopPropagation(); eventTypeClicked.emit({event:type?.key})">
          <div class="cal-event-type-swatch"></div><div>{{type?.key}}</div>
        </div>
      </div>
    </ng-template>
    <ng-template
      [ngTemplateOutlet]="customTemplate || defaultTemplate"
      [ngTemplateOutletContext]="{events: events, eventTypeClicked: eventTypeClicked}">
    </ng-template>
  `
            },] },
];
/**
 * @nocollapse
 */
NovoEventTypeLegendElement.ctorParameters = () => [];
NovoEventTypeLegendElement.propDecorators = {
    'events': [{ type: Input },],
    'customTemplate': [{ type: Input },],
    'eventTypeClicked': [{ type: Output },],
};

class NovoCalendarDateChangeElement {
    /**
     * @param {?} locale
     */
    constructor(locale) {
        /**
         * Called when the view date is changed
         */
        this.viewDateChange = new EventEmitter();
        this.locale = locale;
    }
    /**
     * @hidden
     * @return {?}
     */
    subtractDate() {
        this.changeDate(-1);
    }
    /**
     * @return {?}
     */
    addDate() {
        this.changeDate(1);
    }
    /**
     * @param {?} unit
     * @return {?}
     */
    changeDate(unit) {
        const /** @type {?} */ addFn = {
            day: addDays,
            week: addWeeks,
            month: addMonths
        }[this.view];
        this.viewDateChange.emit(addFn(this.viewDate, unit));
    }
    /**
     * @return {?}
     */
    get startOfWeek() {
        return startOfWeek(this.viewDate);
    }
    /**
     * @return {?}
     */
    get endOfWeek() {
        return endOfWeek(this.viewDate);
    }
}
NovoCalendarDateChangeElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-calendar-date-change',
                template: `
    <div class="cal-date-change">
        <i class="bhi-arrow-left" (click)="subtractDate()" ></i>
        <span [ngSwitch]="view">
            <span *ngSwitchCase="'month'">{{ ( viewDate | month:locale ) + ' ' + ( viewDate | year:locale ) }}</span>
            <span *ngSwitchCase="'week'">{{ ( startOfWeek | monthday:locale:'long' ) + ' - ' + ( endOfWeek | endofweekdisplay:startOfWeek:locale:'long' ) }}</span>
            <span *ngSwitchCase="'day'">{{ ( viewDate | weekday:locale:'long' ) + ', ' + ( viewDate | month:locale ) + ' ' + ( viewDate | dayofmonth:locale ) }}</span>
        </span>
        <i class="bhi-arrow-right" (click)="addDate()"></i>
    </div>
  `
            },] },
];
/**
 * @nocollapse
 */
NovoCalendarDateChangeElement.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [LOCALE_ID,] },] },
];
NovoCalendarDateChangeElement.propDecorators = {
    'view': [{ type: Input },],
    'viewDate': [{ type: Input },],
    'locale': [{ type: Input },],
    'viewDateChange': [{ type: Output },],
};

const WEEKEND_DAY_NUMBERS = [0, 6];
const DAYS_IN_WEEK = 7;
const HOURS_IN_DAY = 24;
const MINUTES_IN_HOUR = 60;
let CalendarEventResponse = {};
CalendarEventResponse.Maybe = 0;
CalendarEventResponse.Accepted = 1;
CalendarEventResponse.Rejected = 2;
CalendarEventResponse[CalendarEventResponse.Maybe] = "Maybe";
CalendarEventResponse[CalendarEventResponse.Accepted] = "Accepted";
CalendarEventResponse[CalendarEventResponse.Rejected] = "Rejected";
/**
 * @param {?} __0
 * @return {?}
 */
function getExcludedDays({ startDate, days, excluded }) {
    if (excluded.length < 1) {
        return 0;
    }
    let /** @type {?} */ day = startDate.getDay();
    let /** @type {?} */ reduce = 0;
    for (let /** @type {?} */ i = 0; i < days; i++) {
        if (day === DAYS_IN_WEEK) {
            day = 0;
        }
        if (excluded.some(e => e === day)) {
            reduce++;
        }
        day++;
    }
    return reduce;
}
/**
 * @param {?} __0
 * @return {?}
 */
function getWeekViewEventOffset({ event, startOfWeek: startOfWeek$$1, excluded = [] }) {
    if (event.start < startOfWeek$$1) {
        return 0;
    }
    const /** @type {?} */ distance = differenceInDays(event.start, startOfWeek$$1);
    return distance - getExcludedDays({ startDate: startOfWeek$$1, days: distance, excluded });
}
/**
 * @param {?} __0
 * @return {?}
 */
function isEventIsPeriod({ event, periodStart, periodEnd }) {
    const /** @type {?} */ eventStart = event.start;
    const /** @type {?} */ eventEnd = event.end || event.start;
    if (eventStart > periodStart && eventStart < periodEnd) {
        return true;
    }
    if (eventEnd > periodStart && eventEnd < periodEnd) {
        return true;
    }
    if (eventStart < periodStart && eventEnd > periodEnd) {
        return true;
    }
    if (isSameSecond(eventStart, periodStart) || isSameSecond(eventStart, periodEnd)) {
        return true;
    }
    if (isSameSecond(eventEnd, periodStart) || isSameSecond(eventEnd, periodEnd)) {
        return true;
    }
    return false;
}
/**
 * @param {?} __0
 * @return {?}
 */
function getEventsInPeriod({ events, periodStart, periodEnd }) {
    return events.filter((event) => isEventIsPeriod({ event, periodStart, periodEnd }));
}
/**
 * @param {?} events
 * @param {?} dayStart
 * @param {?} dayEnd
 * @return {?}
 */
function getEventsInTimeRange(events, dayStart, dayEnd) {
    return events.filter(event => {
        const /** @type {?} */ eventStart = event.start;
        const /** @type {?} */ eventEnd = event.end || eventStart;
        const /** @type {?} */ startOfView = setMinutes(setHours(startOfDay(eventStart), dayStart.hour), dayStart.minute);
        const /** @type {?} */ endOfView = setMinutes(setHours(startOfMinute(eventStart), dayEnd.hour), dayEnd.minute);
        return isAfter(eventEnd, startOfView)
            && isBefore(eventStart, endOfView);
    });
}
/**
 * @param {?} __0
 * @return {?}
 */
function getWeekDay({ date }) {
    const /** @type {?} */ today = startOfDay(new Date());
    return {
        date,
        isPast: date < today,
        isToday: isSameDay(date, today),
        isFuture: date > today,
        isWeekend: WEEKEND_DAY_NUMBERS.indexOf(getDay(date)) > -1
    };
}
/**
 * @param {?} __0
 * @return {?}
 */
function getWeekViewHeader({ viewDate, weekStartsOn, excluded = [] }) {
    const /** @type {?} */ start = startOfWeek(viewDate, { weekStartsOn });
    const /** @type {?} */ days = [];
    for (let /** @type {?} */ i = 0; i < DAYS_IN_WEEK; i++) {
        const /** @type {?} */ date = addDays(start, i);
        if (!excluded.some(e => date.getDay() === e)) {
            days.push(getWeekDay({ date }));
        }
    }
    return days;
}
/**
 * @param {?} __0
 * @return {?}
 */
function getWeekView({ events = [], viewDate, weekStartsOn, excluded = [], hourSegments, segmentHeight, dayStart, dayEnd }) {
    if (!events) {
        events = [];
    }
    const /** @type {?} */ startOfViewWeek = startOfWeek(viewDate, { weekStartsOn });
    const /** @type {?} */ endOfViewWeek = endOfWeek(viewDate, { weekStartsOn });
    const /** @type {?} */ maxRange = DAYS_IN_WEEK - excluded.length;
    const /** @type {?} */ eventsMapped = getEventsInTimeRange(getEventsInPeriod({ events, periodStart: startOfViewWeek, periodEnd: endOfViewWeek }), dayStart, dayEnd).map(event => {
        const /** @type {?} */ offset = getWeekViewEventOffset({ event, startOfWeek: startOfViewWeek, excluded });
        const /** @type {?} */ span = 1; //getWeekViewEventSpan({ event, offset, startOfWeek: startOfViewWeek, excluded });
        return { event, offset, span };
    }).filter(e => e.offset < maxRange).filter(e => e.span > 0).map(entry => ({
        event: entry.event,
        offset: entry.offset,
        span: entry.span,
        startsBeforeWeek: entry.event.start < startOfViewWeek,
        endsAfterWeek: (entry.event.end || entry.event.start) > endOfViewWeek,
        top: 0
    })).sort((itemA, itemB) => {
        const /** @type {?} */ startSecondsDiff = differenceInSeconds(itemA.event.start, itemB.event.start);
        if (startSecondsDiff === 0) {
            return differenceInSeconds(itemB.event.end || itemB.event.start, itemA.event.end || itemA.event.start);
        }
        return startSecondsDiff;
    }).map((entry) => {
        const /** @type {?} */ startOfView = setMinutes(setHours(startOfDay(entry.event.start), dayStart.hour), dayStart.minute);
        const /** @type {?} */ endOfView = setMinutes(setHours(startOfMinute(endOfDay(entry.event.start)), dayEnd.hour), dayEnd.minute);
        const /** @type {?} */ eventStart = entry.event.start;
        const /** @type {?} */ eventEnd = entry.event.end || eventStart;
        const /** @type {?} */ hourHeightModifier = (hourSegments * segmentHeight) / MINUTES_IN_HOUR;
        if (eventStart > startOfView) {
            entry.top += differenceInMinutes(eventStart, startOfView);
        }
        entry.top *= hourHeightModifier;
        const /** @type {?} */ startsBeforeDay = eventStart < startOfView;
        const /** @type {?} */ endsAfterDay = eventEnd > endOfView;
        const /** @type {?} */ startDate = startsBeforeDay ? startOfView : eventStart;
        const /** @type {?} */ endDate = endsAfterDay ? endOfView : eventEnd;
        let /** @type {?} */ height = differenceInMinutes(endDate, startDate);
        if (!entry.event.end) {
            height = segmentHeight;
        }
        else {
            height *= hourHeightModifier;
        }
        entry.height = height;
        return entry;
    });
    const /** @type {?} */ eventRows = [];
    const /** @type {?} */ allocatedEvents = [];
    eventsMapped.forEach((event, index) => {
        if (allocatedEvents.indexOf(event) === -1) {
            allocatedEvents.push(event);
            const /** @type {?} */ otherRowEvents = eventsMapped.slice(index + 1).filter(nextEvent => {
                return nextEvent.top === event.top && nextEvent.offset === event.offset;
            });
            if (otherRowEvents.length > 0) {
                let /** @type {?} */ totalEventsForRow = otherRowEvents.length + 1;
                event.span = (1 / totalEventsForRow);
                let /** @type {?} */ nextOffset = event.span + event.offset;
                otherRowEvents.forEach((nextEvent) => {
                    nextEvent.offset = nextOffset;
                    nextEvent.span = event.span;
                    nextOffset = nextEvent.span + nextEvent.offset;
                });
                allocatedEvents.push(...otherRowEvents);
            }
            eventRows.push({
                row: [
                    event,
                    ...otherRowEvents
                ]
            });
        }
    });
    return eventRows;
}
/**
 * @param {?} __0
 * @return {?}
 */
function getMonthView({ events = [], viewDate, weekStartsOn, excluded = [] }) {
    if (!events) {
        events = [];
    }
    const /** @type {?} */ start = startOfWeek(startOfMonth(viewDate), { weekStartsOn });
    const /** @type {?} */ end = endOfWeek(endOfMonth(viewDate), { weekStartsOn });
    const /** @type {?} */ eventsInMonth = getEventsInPeriod({
        events,
        periodStart: start,
        periodEnd: end
    });
    const /** @type {?} */ days = [];
    for (let /** @type {?} */ i = 0; i < differenceInDays(end, start) + 1; i++) {
        const /** @type {?} */ date = addDays(start, i);
        if (!excluded.some(e => date.getDay() === e)) {
            const /** @type {?} */ day = (getWeekDay({ date }));
            const /** @type {?} */ calEvents = getEventsInPeriod({
                events: eventsInMonth,
                periodStart: startOfDay(date),
                periodEnd: endOfDay(date)
            });
            day.inMonth = isSameMonth(date, viewDate);
            day.events = calEvents;
            day.badgeTotal = calEvents.length;
            days.push(day);
        }
    }
    const /** @type {?} */ totalDaysVisibleInWeek = DAYS_IN_WEEK - excluded.length;
    const /** @type {?} */ rows = Math.floor(days.length / totalDaysVisibleInWeek);
    const /** @type {?} */ rowOffsets = [];
    for (let /** @type {?} */ i = 0; i < rows; i++) {
        rowOffsets.push(i * totalDaysVisibleInWeek);
    }
    return {
        rowOffsets,
        totalDaysVisibleInWeek,
        days
    };
}
/**
 * @param {?} __0
 * @return {?}
 */
function getDayView({ events = [], viewDate, hourSegments, dayStart, dayEnd, eventWidth, segmentHeight }) {
    if (!events) {
        events = [];
    }
    const /** @type {?} */ startOfView = setMinutes(setHours(startOfDay(viewDate), dayStart.hour), dayStart.minute);
    const /** @type {?} */ endOfView = setMinutes(setHours(startOfMinute(endOfDay(viewDate)), dayEnd.hour), dayEnd.minute);
    const /** @type {?} */ previousDayEvents = [];
    const /** @type {?} */ dayViewEvents = getEventsInTimeRange(getEventsInPeriod({
        events: events.filter((event) => !event.allDay),
        periodStart: startOfView,
        periodEnd: endOfView
    }), dayStart, dayEnd).sort((eventA, eventB) => {
        return eventA.start.valueOf() - eventB.start.valueOf();
    }).map((event) => {
        const /** @type {?} */ eventStart = event.start;
        const /** @type {?} */ eventEnd = event.end || eventStart;
        const /** @type {?} */ startsBeforeDay = eventStart < startOfView;
        const /** @type {?} */ endsAfterDay = eventEnd > endOfView;
        const /** @type {?} */ hourHeightModifier = (hourSegments * segmentHeight) / MINUTES_IN_HOUR;
        let /** @type {?} */ top = 0;
        if (eventStart > startOfView) {
            top += differenceInMinutes(eventStart, startOfView);
        }
        top *= hourHeightModifier;
        const /** @type {?} */ startDate = startsBeforeDay ? startOfView : eventStart;
        const /** @type {?} */ endDate = endsAfterDay ? endOfView : eventEnd;
        let /** @type {?} */ height = differenceInMinutes(endDate, startDate);
        if (!event.end) {
            height = segmentHeight;
        }
        else {
            height *= hourHeightModifier;
        }
        const /** @type {?} */ bottom = top + height;
        const /** @type {?} */ overlappingPreviousEvents = previousDayEvents.filter((previousEvent) => {
            const /** @type {?} */ previousEventTop = previousEvent.top;
            const /** @type {?} */ previousEventBottom = previousEvent.top + previousEvent.height;
            if (top < previousEventBottom && previousEventBottom < bottom) {
                return true;
            }
            else if (previousEventTop <= top && bottom <= previousEventBottom) {
                return true;
            }
            return false;
        });
        let /** @type {?} */ left = 0;
        while (overlappingPreviousEvents.some(previousEvent => previousEvent.left === left)) {
            left += eventWidth;
        }
        const /** @type {?} */ dayEvent = {
            event,
            height,
            width: eventWidth,
            top,
            left,
            startsBeforeDay,
            endsAfterDay
        };
        if (height > 0) {
            previousDayEvents.push(dayEvent);
        }
        return dayEvent;
    }).filter((dayEvent) => dayEvent.height > 0);
    const /** @type {?} */ width = Math.max(...dayViewEvents.map((event) => event.left + event.width));
    const /** @type {?} */ allDayEvents = getEventsInPeriod({
        events: events.filter((event) => event.allDay),
        periodStart: startOfDay(startOfView),
        periodEnd: endOfDay(endOfView)
    });
    return {
        events: dayViewEvents,
        width,
        allDayEvents
    };
}
/**
 * @param {?} __0
 * @return {?}
 */
function getDayViewHourGrid({ viewDate, hourSegments, dayStart, dayEnd }) {
    const /** @type {?} */ hours = [];
    const /** @type {?} */ startOfView = setMinutes(setHours(startOfDay(viewDate), dayStart.hour), dayStart.minute);
    const /** @type {?} */ endOfView = setMinutes(setHours(startOfMinute(endOfDay(viewDate)), dayEnd.hour), dayEnd.minute);
    const /** @type {?} */ segmentDuration = MINUTES_IN_HOUR / hourSegments;
    const /** @type {?} */ startOfViewDay = startOfDay(viewDate);
    for (let /** @type {?} */ i = 0; i < HOURS_IN_DAY; i++) {
        const /** @type {?} */ segments = [];
        for (let /** @type {?} */ j = 0; j < hourSegments; j++) {
            const /** @type {?} */ date = addMinutes(addHours(startOfViewDay, i), j * segmentDuration);
            if (date >= startOfView && date < endOfView) {
                segments.push({
                    date,
                    isStart: j === 0
                });
            }
        }
        if (segments.length > 0) {
            hours.push({ segments });
        }
    }
    return hours;
}

/**
 * Shows all events on a given month. Example usage:
 *
 * ```
 * &lt;novo-calendar-month-view
 *  [viewDate]="viewDate"
 *  [events]="events"&gt;
 * &lt;/novo-calendar-month-view&gt;
 * ```
 */
class NovoCalendarMonthViewElement {
    /**
     * @hidden
     * @param {?} cdr
     * @param {?} locale
     */
    constructor(cdr, locale) {
        this.cdr = cdr;
        /**
         * An array of events to display on view
         */
        this.events = [];
        /**
         * An array of day indexes (0 = sunday, 1 = monday etc) that will be hidden on the view
         */
        this.excludeDays = [];
        /**
         * The locale used to format dates
         */
        this.locale = 'en-US';
        /**
         * The placement of the event tooltip
         */
        this.tooltipPosition = 'top';
        /**
         * Called when the day cell is clicked
         */
        this.dayClicked = new EventEmitter();
        /**
         * Called when the event title is clicked
         */
        this.eventClicked = new EventEmitter();
        /**
         * Called when an event is dragged and dropped
         */
        this.eventTimesChanged = new EventEmitter();
        this.viewDateChange = new EventEmitter();
        this.locale = locale;
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnInit() {
        if (this.refresh) {
            this.refreshSubscription = this.refresh.subscribe(() => {
                this.refreshAll();
                this.cdr.markForCheck();
            });
        }
    }
    /**
     * @hidden
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.viewDate || changes.excludeDays) {
            this.refreshHeader();
        }
        if (changes.viewDate || changes.events || changes.excludeDays) {
            this.refreshBody();
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnDestroy() {
        if (this.refreshSubscription) {
            this.refreshSubscription.unsubscribe();
        }
    }
    /**
     * @hidden
     * @param {?} day
     * @param {?} event
     * @return {?}
     */
    eventDropped(day, event) {
        const /** @type {?} */ year = getYear(day.date);
        const /** @type {?} */ month = getMonth(day.date);
        const /** @type {?} */ date = getDate(day.date);
        const /** @type {?} */ newStart = setYear(setMonth(setDate(event.start, date), month), year);
        let /** @type {?} */ newEnd;
        if (event.end) {
            const /** @type {?} */ secondsDiff = differenceInSeconds(newStart, event.start);
            newEnd = addSeconds(event.end, secondsDiff);
        }
        this.eventTimesChanged.emit({ event, newStart, newEnd });
    }
    /**
     * @return {?}
     */
    refreshHeader() {
        this.columnHeaders = getWeekViewHeader({
            viewDate: this.viewDate,
            weekStartsOn: this.weekStartsOn,
            excluded: this.excludeDays
        });
    }
    /**
     * @return {?}
     */
    refreshBody() {
        this.view = getMonthView({
            events: this.events,
            viewDate: this.viewDate,
            weekStartsOn: this.weekStartsOn,
            excluded: this.excludeDays
        });
        if (this.dayModifier) {
            this.view.days.forEach(day => this.dayModifier(day));
        }
    }
    /**
     * @return {?}
     */
    refreshAll() {
        this.refreshHeader();
        this.refreshBody();
        this.viewDateChange.emit(this.viewDate);
    }
}
NovoCalendarMonthViewElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-calendar-month',
                template: `
    <div class="calendar-month-view">
       <novo-calendar-month-header
         [(viewDate)]="viewDate"
         [days]="columnHeaders"
         [locale]="locale"
         [customTemplate]="headerTemplate"
         (viewDateChange)="refreshAll()">
       </novo-calendar-month-header>
      <div class="calendar-days">
        <div *ngFor="let rowIndex of view.rowOffsets">
          <div class="calendar-cell-row">
            <novo-calendar-month-day
              *ngFor="let day of view.days | slice : rowIndex : rowIndex + (view.totalDaysVisibleInWeek)"
              [day]="day"
              [locale]="locale"
              [customTemplate]="cellTemplate"
              (click)="dayClicked.emit({day: day})"
              (eventClicked)="eventClicked.emit({ day: day, event: $event.event})">
            </novo-calendar-month-day>
          </div>
        </div>
      </div>
    </div>
  `
            },] },
];
/**
 * @nocollapse
 */
NovoCalendarMonthViewElement.ctorParameters = () => [
    { type: ChangeDetectorRef, },
    { type: undefined, decorators: [{ type: Inject, args: [LOCALE_ID,] },] },
];
NovoCalendarMonthViewElement.propDecorators = {
    'viewDate': [{ type: Input },],
    'events': [{ type: Input },],
    'excludeDays': [{ type: Input },],
    'dayModifier': [{ type: Input },],
    'refresh': [{ type: Input },],
    'locale': [{ type: Input },],
    'tooltipPosition': [{ type: Input },],
    'weekStartsOn': [{ type: Input },],
    'headerTemplate': [{ type: Input },],
    'cellTemplate': [{ type: Input },],
    'dayClicked': [{ type: Output },],
    'eventClicked': [{ type: Output },],
    'eventTimesChanged': [{ type: Output },],
    'viewDateChange': [{ type: Output },],
};

class NovoCalendarMonthHeaderElement {
    constructor() {
        /**
         * Called when the view date is changed
         */
        this.viewDateChange = new EventEmitter();
    }
    /**
     * @return {?}
     */
    prevMonth() {
        this.viewDateChange.emit(subMonths(this.viewDate, 1));
    }
    /**
     * @return {?}
     */
    nextMonth() {
        this.viewDateChange.emit(addMonths(this.viewDate, 1));
    }
}
NovoCalendarMonthHeaderElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-calendar-month-header',
                template: `
    <ng-template #defaultTemplate>
      <div class="calendar-header">
        <div class="calendar-header-top">
          <button theme="icon" icon="previous" (click)="prevMonth($event)"></button>
          <div class="calendar-month">{{ viewDate | month:locale }}</div>
          <button theme="icon" icon="next" (click)="nextMonth($event)"></button>
        </div>
        <div class="calendar-weekdays">
          <div
            class="calendar-weekday"
            *ngFor="let day of days"
            [class.calendar-past]="day.isPast"
            [class.calendar-today]="day.isToday"
            [class.calendar-future]="day.isFuture"
            [class.calendar-weekend]="day.isWeekend">
            {{ day.date | weekday:locale }}
          </div>
        </div>
      </div>
    </ng-template>
    <ng-template
      [ngTemplateOutlet]="customTemplate || defaultTemplate"
      [ngTemplateOutletContext]="{days: days, locale: locale, viewDate: viewDate}">
    </ng-template>
  `
            },] },
];
/**
 * @nocollapse
 */
NovoCalendarMonthHeaderElement.ctorParameters = () => [];
NovoCalendarMonthHeaderElement.propDecorators = {
    'viewDate': [{ type: Input },],
    'days': [{ type: Input },],
    'locale': [{ type: Input },],
    'customTemplate': [{ type: Input },],
    'viewDateChange': [{ type: Output },],
};

class NovoCalendarMonthDayElement {
    constructor() {
        this.eventClicked = new EventEmitter();
    }
    /**
     * @return {?}
     */
    get accepted() {
        if (!this.day) {
            return [];
        }
        return this.day.events.filter((evt) => {
            return (evt.response === CalendarEventResponse.Accepted);
        });
    }
    /**
     * @return {?}
     */
    get rejected() {
        if (!this.day) {
            return [];
        }
        return this.day.events.filter((evt) => {
            return (evt.response === CalendarEventResponse.Rejected);
        });
    }
    /**
     * @return {?}
     */
    get maybes() {
        if (!this.day) {
            return [];
        }
        return this.day.events.filter((evt) => {
            return (evt.response === CalendarEventResponse.Maybe);
        });
    }
}
NovoCalendarMonthDayElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-calendar-month-day',
                template: `
    <ng-template #defaultTemplate>
      <div class="calendar-day-top">
        <span class="calendar-day-badge" *ngIf="day.badgeTotal > 0">{{ day.badgeTotal }}</span>
        <span class="calendar-day-number">{{ day.date | dayofmonth:locale }}</span>
      </div>
      <div class="calendar-events">
        <div
          class="calendar-event"
          *ngFor="let type of day.events | groupBy : 'type'"
          [style.backgroundColor]="type?.value[0]?.color.primary"
          [ngClass]="type?.value[0]?.cssClass"
          (click)="$event.stopPropagation(); eventClicked.emit({event:type?.value[0]})">
          {{type?.value.length}}
        </div>
      </div>
    </ng-template>
    <ng-template
      [ngTemplateOutlet]="customTemplate || defaultTemplate"
      [ngTemplateOutletContext]="{
        day: day,
        locale: locale,
        tooltipPosition: tooltipPosition,
        eventClicked: eventClicked,
        accepted: accepted,
        rejected: rejected,
        maybes: maybes
      }">
    </ng-template>
  `,
                host: {
                    '[class]': '"calendar-cell calendar-day-cell " + day?.cssClass',
                    '[class.calendar-day-accepted]': 'accepted.length',
                    '[class.calendar-day-rejected]': 'rejected.length',
                    '[class.calendar-past]': 'day.isPast',
                    '[class.calendar-today]': 'day.isToday',
                    '[class.calendar-future]': 'day.isFuture',
                    '[class.calendar-weekend]': 'day.isWeekend',
                    '[class.calendar-in-month]': 'day.inMonth',
                    '[class.calendar-out-month]': '!day.inMonth',
                    '[class.calendar-has-events]': 'day.events.length > 0',
                    '[style.backgroundColor]': 'day.backgroundColor'
                }
            },] },
];
/**
 * @nocollapse
 */
NovoCalendarMonthDayElement.ctorParameters = () => [];
NovoCalendarMonthDayElement.propDecorators = {
    'day': [{ type: Input },],
    'locale': [{ type: Input },],
    'tooltipPosition': [{ type: Input },],
    'customTemplate': [{ type: Input },],
    'eventClicked': [{ type: Output },],
};

/**
 * @hidden
 */
const SEGMENT_HEIGHT = 30;
/**
 * Shows all events on a given week. Example usage:
 *
 * ```typescript
 * &lt;novo-calendar-week
 *  [viewDate]="viewDate"
 *  [events]="events"&gt;
 * &lt;/novo-calendar-week&gt;
 * ```
 */
class NovoCalendarWeekViewElement {
    /**
     * @hidden
     * @param {?} cdr
     * @param {?} locale
     */
    constructor(cdr, locale) {
        this.cdr = cdr;
        /**
         * An array of events to display on view
         */
        this.events = [];
        /**
         * An array of day indexes (0 = sunday, 1 = monday etc) that will be hidden on the view
         */
        this.excludeDays = [];
        /**
         * The placement of the event tooltip
         */
        this.tooltipPosition = 'bottom';
        /**
         * The precision to display events.
         * `days` will round event start and end dates to the nearest day and `minutes` will not do this rounding
         */
        this.precision = 'days';
        /**
         * The number of segments in an hour. Must be <= 6
         */
        this.hourSegments = 2;
        /**
         * The day start hours in 24 hour time. Must be 0-23
         */
        this.dayStartHour = 0;
        /**
         * The day start minutes. Must be 0-59
         */
        this.dayStartMinute = 0;
        /**
         * The day end hours in 24 hour time. Must be 0-23
         */
        this.dayEndHour = 23;
        /**
         * The day end minutes. Must be 0-59
         */
        this.dayEndMinute = 59;
        /**
         * Called when an hour segment is clicked
         */
        this.hourSegmentClicked = new EventEmitter();
        /**
         * Called when a header week day is clicked
         */
        this.dayClicked = new EventEmitter();
        /**
         * Called when the event title is clicked
         */
        this.eventClicked = new EventEmitter();
        /**
         * Called when an event is resized or dragged and dropped
         */
        this.eventTimesChanged = new EventEmitter();
        /**
         * @hidden
         */
        this.hours = [];
        /**
         * @hidden
         */
        this.eventRows = [];
        this.locale = locale;
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnInit() {
        if (this.refresh) {
            this.refreshSubscription = this.refresh.subscribe(() => {
                this.refreshAll();
                this.cdr.detectChanges();
            });
        }
    }
    /**
     * @hidden
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.viewDate || changes.excludeDays) {
            this.refreshHeader();
        }
        if (changes.events || changes.viewDate || changes.excludeDays) {
            this.refreshBody();
        }
        if (changes.viewDate ||
            changes.dayStartHour ||
            changes.dayStartMinute ||
            changes.dayEndHour ||
            changes.dayEndMinute) {
            this.refreshHourGrid();
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnDestroy() {
        if (this.refreshSubscription) {
            this.refreshSubscription.unsubscribe();
        }
    }
    /**
     * @param {?} eventRowContainer
     * @return {?}
     */
    getDayColumnWidth(eventRowContainer) {
        return Math.floor(eventRowContainer.offsetWidth / this.days.length);
    }
    /**
     * @return {?}
     */
    refreshHeader() {
        this.days = getWeekViewHeader({
            viewDate: this.viewDate,
            weekStartsOn: this.weekStartsOn,
            excluded: this.excludeDays
        });
    }
    /**
     * @return {?}
     */
    refreshBody() {
        this.eventRows = getWeekView({
            events: this.events,
            viewDate: this.viewDate,
            weekStartsOn: this.weekStartsOn,
            excluded: this.excludeDays,
            hourSegments: this.hourSegments,
            segmentHeight: SEGMENT_HEIGHT,
            dayStart: {
                hour: this.dayStartHour,
                minute: this.dayStartMinute
            },
            dayEnd: {
                hour: this.dayEndHour,
                minute: this.dayEndMinute
            },
        });
    }
    /**
     * @return {?}
     */
    refreshHourGrid() {
        this.hours = getDayViewHourGrid({
            viewDate: this.viewDate,
            hourSegments: this.hourSegments,
            dayStart: {
                hour: this.dayStartHour,
                minute: this.dayStartMinute
            },
            dayEnd: {
                hour: this.dayEndHour,
                minute: this.dayEndMinute
            }
        });
        // if (this.hourSegmentModifier) {
        //   this.hours.forEach(hour => {
        //     hour.segments.forEach(segment => this.hourSegmentModifier(segment));
        //   });
        // }
    }
    /**
     * @return {?}
     */
    refreshAll() {
        this.refreshHeader();
        this.refreshHourGrid();
        this.refreshBody();
    }
}
NovoCalendarWeekViewElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-calendar-week',
                template: `
    <div class="cal-week-view" #weekViewContainer>
      <novo-calendar-week-header
        [days]="days"
        [locale]="locale"
        [customTemplate]="headerTemplate"
        (dayClicked)="dayClicked.emit($event)">
      </novo-calendar-week-header>
      <div *ngFor="let eventRow of eventRows" #eventRowContainer>
        <div
          class="cal-event-container"
          #event
          *ngFor="let weekEvent of eventRow.row"
          [style.width]="((100 / days.length) * weekEvent.span) + '%'"
          [style.marginTop.px]="weekEvent.top"
          [style.height.px]="weekEvent.height"
          [style.marginLeft]="((100 / days.length) * weekEvent.offset) + '%'">
          <novo-calendar-week-event
            [weekEvent]="weekEvent"
            [tooltipPosition]="tooltipPosition"
            [customTemplate]="eventTemplate"
            (eventClicked)="eventClicked.emit($event)">
          </novo-calendar-week-event>
        </div>
      </div>
      <div class="cal-hour" *ngFor="let hour of hours" [style.minWidth.px]="view?.width + 70">
        <novo-calendar-day-hour-segment
          *ngFor="let segment of hour.segments"
          [segment]="segment"
          [locale]="locale"
          [customTemplate]="hourSegmentTemplate"
          (click)="hourSegmentClicked.emit({date: segment.date})">
        </novo-calendar-day-hour-segment>
      </div>
    </div>
  `
            },] },
];
/**
 * @nocollapse
 */
NovoCalendarWeekViewElement.ctorParameters = () => [
    { type: ChangeDetectorRef, },
    { type: undefined, decorators: [{ type: Inject, args: [LOCALE_ID,] },] },
];
NovoCalendarWeekViewElement.propDecorators = {
    'viewDate': [{ type: Input },],
    'events': [{ type: Input },],
    'excludeDays': [{ type: Input },],
    'refresh': [{ type: Input },],
    'locale': [{ type: Input },],
    'tooltipPosition': [{ type: Input },],
    'weekStartsOn': [{ type: Input },],
    'headerTemplate': [{ type: Input },],
    'eventTemplate': [{ type: Input },],
    'precision': [{ type: Input },],
    'hourSegments': [{ type: Input },],
    'dayStartHour': [{ type: Input },],
    'dayStartMinute': [{ type: Input },],
    'dayEndHour': [{ type: Input },],
    'dayEndMinute': [{ type: Input },],
    'hourSegmentTemplate': [{ type: Input },],
    'hourSegmentClicked': [{ type: Output },],
    'dayClicked': [{ type: Output },],
    'eventClicked': [{ type: Output },],
    'eventTimesChanged': [{ type: Output },],
};

class NovoCalendarWeekHeaderElement {
    constructor() {
        this.dayClicked = new EventEmitter();
        this.eventDropped = new EventEmitter();
    }
}
NovoCalendarWeekHeaderElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-calendar-week-header',
                template: `
    <ng-template #defaultTemplate>
      <div class="cal-day-headers">
        <div
          class="cal-header"
          *ngFor="let day of days"
          [class.cal-past]="day.isPast"
          [class.cal-today]="day.isToday"
          [class.cal-future]="day.isFuture"
          [class.cal-weekend]="day.isWeekend"
          [class.cal-drag-over]="day.dragOver"
          (click)="dayClicked.emit({date: day.date})"
          mwlDroppable
          (dragEnter)="day.dragOver = true"
          (dragLeave)="day.dragOver = false"
          (drop)="day.dragOver = false; eventDropped.emit({event: $event.dropData.event, newStart: day.date})">
          <b>{{ day.date | weekday:locale:'long'}}</b><br>
          <span>{{ day.date | monthday:locale }}</span>
        </div>
      </div>
    </ng-template>
    <ng-template
      [ngTemplateOutlet]="customTemplate || defaultTemplate"
      [ngTemplateOutletContext]="{days: days, locale: locale, dayClicked: dayClicked, eventDropped: eventDropped}">
    </ng-template>
  `
            },] },
];
/**
 * @nocollapse
 */
NovoCalendarWeekHeaderElement.ctorParameters = () => [];
NovoCalendarWeekHeaderElement.propDecorators = {
    'days': [{ type: Input },],
    'locale': [{ type: Input },],
    'customTemplate': [{ type: Input },],
    'dayClicked': [{ type: Output },],
    'eventDropped': [{ type: Output },],
};

class NovoCalendarWeekEventElement {
    constructor() {
        this.eventClicked = new EventEmitter();
    }
}
NovoCalendarWeekEventElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-calendar-week-event',
                template: `
    <ng-template #defaultTemplate>
      <div
        class="cal-event"
        [class.cal-starts-within-week]="!weekEvent.startsBeforeWeek"
        [class.cal-ends-within-week]="!weekEvent.endsAfterWeek"
        [ngClass]="weekEvent.event?.cssClass"
        [tooltip]="weekEvent.event.description"
        [tooltipPosition]="tooltipPosition"
        (click)="eventClicked.emit({event: weekEvent.event})">
        <div class="cal-event-ribbon" [style.backgroundColor]="weekEvent.event.color.primary"></div>
        <div class="cal-event-title">{{weekEvent.event?.title}}</div>
        <div class="cal-event-description">{{weekEvent.event?.description}}</div>
      </div>
    </ng-template>
    <ng-template
      [ngTemplateOutlet]="customTemplate || defaultTemplate"
      [ngTemplateOutletContext]="{weekEvent: weekEvent, tooltipPosition: tooltipPosition, eventClicked: eventClicked}">
    </ng-template>
  `
            },] },
];
/**
 * @nocollapse
 */
NovoCalendarWeekEventElement.ctorParameters = () => [];
NovoCalendarWeekEventElement.propDecorators = {
    'weekEvent': [{ type: Input },],
    'tooltipPosition': [{ type: Input },],
    'customTemplate': [{ type: Input },],
    'eventClicked': [{ type: Output },],
};

/**
 * @hidden
 */
const SEGMENT_HEIGHT$1 = 30;
/**
 * Shows all events on a given day. Example usage:
 *
 * ```typescript
 * &lt;novo-calendar-day
 *  [viewDate]="viewDate"
 *  [events]="events"&gt;
 * &lt;/novo-calendar-day&gt;
 * ```
 */
class NovoCalendarDayViewElement {
    /**
     * @hidden
     * @param {?} cdr
     * @param {?} locale
     */
    constructor(cdr, locale) {
        this.cdr = cdr;
        /**
         * An array of events to display on view
         */
        this.events = [];
        /**
         * The number of segments in an hour. Must be <= 6
         */
        this.hourSegments = 2;
        /**
         * The day start hours in 24 hour time. Must be 0-23
         */
        this.dayStartHour = 0;
        /**
         * The day start minutes. Must be 0-59
         */
        this.dayStartMinute = 0;
        /**
         * The day end hours in 24 hour time. Must be 0-23
         */
        this.dayEndHour = 23;
        /**
         * The day end minutes. Must be 0-59
         */
        this.dayEndMinute = 59;
        /**
         * The width in pixels of each event on the view
         */
        this.eventWidth = 150;
        /**
         * The grid size to snap resizing and dragging of events to
         */
        this.eventSnapSize = 30;
        /**
         * The placement of the event tooltip
         */
        this.tooltipPosition = 'top';
        /**
         * Called when an event title is clicked
         */
        this.eventClicked = new EventEmitter();
        /**
         * Called when an hour segment is clicked
         */
        this.hourSegmentClicked = new EventEmitter();
        /**
         * Called when an event is resized or dragged and dropped
         */
        this.eventTimesChanged = new EventEmitter();
        /**
         * @hidden
         */
        this.hours = [];
        /**
         * @hidden
         */
        this.width = 0;
        this.locale = locale;
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnInit() {
        if (this.refresh) {
            this.refreshSubscription = this.refresh.subscribe(() => {
                this.refreshAll();
                this.cdr.detectChanges();
            });
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnDestroy() {
        if (this.refreshSubscription) {
            this.refreshSubscription.unsubscribe();
        }
    }
    /**
     * @hidden
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.viewDate ||
            changes.dayStartHour ||
            changes.dayStartMinute ||
            changes.dayEndHour ||
            changes.dayEndMinute) {
            this.refreshHourGrid();
        }
        if (changes.viewDate ||
            changes.events ||
            changes.dayStartHour ||
            changes.dayStartMinute ||
            changes.dayEndHour ||
            changes.dayEndMinute ||
            changes.eventWidth) {
            this.refreshView();
        }
    }
    /**
     * @return {?}
     */
    refreshHourGrid() {
        this.hours = getDayViewHourGrid({
            viewDate: this.viewDate,
            hourSegments: this.hourSegments,
            dayStart: {
                hour: this.dayStartHour,
                minute: this.dayStartMinute
            },
            dayEnd: {
                hour: this.dayEndHour,
                minute: this.dayEndMinute
            }
        });
        if (this.hourSegmentModifier) {
            this.hours.forEach(hour => {
                hour.segments.forEach(segment => this.hourSegmentModifier(segment));
            });
        }
    }
    /**
     * @return {?}
     */
    refreshView() {
        this.view = getDayView({
            events: this.events,
            viewDate: this.viewDate,
            hourSegments: this.hourSegments,
            dayStart: {
                hour: this.dayStartHour,
                minute: this.dayStartMinute
            },
            dayEnd: {
                hour: this.dayEndHour,
                minute: this.dayEndMinute
            },
            eventWidth: this.eventWidth,
            segmentHeight: SEGMENT_HEIGHT$1
        });
    }
    /**
     * @return {?}
     */
    refreshAll() {
        this.refreshHourGrid();
        this.refreshView();
    }
}
NovoCalendarDayViewElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-calendar-day',
                template: `
    <div class="cal-day-view" #dayViewContainer>
      <novo-calendar-all-day-event
        *ngFor="let event of view.allDayEvents"
        [event]="event"
        [customTemplate]="allDayEventTemplate"
        (eventClicked)="eventClicked.emit({event: event})">
      </novo-calendar-all-day-event>
      <div class="cal-hour-rows">
        <div class="cal-events">
          <div
            #event
            *ngFor="let dayEvent of view?.events"
            class="cal-event-container"
            [style.marginTop.px]="dayEvent.top"
            [style.height.px]="dayEvent.height"
            [style.marginLeft.px]="dayEvent.left + 70"
            [style.width.px]="dayEvent.width - 1">
            <novo-calendar-day-event
              [dayEvent]="dayEvent"
              [tooltipPosition]="tooltipPosition"
              [customTemplate]="eventTemplate"
              (eventClicked)="eventClicked.emit($event)">
            </novo-calendar-day-event>
          </div>
        </div>
        <div class="cal-hour" *ngFor="let hour of hours" [style.minWidth.px]="view?.width + 70">
          <novo-calendar-day-hour-segment
            *ngFor="let segment of hour.segments"
            [segment]="segment"
            [locale]="locale"
            [customTemplate]="hourSegmentTemplate"
            (click)="hourSegmentClicked.emit({date: segment.date})">
          </novo-calendar-day-hour-segment>
        </div>
      </div>
    </div>
  `
            },] },
];
/**
 * @nocollapse
 */
NovoCalendarDayViewElement.ctorParameters = () => [
    { type: ChangeDetectorRef, },
    { type: undefined, decorators: [{ type: Inject, args: [LOCALE_ID,] },] },
];
NovoCalendarDayViewElement.propDecorators = {
    'viewDate': [{ type: Input },],
    'events': [{ type: Input },],
    'hourSegments': [{ type: Input },],
    'dayStartHour': [{ type: Input },],
    'dayStartMinute': [{ type: Input },],
    'dayEndHour': [{ type: Input },],
    'dayEndMinute': [{ type: Input },],
    'eventWidth': [{ type: Input },],
    'refresh': [{ type: Input },],
    'locale': [{ type: Input },],
    'hourSegmentModifier': [{ type: Input },],
    'eventSnapSize': [{ type: Input },],
    'tooltipPosition': [{ type: Input },],
    'hourSegmentTemplate': [{ type: Input },],
    'allDayEventTemplate': [{ type: Input },],
    'eventTemplate': [{ type: Input },],
    'eventClicked': [{ type: Output },],
    'hourSegmentClicked': [{ type: Output },],
    'eventTimesChanged': [{ type: Output },],
};

class NovoCalendarDayEventElement {
    constructor() {
        this.eventClicked = new EventEmitter();
    }
}
NovoCalendarDayEventElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-calendar-day-event',
                template: `
    <ng-template #defaultTemplate>
      <div
        class="cal-event"
        [style.borderColor]="dayEvent.event.color.secondary"
        [class.cal-starts-within-day]="!dayEvent.startsBeforeDay"
        [class.cal-ends-within-day]="!dayEvent.endsAfterDay"
        [ngClass]="dayEvent.event.cssClass"
        [tooltip]="dayEvent.event.description"
        [tooltipPosition]="tooltipPosition"
        (click)="eventClicked.emit({event: dayEvent.event})">
          <div class="cal-event-ribbon" [style.backgroundColor]="dayEvent.event.color.primary"></div>
          <div class="cal-event-group">
            <div class="cal-event-title">{{dayEvent.event.title}}</div>
            <div class="cal-event-description">{{dayEvent.event?.description}}</div>
          </div>
      </div>
    </ng-template>
    <ng-template
      [ngTemplateOutlet]="customTemplate || defaultTemplate"
      [ngTemplateOutletContext]="{dayEvent: dayEvent, tooltipPosition: tooltipPosition, eventClicked: eventClicked}">
    </ng-template>
  `
            },] },
];
/**
 * @nocollapse
 */
NovoCalendarDayEventElement.ctorParameters = () => [];
NovoCalendarDayEventElement.propDecorators = {
    'dayEvent': [{ type: Input },],
    'tooltipPosition': [{ type: Input },],
    'customTemplate': [{ type: Input },],
    'eventClicked': [{ type: Output },],
};

class NovoCalendarHourSegmentElement {
}
NovoCalendarHourSegmentElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-calendar-day-hour-segment',
                template: `
    <ng-template #defaultTemplate>
      <div
        class="cal-hour-segment"
        [class.cal-hour-start]="segment.isStart"
        [class.cal-after-hour-start]="!segment.isStart"
        [ngClass]="segment.cssClass">
        <div class="cal-time">
          {{ segment.date | hours:locale }}
        </div>
      </div>
    </ng-template>
    <ng-template
      [ngTemplateOutlet]="customTemplate || defaultTemplate"
      [ngTemplateOutletContext]="{
        segment: segment,
        locale: locale
      }">
    </ng-template>
  `
            },] },
];
/**
 * @nocollapse
 */
NovoCalendarHourSegmentElement.ctorParameters = () => [];
NovoCalendarHourSegmentElement.propDecorators = {
    'segment': [{ type: Input },],
    'locale': [{ type: Input },],
    'customTemplate': [{ type: Input },],
};

class NovoCalendarAllDayEventElement {
    constructor() {
        this.eventClicked = new EventEmitter();
    }
}
NovoCalendarAllDayEventElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-calendar-all-day-event',
                template: `
    <ng-template #defaultTemplate>
      <div
        class="cal-all-day-event"
        [style.backgroundColor]="event.color.secondary"
        [style.borderColor]="event.color.primary">
        {{event.title}}
        <!--<novo-calendar-event-title
          [event]="event"
          view="day"
          (click)="eventClicked.emit()">
        </novo-calendar-event-title>
        <novo-calendar-event-actions [event]="event"></novo-calendar-event-actions>-->
      </div>
    </ng-template>
    <ng-template
      [ngTemplateOutlet]="customTemplate || defaultTemplate"
      [ngTemplateOutletContext]="{
        event: event,
        eventClicked: eventClicked
      }">
    </ng-template>
  `
            },] },
];
/**
 * @nocollapse
 */
NovoCalendarAllDayEventElement.ctorParameters = () => [];
NovoCalendarAllDayEventElement.propDecorators = {
    'event': [{ type: Input },],
    'customTemplate': [{ type: Input },],
    'eventClicked': [{ type: Output },],
};

class WeekdayPipe {
    /**
     * @param {?=} locale
     */
    constructor(locale = 'en-US') {
        this.locale = locale;
    }
    /**
     * @param {?} date
     * @param {?=} locale
     * @param {?=} method
     * @return {?}
     */
    transform(date, locale = this.locale, method = 'short') {
        return new Intl.DateTimeFormat(locale, { weekday: method }).format(date);
    }
}
WeekdayPipe.decorators = [
    { type: Pipe, args: [{ name: 'weekday' },] },
];
/**
 * @nocollapse
 */
WeekdayPipe.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [LOCALE_ID,] },] },
];

class MonthPipe {
    /**
     * @param {?=} locale
     */
    constructor(locale = 'en-US') {
        this.locale = locale;
    }
    /**
     * @param {?} date
     * @param {?=} locale
     * @param {?=} method
     * @return {?}
     */
    transform(date, locale = this.locale, method = 'long') {
        return new Intl.DateTimeFormat(locale, { month: method }).format(date);
    }
}
MonthPipe.decorators = [
    { type: Pipe, args: [{ name: 'month' },] },
];
/**
 * @nocollapse
 */
MonthPipe.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [LOCALE_ID,] },] },
];

class MonthDayPipe {
    /**
     * @param {?=} locale
     */
    constructor(locale = 'en-US') {
        this.locale = locale;
    }
    /**
     * @param {?} date
     * @param {?=} locale
     * @param {?=} method
     * @return {?}
     */
    transform(date, locale = this.locale, method = 'short') {
        return new Intl.DateTimeFormat(locale, { month: method, day: 'numeric' }).format(date);
    }
}
MonthDayPipe.decorators = [
    { type: Pipe, args: [{ name: 'monthday' },] },
];
/**
 * @nocollapse
 */
MonthDayPipe.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [LOCALE_ID,] },] },
];

class YearPipe {
    /**
     * @param {?=} locale
     */
    constructor(locale = 'en-US') {
        this.locale = locale;
    }
    /**
     * @param {?} date
     * @param {?=} locale
     * @param {?=} method
     * @return {?}
     */
    transform(date, locale = this.locale, method = 'numeric') {
        return new Intl.DateTimeFormat(locale, { year: method }).format(date);
    }
}
YearPipe.decorators = [
    { type: Pipe, args: [{ name: 'year' },] },
];
/**
 * @nocollapse
 */
YearPipe.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [LOCALE_ID,] },] },
];

class HoursPipe {
    /**
     * @param {?=} locale
     */
    constructor(locale = 'en-US') {
        this.locale = locale;
    }
    /**
     * @param {?} date
     * @param {?=} locale
     * @param {?=} method
     * @return {?}
     */
    transform(date, locale = this.locale, method = 'numeric') {
        return new Intl.DateTimeFormat(locale, { hour: method }).format(date);
    }
}
HoursPipe.decorators = [
    { type: Pipe, args: [{ name: 'hours' },] },
];
/**
 * @nocollapse
 */
HoursPipe.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [LOCALE_ID,] },] },
];

class DayOfMonthPipe {
    /**
     * @param {?=} locale
     */
    constructor(locale = 'en-US') {
        this.locale = locale;
    }
    /**
     * @param {?} date
     * @param {?=} locale
     * @param {?=} method
     * @return {?}
     */
    transform(date, locale = this.locale, method = 'numeric') {
        return new Intl.DateTimeFormat(locale, { day: method }).format(date);
    }
}
DayOfMonthPipe.decorators = [
    { type: Pipe, args: [{ name: 'dayofmonth' },] },
];
/**
 * @nocollapse
 */
DayOfMonthPipe.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [LOCALE_ID,] },] },
];

class EndOfWeekDisplayPipe {
    /**
     * @param {?=} locale
     */
    constructor(locale = 'en-US') {
        this.locale = locale;
    }
    /**
     * @param {?} endOfWeek
     * @param {?} startOfWeek
     * @param {?=} locale
     * @param {?=} method
     * @return {?}
     */
    transform(endOfWeek$$1, startOfWeek$$1, locale = this.locale, method = 'short') {
        if (endOfWeek$$1.getMonth() === startOfWeek$$1.getMonth()) {
            return new Intl.DateTimeFormat(locale, { day: 'numeric' }).format(endOfWeek$$1);
        }
        return new Intl.DateTimeFormat(locale, { month: method, day: 'numeric' }).format(endOfWeek$$1);
    }
}
EndOfWeekDisplayPipe.decorators = [
    { type: Pipe, args: [{ name: 'endofweekdisplay' },] },
];
/**
 * @nocollapse
 */
EndOfWeekDisplayPipe.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [LOCALE_ID,] },] },
];

// NG2
// APP
// Common Elements
// Month View
// Week View
// Day View
// Common
class NovoCalendarModule {
}
NovoCalendarModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, NovoButtonModule, NovoTooltipModule, NovoPipesModule],
                declarations: [
                    NovoEventTypeLegendElement,
                    NovoCalendarMonthViewElement,
                    NovoCalendarMonthHeaderElement,
                    NovoCalendarMonthDayElement,
                    NovoCalendarWeekViewElement,
                    NovoCalendarWeekHeaderElement,
                    NovoCalendarWeekEventElement,
                    NovoCalendarDayViewElement,
                    NovoCalendarDayEventElement,
                    NovoCalendarHourSegmentElement,
                    NovoCalendarAllDayEventElement,
                    NovoCalendarDateChangeElement,
                    WeekdayPipe,
                    DayOfMonthPipe,
                    MonthPipe,
                    MonthDayPipe,
                    YearPipe,
                    HoursPipe,
                    EndOfWeekDisplayPipe
                ],
                exports: [
                    NovoEventTypeLegendElement,
                    NovoCalendarMonthViewElement,
                    NovoCalendarMonthHeaderElement,
                    NovoCalendarMonthDayElement,
                    NovoCalendarWeekViewElement,
                    NovoCalendarWeekHeaderElement,
                    NovoCalendarWeekEventElement,
                    NovoCalendarDayViewElement,
                    NovoCalendarDayEventElement,
                    NovoCalendarHourSegmentElement,
                    NovoCalendarAllDayEventElement,
                    NovoCalendarDateChangeElement,
                    WeekdayPipe,
                    DayOfMonthPipe,
                    MonthPipe,
                    MonthDayPipe,
                    YearPipe,
                    HoursPipe,
                    EndOfWeekDisplayPipe
                ]
            },] },
];
/**
 * @nocollapse
 */
NovoCalendarModule.ctorParameters = () => [];

// NG2
class NovoToastElement {
    constructor() {
        this.theme = 'danger';
        this.icon = 'caution';
        this.hasDialogue = false;
        this.isCloseable = false;
        this.show = false;
        this.animate = false;
        this.parent = null;
        this.launched = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.launched) {
            // clear position and time
            this.position = null;
            this.time = null;
            // set icon and styling
            this.iconClass = `bhi-${this.icon}`;
            this.alertTheme = `${this.theme} toast-container embedded`;
            if (this.hasDialogue) {
                this.alertTheme += ' dialogue';
            }
        }
    }
    /**
     * @param {?=} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        // set icon and styling
        this.iconClass = `bhi-${this.icon}`;
        this.alertTheme = `${this.theme} toast-container embedded`;
        if (this.hasDialogue) {
            this.alertTheme += ' dialogue';
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    clickHandler(event) {
        if (!this.isCloseable) {
            if (event) {
                event.stopPropagation();
                event.preventDefault();
            }
            if (this.parent) {
                this.parent.hide(this);
            }
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    close(event) {
        if (event) {
            event.stopPropagation();
            event.preventDefault();
        }
        this.parent.hide(this);
    }
}
NovoToastElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-toast',
                host: {
                    '[class]': 'alertTheme',
                    '[class.show]': 'show',
                    '[class.animate]': 'animate',
                    '[class.embedded]': 'embedded',
                    '(click)': '!isCloseable && clickHandler($event)'
                },
                template: `
        <div class="toast-icon">
            <i [ngClass]="iconClass"></i>
        </div>
        <div class="toast-content">
            <h5 *ngIf="title">{{title}}</h5>
            <p *ngIf="message" [class.message-only]="!title">{{message}}</p>
            <div *ngIf="link" class="link-generated">
                <input type="text" [value]="link" onfocus="this.select();"/>
            </div>
            <div class="dialogue">
                <ng-content></ng-content>
            </div>
        </div>
        <div class="close-icon" *ngIf="isCloseable" (click)="close($event)">
            <i class="bhi-times"></i>
        </div>
    `
            },] },
];
/**
 * @nocollapse
 */
NovoToastElement.ctorParameters = () => [];
NovoToastElement.propDecorators = {
    'theme': [{ type: Input },],
    'icon': [{ type: Input },],
    'title': [{ type: Input },],
    'message': [{ type: Input },],
    'hasDialogue': [{ type: Input },],
    'link': [{ type: Input },],
    'isCloseable': [{ type: Input },],
};

// NG2
// APP
class NovoToastModule {
}
NovoToastModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                declarations: [NovoToastElement],
                exports: [NovoToastElement],
                entryComponents: [NovoToastElement]
            },] },
];
/**
 * @nocollapse
 */
NovoToastModule.ctorParameters = () => [];

// NG2
class UtilsElement {
}
UtilsElement.decorators = [
    { type: Component, args: [{
                selector: 'utils',
                template: `
        <ng-content></ng-content>
    `
            },] },
];
/**
 * @nocollapse
 */
UtilsElement.ctorParameters = () => [];
class UtilActionElement {
}
UtilActionElement.decorators = [
    { type: Component, args: [{
                selector: 'util-action',
                template: `
        <button theme="icon" [icon]="icon" [attr.inverse]="inverse" [disabled]="disabled"></button>
    `
            },] },
];
/**
 * @nocollapse
 */
UtilActionElement.ctorParameters = () => [];
UtilActionElement.propDecorators = {
    'icon': [{ type: Input },],
    'inverse': [{ type: Input },],
    'disabled': [{ type: Input },],
};
class NovoHeaderElement {
    constructor() {
        this.inverse = 'inverse';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.iconClass = `bhi-${this.icon}`;
        this.config = this.config || {};
        this.inverse = (this.theme === 'white' || this.theme === 'off-white' || this.theme === 'light') ? null : 'inverse';
    }
}
NovoHeaderElement.decorators = [
    { type: Component, args: [{
                selector: 'header[theme]',
                host: {
                    '[attr.theme]': 'theme'
                },
                template: `
        <section>
            <div>
                <i *ngIf="icon" class="header-icon" [ngClass]="iconClass"></i>
                <div class="header-titles">
                    <h1>{{ title || config.title }}</h1>
                    <small *ngIf="subTitle">{{ subTitle || config.subTitle }}</small>
                </div>
            </div>
            <ng-content select="section"></ng-content>
            <ng-content select="utils"></ng-content>
        </section>
        <ng-content></ng-content>
    `
            },] },
];
/**
 * @nocollapse
 */
NovoHeaderElement.ctorParameters = () => [];
NovoHeaderElement.propDecorators = {
    'title': [{ type: Input },],
    'subTitle': [{ type: Input },],
    'theme': [{ type: Input },],
    'icon': [{ type: Input },],
    'config': [{ type: Input },],
};

// NG2
// APP
class NovoHeaderModule {
}
NovoHeaderModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, NovoButtonModule],
                declarations: [NovoHeaderElement, UtilActionElement, UtilsElement],
                exports: [NovoHeaderElement, UtilActionElement, UtilsElement]
            },] },
];
/**
 * @nocollapse
 */
NovoHeaderModule.ctorParameters = () => [];

// NG2
class NovoNavElement {
    constructor() {
        this.theme = '';
        this.direction = '';
        this.condensed = false;
        this.items = [];
    }
    /**
     * @param {?} item
     * @return {?}
     */
    select(item) {
        /**
         * Deactivate all other tabs
         * @param {?} items
         * @return {?}
         */
        function _deactivateAllItems(items) {
            items.forEach((t) => {
                if (t.active === true) {
                    // t.deselected.next();
                }
                t.active = false;
            });
        }
        _deactivateAllItems(this.items);
        item.active = true;
        if (this.outlet) {
            this.outlet.show(this.items.indexOf(item));
        }
        // TODO - remove hack to make DOM rerender - jgodi
        let /** @type {?} */ element = (document.querySelector('novo-tab-link.active span.indicator'));
        if (element) {
            element.style.opacity = 0.99;
            setTimeout(() => {
                element.style.opacity = 1;
            }, 10);
        }
    }
    /**
     * @param {?} item
     * @return {?}
     */
    add(item) {
        if (this.items.length === 0) {
            item.active = true;
            // item.selected.next();
        }
        this.items.push(item);
    }
}
NovoNavElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-nav',
                template: '<ng-content></ng-content>'
            },] },
];
/**
 * @nocollapse
 */
NovoNavElement.ctorParameters = () => [];
NovoNavElement.propDecorators = {
    'theme': [{ type: Input },],
    'direction': [{ type: Input },],
    'outlet': [{ type: Input },],
    'router': [{ type: Input },],
    'condensed': [{ type: HostBinding, args: ['class.condensed',] }, { type: Input },],
};
class NovoTabElement {
    /**
     * @param {?} nav
     */
    constructor(nav) {
        this.active = false;
        this.disabled = false;
        this.activeChange = new EventEmitter();
        this.nav = nav;
        this.nav.add(this);
    }
    /**
     * @return {?}
     */
    select() {
        if (!this.disabled) {
            this.activeChange.emit(true);
            this.nav.select(this);
        }
    }
}
NovoTabElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-tab',
                host: {
                    '(click)': 'select()',
                    '[class.active]': 'active',
                    '[class.disabled]': 'disabled'
                },
                template: `
        <div class="novo-tab-link">
            <ng-content></ng-content>
        </div>
        <span class="indicator"></span>
   `
            },] },
];
/**
 * @nocollapse
 */
NovoTabElement.ctorParameters = () => [
    { type: NovoNavElement, },
];
NovoTabElement.propDecorators = {
    'active': [{ type: Input },],
    'disabled': [{ type: Input },],
    'activeChange': [{ type: Output },],
};
class NovoTabButtonElement {
    /**
     * @param {?} nav
     */
    constructor(nav) {
        this.active = false;
        this.disabled = false;
        this.nav = nav;
        this.nav.add(this);
    }
    /**
     * @return {?}
     */
    select() {
        if (!this.disabled) {
            this.nav.select(this);
        }
    }
}
NovoTabButtonElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-tab-button',
                host: {
                    '(click)': 'select()',
                    '[class.active]': 'active',
                    '[class.disabled]': 'disabled'
                },
                template: '<ng-content></ng-content>'
            },] },
];
/**
 * @nocollapse
 */
NovoTabButtonElement.ctorParameters = () => [
    { type: NovoNavElement, },
];
NovoTabButtonElement.propDecorators = {
    'active': [{ type: Input },],
    'disabled': [{ type: Input },],
};
class NovoTabLinkElement {
    /**
     * @param {?} nav
     */
    constructor(nav) {
        this.active = false;
        this.disabled = false;
        this.nav = nav;
        this.nav.add(this);
    }
    /**
     * @return {?}
     */
    select() {
        if (!this.disabled) {
            this.nav.select(this);
        }
    }
}
NovoTabLinkElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-tab-link',
                host: {
                    '(click)': 'select()',
                    '[class.active]': 'active',
                    '[class.disabled]': 'disabled'
                },
                template: `
        <div class="novo-tab-link">
            <ng-content></ng-content>
        </div>
        <span class="indicator"></span>
    `
            },] },
];
/**
 * @nocollapse
 */
NovoTabLinkElement.ctorParameters = () => [
    { type: NovoNavElement, },
];
NovoTabLinkElement.propDecorators = {
    'active': [{ type: Input },],
    'disabled': [{ type: Input },],
};
class NovoNavOutletElement {
    constructor() {
        this.items = [];
    }
    /**
     * @param {?} index
     * @return {?}
     */
    show(index) {
        let /** @type {?} */ item = this.items[index];
        /**
         * Deactivates other tab items
         * @param {?} items - deactivated items
         * @return {?}
         */
        function _deactivateAllItems(items) {
            items.forEach((t) => {
                if (t.active === true) {
                    // t.deselected.next();
                }
                t.active = false;
            });
        }
        _deactivateAllItems(this.items);
        item.active = true;
    }
    /**
     * @param {?} item
     * @return {?}
     */
    add(item) {
        if (this.items.length === 0) {
            item.active = true;
        }
        this.items.push(item);
    }
}
NovoNavOutletElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-nav-outlet',
                template: '<ng-content></ng-content>'
            },] },
];
/**
 * @nocollapse
 */
NovoNavOutletElement.ctorParameters = () => [];
class NovoNavContentElement {
    /**
     * @param {?} outlet
     */
    constructor(outlet) {
        this.active = false;
        outlet.add(this);
    }
}
NovoNavContentElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-nav-content',
                host: {
                    '[class.active]': 'active'
                },
                template: '<ng-content></ng-content>'
            },] },
];
/**
 * @nocollapse
 */
NovoNavContentElement.ctorParameters = () => [
    { type: NovoNavOutletElement, },
];
NovoNavContentElement.propDecorators = {
    'active': [{ type: Input },],
};
class NovoNavHeaderElement {
    /**
     * @param {?} outlet
     */
    constructor(outlet) {
        this.active = false;
        this.active = this.active || false;
        this.outlet = outlet;
    }
    /**
     * @param {?=} event
     * @return {?}
     */
    show(event) {
        try {
            const /** @type {?} */ INDEX = this.outlet.items.indexOf(this.forElement);
            if (INDEX > -1) {
                this.outlet.show(INDEX);
            }
        }
        catch (err) {
            // do nothing
        }
    }
}
NovoNavHeaderElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-nav-header',
                host: {
                    '[class.active]': 'active',
                    '(click)': 'show($event)'
                },
                template: '<ng-content></ng-content>'
            },] },
];
/**
 * @nocollapse
 */
NovoNavHeaderElement.ctorParameters = () => [
    { type: NovoNavOutletElement, },
];
NovoNavHeaderElement.propDecorators = {
    'active': [{ type: Input },],
    'forElement': [{ type: Input, args: ['for',] },],
};

// NG2
// APP
class NovoTabModule {
}
NovoTabModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                declarations: [
                    NovoNavElement,
                    NovoTabElement,
                    NovoTabButtonElement,
                    NovoTabLinkElement,
                    NovoNavOutletElement,
                    NovoNavContentElement,
                    NovoNavHeaderElement
                ],
                exports: [
                    NovoNavElement,
                    NovoTabElement,
                    NovoTabButtonElement,
                    NovoTabLinkElement,
                    NovoNavOutletElement,
                    NovoNavContentElement,
                    NovoNavHeaderElement
                ]
            },] },
];
/**
 * @nocollapse
 */
NovoTabModule.ctorParameters = () => [];

// NG2
// APP
// Value accessor for the component (supports ngModel)
const TILES_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => NovoTilesElement),
    multi: true
};
class NovoTilesElement {
    /**
     * @param {?} element
     * @param {?} ref
     */
    constructor(element, ref) {
        this.element = element;
        this.ref = ref;
        this.onChange = new EventEmitter();
        this.onDisabledOptionClick = new EventEmitter();
        this._options = [];
        this.activeTile = null;
        this.state = 'inactive';
        this.focused = false;
        this.onModelChange = () => {
        };
        this.onModelTouched = () => {
        };
    }
    /**
     * @param {?} focus
     * @return {?}
     */
    setFocus(focus) {
        this.focused = focus;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.name = this.name || '';
        this.setupOptions();
    }
    /**
     * @param {?} change
     * @return {?}
     */
    ngOnChanges(change) {
        if (change['options'] && change['options'].currentValue && !change['options'].firstChange) {
            this.name = this.name || '';
            this._options = [];
            this.setupOptions();
        }
    }
    /**
     * @return {?}
     */
    setupOptions() {
        if (this.options && this.options.length && (this.options[0].value === undefined || this.options[0].value === null)) {
            this._options = this.options.map((x) => {
                let /** @type {?} */ item = { value: x, label: x, checked: this.model === x };
                if (item.checked) {
                    this.setTile(item);
                }
                return item;
            });
        }
        else {
            this._options = this.options.map((x) => {
                x.checked = this.model === x.value;
                if (x.checked) {
                    this.setTile(x);
                }
                return x;
            });
        }
        this.ref.markForCheck();
    }
    /**
     * @param {?} event
     * @param {?} item
     * @return {?}
     */
    select(event, item) {
        if (event) {
            event.stopPropagation();
            event.preventDefault();
        }
        if (item.checked) {
            return;
        }
        if (!item.disabled) {
            for (let /** @type {?} */ option of this._options) {
                option.checked = false;
            }
            item.checked = !item.checked;
            this.onChange.emit(item.value);
            this.onModelChange(item.value);
            this.setTile(item);
            this.model = item.value;
        }
        else {
            this.onDisabledOptionClick.emit(item);
        }
        this.ref.markForCheck();
    }
    /**
     * @param {?} item
     * @return {?}
     */
    setTile(item) {
        if (item) {
            this.activeTile = item.value;
            this.moveTile();
        }
    }
    /**
     * @return {?}
     */
    moveTile() {
        setTimeout(() => {
            let /** @type {?} */ ind = this.element.nativeElement.querySelector('.active-indicator');
            let /** @type {?} */ el = this.element.nativeElement.querySelector('.tile.active');
            if (ind && el) {
                let /** @type {?} */ w = el.clientWidth;
                let /** @type {?} */ left = el.offsetLeft;
                // These style adjustments need to occur in this order.
                setTimeout(() => {
                    ind.style.width = `${w + 4}px`;
                    setTimeout(() => {
                        ind.style.transform = `translateX(${left}px)`;
                        setTimeout(() => {
                            this.state = 'active';
                            this.ref.markForCheck();
                        });
                    });
                });
            }
        });
    }
    /**
     * @param {?} model
     * @return {?}
     */
    writeValue(model) {
        this.model = model;
        if (!Helpers.isBlank(model)) {
            this.setupOptions();
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onModelChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onModelTouched = fn;
    }
}
NovoTilesElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-tiles',
                providers: [TILES_VALUE_ACCESSOR],
                template: `
        <div class="tile-container" [class.active]="focused">
            <div class="tile" *ngFor="let option of _options; let i = index" [ngClass]="{active: option.checked, disabled: option.disabled}" (click)="select($event, option, i)" [attr.data-automation-id]="option.label || option">
                <input class="tiles-input" [name]="name" type="radio" [value]="option.checked || option" [attr.id]="name + i" (change)="select($event, option, i)" (focus)="setFocus(true)" (blur)="setFocus(false)">
                <label [attr.for]="name + i" [attr.data-automation-id]="option.label || option">
                    {{ option.label || option}}
                </label>
            </div>
            <span class="active-indicator" [@tileState]="state" [hidden]="activeTile === undefined || activeTile === null"></span>
        </div>
    `,
                animations: [
                    trigger('tileState', [
                        state('inactive', style({
                            opacity: '0'
                        })),
                        state('active', style({
                            opacity: '1'
                        })),
                        transition('inactive => active', animate('200ms ease-in')),
                        transition('active => inactive', animate('200ms ease-out'))
                    ])
                ],
                changeDetection: ChangeDetectionStrategy.OnPush,
            },] },
];
/**
 * @nocollapse
 */
NovoTilesElement.ctorParameters = () => [
    { type: ElementRef, },
    { type: ChangeDetectorRef, },
];
NovoTilesElement.propDecorators = {
    'name': [{ type: Input },],
    'options': [{ type: Input },],
    'required': [{ type: Input },],
    'onChange': [{ type: Output },],
    'onDisabledOptionClick': [{ type: Output },],
};

// NG2
// APP
class NovoTilesModule {
}
NovoTilesModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, ReactiveFormsModule],
                declarations: [NovoTilesElement],
                exports: [NovoTilesElement]
            },] },
];
/**
 * @nocollapse
 */
NovoTilesModule.ctorParameters = () => [];

/**
 * A Promise that uses the deferred anti-pattern
 * @return {?}
 */
function Deferred() {
    const /** @type {?} */ temp = {};
    const /** @type {?} */ promise = new Promise((resolve, reject) => {
        temp.resolve = resolve;
        temp.reject = reject;
    });
    promise.resolve = temp.resolve;
    promise.reject = temp.reject;
    return promise;
}

// NG2
class ComponentUtils {
    /**
     * @param {?} componentFactoryResolver
     */
    constructor(componentFactoryResolver) {
        this.componentFactoryResolver = componentFactoryResolver;
    }
    /**
     * @param {?} ComponentClass
     * @param {?} location
     * @param {?=} providers
     * @return {?}
     */
    appendNextToLocation(ComponentClass, location, providers) {
        let /** @type {?} */ componentFactory = this.componentFactoryResolver.resolveComponentFactory(ComponentClass);
        let /** @type {?} */ parentInjector = location.parentInjector;
        let /** @type {?} */ childInjector = parentInjector;
        if (providers && providers.length > 0) {
            childInjector = ReflectiveInjector.fromResolvedProviders(providers, parentInjector);
        }
        return location.createComponent(componentFactory, location.length, childInjector);
    }
}
ComponentUtils.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
ComponentUtils.ctorParameters = () => [
    { type: ComponentFactoryResolver, },
];

// NG2
// APP
class NovoModalParams {
}
/**
 * Reference to an opened dialog.
 */
class NovoModalRef {
    constructor() {
        this.component = null;
        this.contentRef = null;
        this.containerRef = null;
        this.isClosed = false;
        this._onClosed = Deferred();
    }
    /**
     * @return {?}
     */
    get onClosed() {
        return this._onClosed;
    }
    /**
     * @return {?}
     */
    open() {
        document.body.classList.add('modal-open');
    }
    /**
     * @param {?=} result
     * @return {?}
     */
    close(result) {
        document.body.classList.remove('modal-open');
        if (this.contentRef) {
            this.contentRef.destroy();
        }
        if (this.containerRef) {
            this.containerRef.destroy();
        }
        this._onClosed.resolve(result);
    }
}
NovoModalRef.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
NovoModalRef.ctorParameters = () => [];
class NovoModalContainerElement {
    /**
     * @param {?} modalRef
     * @param {?} componentUtils
     */
    constructor(modalRef, componentUtils) {
        this.modalRef = modalRef;
        this.componentUtils = componentUtils;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        setTimeout(() => {
            this.modalRef.contentRef = this.componentUtils.appendNextToLocation(this.modalRef.component, this.container);
        });
    }
}
NovoModalContainerElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-modal-container',
                template: '<span #container></span>'
            },] },
];
/**
 * @nocollapse
 */
NovoModalContainerElement.ctorParameters = () => [
    { type: NovoModalRef, },
    { type: ComponentUtils, },
];
NovoModalContainerElement.propDecorators = {
    'container': [{ type: ViewChild, args: ['container', { read: ViewContainerRef },] },],
};
class NovoModalElement {
    /**
     * @param {?} modalRef
     */
    constructor(modalRef) {
        this.modalRef = modalRef;
    }
    /**
     * @return {?}
     */
    close() {
        this.modalRef.close();
    }
}
NovoModalElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-modal',
                template: `
        <ng-content select="header"></ng-content>
        <ng-content select="section"></ng-content>
        <footer>
            <ng-content select="button"></ng-content>
        </footer>
    `
            },] },
];
/**
 * @nocollapse
 */
NovoModalElement.ctorParameters = () => [
    { type: NovoModalRef, },
];
class NovoModalNotificationElement {
    /**
     * @param {?} modalRef
     */
    constructor(modalRef) {
        this.modalRef = modalRef;
        this.cancel = new EventEmitter();
        this.modalRef = modalRef;
    }
    /**
     * @return {?}
     */
    close() {
        this.cancel.emit();
        this.modalRef.close();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        switch (this.type) {
            case 'success':
                this.iconType = 'bhi-check';
                break;
            case 'warning':
                this.iconType = 'bhi-caution-o';
                break;
            case 'error':
                this.iconType = 'bhi-caution-o';
                break;
            case 'custom':
                this.iconType = `bhi-${this.icon}`;
                break;
            default:
                break;
        }
    }
}
NovoModalNotificationElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-notification',
                template: `
        <button class="modal-close" theme="icon" icon="times" (click)="close()"></button>
        <header>
            <ng-content select="label"></ng-content>
        </header>
        <section class="notification-body">
            <i class="indicator" [ngClass]="iconType" *ngIf="iconType"></i>
            <ng-content select="h1"></ng-content>
            <ng-content select="h2"></ng-content>
            <ng-content select="p"></ng-content>
        </section>
        <footer>
            <ng-content select="button"></ng-content>
        </footer>
    `
            },] },
];
/**
 * @nocollapse
 */
NovoModalNotificationElement.ctorParameters = () => [
    { type: NovoModalRef, },
];
NovoModalNotificationElement.propDecorators = {
    'type': [{ type: Input },],
    'icon': [{ type: Input },],
    'cancel': [{ type: Output },],
};

// NG2
// APP
class NovoModalModule {
}
NovoModalModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, NovoButtonModule],
                declarations: [NovoModalContainerElement, NovoModalElement, NovoModalNotificationElement],
                exports: [NovoModalElement, NovoModalNotificationElement],
                entryComponents: [NovoModalContainerElement]
            },] },
];
/**
 * @nocollapse
 */
NovoModalModule.ctorParameters = () => [];

// NG2
class NovoListElement {
    /**
     * @param {?} element
     */
    constructor(element) {
        this.element = element;
    }
}
NovoListElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-list',
                host: {
                    '[class.vertical-list]': 'direction === "vertical"',
                    '[class.horizontal-list]': 'direction === "horizontal"',
                    '[attr.theme]': 'theme'
                },
                template: `
        <ng-content></ng-content>
    `
            },] },
];
/**
 * @nocollapse
 */
NovoListElement.ctorParameters = () => [
    { type: ElementRef, },
];
NovoListElement.propDecorators = {
    'theme': [{ type: Input },],
    'direction': [{ type: Input },],
};
class NovoListItemElement {
    /**
     * @param {?} element
     */
    constructor(element) {
        this.element = element;
        this.avatar = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.avatar = !!this.element.nativeElement.querySelector('item-avatar');
    }
}
NovoListItemElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-list-item',
                template: `
        <div class="list-item" [ngClass]="{'avatar': avatar}">
            <ng-content select="item-header"></ng-content>
            <ng-content select="item-content"></ng-content>
        </div>
        <ng-content select="item-end"></ng-content>
    `
            },] },
];
/**
 * @nocollapse
 */
NovoListItemElement.ctorParameters = () => [
    { type: ElementRef, },
];
class NovoItemAvatarElement {
    /**
     * @param {?=} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this.iconClass = (this.icon) ? `bhi-${this.icon}` : null;
        this.classMap = [this.iconClass, this.icon];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.ngOnChanges();
    }
}
NovoItemAvatarElement.decorators = [
    { type: Component, args: [{
                selector: 'item-avatar',
                template: `
        <i *ngIf="iconClass" [ngClass]="classMap" theme="contained"></i>
    `
            },] },
];
/**
 * @nocollapse
 */
NovoItemAvatarElement.ctorParameters = () => [];
NovoItemAvatarElement.propDecorators = {
    'icon': [{ type: Input },],
};
class NovoItemTitleElement {
}
NovoItemTitleElement.decorators = [
    { type: Component, args: [{
                selector: 'item-title',
                template: `
        <h6><ng-content></ng-content></h6>
    `
            },] },
];
/**
 * @nocollapse
 */
NovoItemTitleElement.ctorParameters = () => [];
class NovoItemHeaderElement {
}
NovoItemHeaderElement.decorators = [
    { type: Component, args: [{
                selector: 'item-header',
                template: `
        <ng-content select="item-avatar"></ng-content>
        <ng-content select="item-title"></ng-content>
        <ng-content select="item-header-end"></ng-content>
    `
            },] },
];
/**
 * @nocollapse
 */
NovoItemHeaderElement.ctorParameters = () => [];
class NovoItemDateElement {
}
NovoItemDateElement.decorators = [
    { type: Component, args: [{
                selector: 'item-header-end',
                template: `
        <ng-content></ng-content>
    `
            },] },
];
/**
 * @nocollapse
 */
NovoItemDateElement.ctorParameters = () => [];
class NovoItemContentElement {
}
NovoItemContentElement.decorators = [
    { type: Component, args: [{
                selector: 'item-content',
                host: {
                    '[class.vertical-list]': 'direction === "vertical"',
                    '[class.horizontal-list]': 'direction === "horizontal"'
                },
                template: `
        <ng-content></ng-content>
    `
            },] },
];
/**
 * @nocollapse
 */
NovoItemContentElement.ctorParameters = () => [];
NovoItemContentElement.propDecorators = {
    'direction': [{ type: Input },],
};
class NovoItemEndElement {
}
NovoItemEndElement.decorators = [
    { type: Component, args: [{
                selector: 'item-end',
                template: `
        <ng-content></ng-content>
    `
            },] },
];
/**
 * @nocollapse
 */
NovoItemEndElement.ctorParameters = () => [];

// NG2
// APP
class NovoListModule {
}
NovoListModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                declarations: [NovoListElement, NovoListItemElement, NovoItemAvatarElement, NovoItemTitleElement, NovoItemContentElement, NovoItemEndElement, NovoItemHeaderElement, NovoItemDateElement],
                exports: [NovoListElement, NovoListItemElement, NovoItemAvatarElement, NovoItemTitleElement, NovoItemHeaderElement, NovoItemContentElement, NovoItemEndElement, NovoItemDateElement]
            },] },
];
/**
 * @nocollapse
 */
NovoListModule.ctorParameters = () => [];

// NG2
// APP
/**
 * Outside click helper, makes to set the element as inactive when clicking outside of it
 */
class OutsideClick {
    /**
     * @param {?} element
     */
    constructor(element) {
        this.active = false;
        this.onActiveChange = new EventEmitter();
        // Component element
        this.element = element;
        // Outside click handler
        // Property because `this.func.bind(this)` returns a new function each time
        this.onOutsideClick = this.handleOutsideClick.bind(this);
    }
    /**
     * When the element is destroyed, make sure to remove the handler
     * @return {?}
     */
    ngOnDestroy() {
        window.removeEventListener('click', this.onOutsideClick);
    }
    /**
     * Toggles the element as active and adds/removes the outside click handler
     * @param {?=} event
     * @param {?=} forceValue
     * @return {?}
     */
    toggleActive(event, forceValue) {
        // Reverse the active property (if forceValue, use that)
        this.active = !Helpers.isBlank(forceValue) ? forceValue : !this.active;
        // Bind window click events to hide on outside click
        if (this.active) {
            window.addEventListener('click', this.onOutsideClick);
        }
        else {
            window.removeEventListener('click', this.onOutsideClick);
        }
        // Fire the active change event
        this.onActiveChange.emit(this.active);
    }
    /**
     * When clicking outside, checks the element and closes if outside
     * @param {?} event
     * @return {?}
     */
    handleOutsideClick(event) {
        // If the elements doesn't contain the target element, it is an outside click
        let /** @type {?} */ outsideClick = !this.element.nativeElement.contains(event.target);
        if (this.otherElement && outsideClick) {
            outsideClick = !this.otherElement.nativeElement.contains(event.target);
        }
        if (outsideClick) {
            this.toggleActive(event, false);
        }
    }
}

// Helper to keep track of key codes
const KeyCodes = {
    BACKSPACE: 8,
    TAB: 9,
    NUM_CENTER: 12,
    ENTER: 13,
    RETURN: 13,
    SHIFT: 16,
    CTRL: 17,
    ALT: 18,
    PAUSE: 19,
    CAPS_LOCK: 20,
    ESC: 27,
    SPACE: 32,
    PAGE_UP: 33,
    PAGE_DOWN: 34,
    HASH_SYMBOL: 35,
    HOME: 36,
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,
    PRINT_SCREEN: 44,
    INSERT: 45,
    DELETE: 46,
    ZERO: 48,
    ONE: 49,
    TWO: 50,
    THREE: 51,
    FOUR: 52,
    FIVE: 53,
    SIX: 54,
    SEVEN: 55,
    EIGHT: 56,
    NINE: 57,
    AT_SYMBOL: 64,
    A: 65,
    B: 66,
    C: 67,
    D: 68,
    E: 69,
    F: 70,
    G: 71,
    H: 72,
    I: 73,
    J: 74,
    K: 75,
    L: 76,
    M: 77,
    N: 78,
    O: 79,
    P: 80,
    Q: 81,
    R: 82,
    S: 83,
    T: 84,
    U: 85,
    V: 86,
    W: 87,
    X: 88,
    Y: 89,
    Z: 90,
    CONTEXT_MENU: 93,
    NUM_ZERO: 96,
    NUM_ONE: 97,
    NUM_TWO: 98,
    NUM_THREE: 99,
    NUM_FOUR: 100,
    NUM_FIVE: 101,
    NUM_SIX: 102,
    NUM_SEVEN: 103,
    NUM_EIGHT: 104,
    NUM_NINE: 105,
    NUM_MULTIPLY: 106,
    NUM_PLUS: 107,
    NUM_MINUS: 109,
    NUM_PERIOD: 110,
    NUM_DIVISION: 111,
    F1: 112,
    F2: 113,
    F3: 114,
    F4: 115,
    F5: 116,
    F6: 117,
    F7: 118,
    F8: 119,
    F9: 120,
    F10: 121,
    F11: 122,
    F12: 123,
    DASH: 189,
    PERIOD: 190,
    FORWARD_SLASH: 191
};

// NG2
// APP
// Vendor
/**
 * \@name: PickerResults
 *
 * \@description This is the actual list of matches that gets injected into the DOM. It's also the piece that can be
 * overwritten if custom list options are needed.
 */
class BasePickerResults {
    /**
     * @param {?} element
     * @param {?} ref
     */
    constructor(element, ref) {
        this._term = '';
        this.selected = [];
        this.matches = [];
        this.hasError = false;
        this.isLoading = false;
        this.isStatic = true;
        this.page = 0;
        this.lastPage = false;
        this.autoSelectFirstOption = true;
        this.element = element;
        this.ref = ref;
    }
    /**
     * @param {?} target
     * @return {?}
     */
    onScrollDown(target) {
        if (target) {
            let /** @type {?} */ offset = target.offsetHeight + target.scrollTop, /** @type {?} */ bottom = target.scrollHeight;
            if (offset >= bottom) {
                event.stopPropagation();
                if (!this.lastPage && !this.config.disableInfiniteScroll) {
                    this.processSearch();
                }
            }
        }
    }
    /**
     * @return {?}
     */
    get term() {
        return this._term;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set term(value) {
        if (value !== this._term || this.page === 0) {
            this._term = value;
            this.page = 0;
            this.matches = [];
            this.processSearch();
        }
    }
    /**
     * @return {?}
     */
    processSearch() {
        this.hasError = false;
        this.isLoading = true;
        this.ref.markForCheck();
        this.search(this.term)
            .subscribe((results) => {
            if (this.isStatic) {
                this.matches = this.filterData(results);
            }
            else {
                this.matches = this.matches.concat(results);
                this.lastPage = (results && !results.length);
            }
            if (this.matches.length > 0 && this.autoSelectFirstOption) {
                this.nextActiveMatch();
            }
            this.isLoading = false;
            this.ref.markForCheck();
            setTimeout(() => this.overlay.updatePosition()); // @bkimball: This was added for Dylan Schulte, 9.18.2017 4:14PM EST, you're welcome!
        }, (err) => {
            this.hasError = this.term && this.term.length !== 0;
            this.isLoading = false;
            this.lastPage = true;
            if (this.term && this.term.length !== 0) {
                console.error(err); // tslint:disable-lineno
            }
            this.ref.markForCheck();
        });
    }
    /**
     * @param {?} term
     * @param {?=} mode
     * @return {?}
     */
    search(term, mode) {
        let /** @type {?} */ options = this.config.options;
        return Observable$1.fromPromise(new Promise((resolve, reject) => {
            // Check if there is match data
            if (options) {
                // Resolve the data
                if (Array.isArray(options)) {
                    this.isStatic = true;
                    // Arrays are returned immediately
                    resolve(this.structureArray(options));
                }
                else if (term && term.length >= (this.config.minSearchLength || 1)) {
                    if ((options.hasOwnProperty('reject') && options.hasOwnProperty('resolve')) || Object.getPrototypeOf(options).hasOwnProperty('then')) {
                        this.isStatic = false;
                        // Promises (ES6 or Deferred) are resolved whenever they resolve
                        options
                            .then(this.structureArray.bind(this))
                            .then(resolve, reject);
                    }
                    else if (typeof options === 'function') {
                        this.isStatic = false;
                        // Promises (ES6 or Deferred) are resolved whenever they resolve
                        options(term, ++this.page)
                            .then(this.structureArray.bind(this))
                            .then(resolve, reject);
                    }
                    else {
                        // All other kinds of data are rejected
                        reject('The data provided is not an array or a promise');
                        throw new Error('The data provided is not an array or a promise');
                    }
                }
                else {
                    if (this.config.defaultOptions) {
                        this.isStatic = false;
                        if (typeof this.config.defaultOptions === 'function') {
                            let /** @type {?} */ defaultOptions = this.config.defaultOptions(term, ++this.page);
                            if (Object.getPrototypeOf(defaultOptions).hasOwnProperty('then')) {
                                defaultOptions
                                    .then(this.structureArray.bind(this))
                                    .then(resolve, reject);
                            }
                            else {
                                resolve(this.structureArray(defaultOptions));
                            }
                        }
                        else {
                            resolve(this.structureArray(this.config.defaultOptions));
                        }
                    }
                    else {
                        // No search term gets rejected
                        reject('No search term');
                    }
                }
            }
            else {
                // No data gets rejected
                reject('error');
            }
        }));
    }
    /**
     * \@name structureArray
     * \@description This function structures an array of nodes into an array of objects with a
     * 'name' field by default.
     * @param {?} collection - the data once getData resolves it
     *
     * @return {?}
     */
    structureArray(collection) {
        let /** @type {?} */ dataArray = collection.data ? collection.data : collection;
        if (dataArray && (typeof dataArray[0] === 'string' || typeof dataArray[0] === 'number')) {
            return collection.map((item) => {
                return {
                    value: item,
                    label: item
                };
            });
        }
        return dataArray.map((data) => {
            let /** @type {?} */ value = this.config.field ? data[this.config.field] : (data.value || data);
            if (this.config.valueFormat) {
                value = Helpers.interpolate(this.config.valueFormat, data);
            }
            let /** @type {?} */ label = this.config.format ? Helpers.interpolate(this.config.format, data) : data.label || String(value);
            return { value, label, data };
        });
    }
    /**
     * \@name filterData=
     * \@description This function loops through the picker options and creates a filtered list of objects that contain
     * the newSearch.
     * @param {?} matches - Collection of objects=
     *
     * @return {?}
     */
    filterData(matches) {
        if (this.term && matches) {
            return matches.filter((match) => {
                return ~String(match.label).toLowerCase().indexOf(this.term.toLowerCase());
            });
        }
        // Show no recent results template
        return matches;
    }
    /**
     * \@name selectActiveMatch
     *
     * \@description This function is called when the user presses the enter key to call the selectMatch method.
     * @return {?}
     */
    selectActiveMatch() {
        this.selectMatch();
    }
    /**
     * \@name prevActiveMatch
     *
     * \@description This function sets activeMatch to the match before the current node.
     * @return {?}
     */
    prevActiveMatch() {
        let /** @type {?} */ index = this.matches.indexOf(this.activeMatch);
        this.activeMatch = this.matches[index - 1 < 0 ? this.matches.length - 1 : index - 1];
        this.scrollToActive();
        this.ref.markForCheck();
    }
    /**
     * \@name nextActiveMatch
     *
     * \@description This function sets activeMatch to the match after the current node.
     * @return {?}
     */
    nextActiveMatch() {
        let /** @type {?} */ index = this.matches.indexOf(this.activeMatch);
        this.activeMatch = this.matches[index + 1 > this.matches.length - 1 ? 0 : index + 1];
        this.scrollToActive();
        this.ref.markForCheck();
    }
    /**
     * @return {?}
     */
    getListElement() {
        return this.element.nativeElement;
    }
    /**
     * @return {?}
     */
    getChildrenOfListElement() {
        let /** @type {?} */ children = [];
        if (this.getListElement()) {
            children = this.getListElement().children;
        }
        return children;
    }
    /**
     * @return {?}
     */
    scrollToActive() {
        let /** @type {?} */ list = this.getListElement();
        let /** @type {?} */ items = this.getChildrenOfListElement();
        let /** @type {?} */ index = this.matches.indexOf(this.activeMatch);
        let /** @type {?} */ item = items[index];
        if (item) {
            list.scrollTop = item.offsetTop;
        }
    }
    /**
     * \@name selectActive
     * \@description
     * @param {?} match
     *
     * @return {?}
     */
    selectActive(match) {
        this.activeMatch = match;
    }
    /**
     * \@name isActive
     * \@description
     * @param {?} match
     *
     * @return {?}
     */
    isActive(match) {
        return this.activeMatch === match;
    }
    /**
     * \@name selectMatch
     * \@description
     * @param {?=} event
     * @param {?=} item
     *
     * @return {?}
     */
    selectMatch(event, item) {
        if (event) {
            event.stopPropagation();
            event.preventDefault();
        }
        let /** @type {?} */ selected = this.activeMatch;
        if (selected && this.parent) {
            this.parent.value = selected;
            if (this.parent.closeOnSelect) {
                this.parent.hideResults();
            }
        }
        this.ref.markForCheck();
        return false;
    }
    /**
     * \@name escapeRegexp
     * \@description This function captures the whole query string and replace it with the string that will be used to
     * match.
     * @param {?} queryToEscape
     *
     * @return {?}
     */
    escapeRegexp(queryToEscape) {
        // Ex: if the capture is "a" the result will be \a
        return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
    }
    /**
     * \@name highlight
     * \@description This function should return a <strong>-tag wrapped HTML string.
     * @param {?} match
     * @param {?} query
     *
     * @return {?}
     */
    highlight(match, query) {
        // Replaces the capture string with a the same string inside of a "strong" tag
        return query ? match.replace(new RegExp(this.escapeRegexp(query), 'gi'), '<strong>$&</strong>') : match;
    }
    /**
     * @param {?} match
     * @return {?}
     */
    preselected(match) {
        return this.selected.findIndex(item => {
            let /** @type {?} */ isPreselected = false;
            if (item && item.value && match && match.value) {
                if (item.value.id && match.value.id) {
                    isPreselected = item.value.id === match.value.id;
                }
                else {
                    isPreselected = item.value === match.value;
                }
            }
            return isPreselected;
        }) !== -1;
    }
}
BasePickerResults.propDecorators = {
    'matches': [{ type: Input },],
    'onScrollDown': [{ type: HostListener, args: ['scroll', ['$event.target'],] },],
};

// NG2
// APP
class PickerResults extends BasePickerResults {
    /**
     * @param {?} element
     * @param {?} labels
     * @param {?} ref
     */
    constructor(element, labels, ref) {
        super(element, ref);
        this.labels = labels;
    }
    /**
     * @return {?}
     */
    getListElement() {
        return this.element.nativeElement.querySelector('novo-list');
    }
}
PickerResults.decorators = [
    { type: Component, args: [{
                selector: 'picker-results',
                host: {
                    'class': 'active'
                },
                template: `
        <novo-list *ngIf="matches.length > 0" direction="vertical">
            <novo-list-item
                *ngFor="let match of matches"
                (click)="selectMatch($event)"
                [class.active]="match === activeMatch"
                (mouseenter)="selectActive(match)"
                [class.disabled]="preselected(match)">
                <item-content>
                    <span [innerHtml]="highlight(match.label, term)"></span>
                </item-content>
            </novo-list-item>
        </novo-list>
        <div class="picker-loader" *ngIf="isLoading && matches.length === 0">
            <novo-loading theme="line"></novo-loading>
        </div>
        <p class="picker-error" *ngIf="hasError">{{ labels.pickerError }}</p>
        <p class="picker-null-results" *ngIf="!isLoading && !matches.length && !hasError">{{ labels.pickerEmpty }}</p>
    `
            },] },
];
/**
 * @nocollapse
 */
PickerResults.ctorParameters = () => [
    { type: ElementRef, },
    { type: NovoLabelService, },
    { type: ChangeDetectorRef, },
];

// NG2
// Vendor
// APP
class QuickNoteResults extends PickerResults {
    /**
     * @param {?} element
     * @param {?} labels
     * @param {?} ref
     */
    constructor(element, labels, ref) {
        super(element, labels, ref);
        this.labels = labels;
        // Mode that the quick note is in for tagging
        this.taggingMode = '';
    }
    /**
     * @return {?}
     */
    get term() {
        return this._term;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set term(value) {
        this._term = value.searchTerm;
        this.taggingMode = value.taggingMode;
        this.hasError = false;
        this.isLoading = true;
        this.search(value, this.taggingMode)
            .subscribe(results => {
            this.matches = this.isStatic ? this.filterData(results) : results;
            this.isLoading = false;
        }, () => {
            this.hasError = true;
            this.isLoading = false;
        });
    }
    /**
     * @param {?} term
     * @param {?} taggingMode
     * @return {?}
     */
    search(term, taggingMode) {
        let /** @type {?} */ searchCall = this.config.options[taggingMode];
        return Observable$1.fromPromise(new Promise((resolve, reject) => {
            // Check if there is match data
            if (searchCall) {
                // Resolve the data
                if (Array.isArray(searchCall)) {
                    this.isStatic = true;
                    // Arrays are returned immediately
                    resolve(this.structureArray(searchCall));
                }
                else if ((searchCall.hasOwnProperty('reject') && searchCall.hasOwnProperty('resolve')) || Object.getPrototypeOf(searchCall).hasOwnProperty('then')) {
                    this.isStatic = false;
                    // Promises (ES6 or Deferred) are resolved whenever they resolve
                    searchCall
                        .then(this.structureArray.bind(this))
                        .then(resolve, reject);
                }
                else if (typeof searchCall === 'function') {
                    this.isStatic = false;
                    // Promises (ES6 or Deferred) are resolved whenever they resolve
                    searchCall(term)
                        .then(this.structureArray.bind(this))
                        .then(resolve, reject);
                }
                else {
                    // All other kinds of data are rejected
                    reject('The data provided is not an array or a promise');
                    throw new Error('The data provided is not an array or a promise');
                }
            }
            else {
                // No data gets rejected
                reject('error');
            }
        }));
    }
    /**
     * \@name structureArray
     * \@description This function structures an array of nodes into an array of objects with a
     * 'name' field by default.
     * @param {?} collection - the data once getData resolves it
     *
     * @return {?}
     */
    structureArray(collection) {
        if (collection && (typeof collection[0] === 'string' || typeof collection[0] === 'number')) {
            return collection.map((item) => {
                return {
                    value: item,
                    label: item
                };
            });
        }
        return collection.map((data) => {
            let /** @type {?} */ value = this.config.field ? data[this.config.field[this.taggingMode]] : (data.value || data);
            let /** @type {?} */ label = this.config.format ? Helpers.interpolate(this.config.format[this.taggingMode], data) : data.label || String(value);
            return { value, label, data };
        });
    }
    /**
     * \@name selectMatch
     * \@description
     * @param {?} event
     *
     * @return {?}
     */
    selectMatch(event) {
        if (event) {
            event.stopPropagation();
            event.preventDefault();
        }
        let /** @type {?} */ selected = this.activeMatch;
        if (selected) {
            this.parent.onSelected(this.taggingMode, selected);
            this.parent.hideResults();
        }
        return false;
    }
}
QuickNoteResults.decorators = [
    { type: Component, args: [{
                selector: 'quick-note-results',
                host: {
                    'class': 'active'
                },
                template: `
        <novo-loading theme="line" *ngIf="isLoading && !matches.length"></novo-loading>
        <novo-list *ngIf="matches.length > 0">
            <novo-list-item
                *ngFor="let match of matches"
                (click)="selectMatch($event)"
                [class.active]="match===activeMatch"
                (mouseenter)="selectActive(match)">
                <item-content>
                    <p [innerHtml]="highlight(match.label, term)"></p>
                </item-content>
            </novo-list-item>
        </novo-list>
        <p class="picker-error" *ngIf="hasError">{{ labels.quickNoteError }}</p>
        <p class="picker-null" *ngIf="!isLoading && !matches.length && !hasError">{{ labels.quickNoteEmpty }}</p>
    `
            },] },
];
/**
 * @nocollapse
 */
QuickNoteResults.ctorParameters = () => [
    { type: ElementRef, },
    { type: NovoLabelService, },
    { type: ChangeDetectorRef, },
];

// NG2
// APP
// Value accessor for the component (supports ngModel)
const QUICK_NOTE_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => QuickNoteElement),
    multi: true
};
class QuickNoteElement extends OutsideClick {
    /**
     * @param {?} zone
     * @param {?} element
     * @param {?} componentUtils
     */
    constructor(zone, element, componentUtils) {
        super(element);
        this.zone = zone;
        this.componentUtils = componentUtils;
        // Emitter for selects
        this.focus = new EventEmitter();
        this.blur = new EventEmitter();
        this.change = new EventEmitter();
        this.placeholderVisible = false;
        this._placeholderElement = null;
        this.onModelChange = () => {
        };
        this.onModelTouched = () => {
        };
        // Bind to the active change event from the OutsideClick
        this.onActiveChange.subscribe(active => {
            if (!active) {
                setTimeout(() => {
                    this.hideResults();
                });
            }
        });
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // Make sure we have a proper config
        if (!this.config) {
            throw new Error('No config set for QuickNote!');
        }
        // Make sure that we have triggers
        if (!this.config.triggers) {
            throw new Error('QuickNote config must supply triggers!');
        }
        // Make sure that we have options
        if (!this.config.options) {
            throw new Error('QuickNote config must supply options!');
        }
        // Allow for callers to use a custom results template class in the config
        this.resultsComponent = this.config.resultsTemplate || QuickNoteResults;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        // Tear down the CKEditor instance
        if (this.ckeInstance) {
            this.ckeInstance.focusManager.blur(true); // Remove focus from editor
            setTimeout(() => {
                this.ckeInstance.removeAllListeners();
                CKEDITOR.instances[this.ckeInstance.name].destroy();
                this.ckeInstance.destroy();
                this.ckeInstance = null;
            });
        }
    }
    /**
     * Connect to key/mouse events from CKEditor after the editor has been initialized
     * @return {?}
     */
    ngAfterViewInit() {
        if (!CKEDITOR) {
            console.error('Make sure to include CKEditor sources in your dependencies!');
            return;
        }
        // Replace the textarea with an instance of CKEditor
        this.ckeInstance = CKEDITOR.replace(this.host.nativeElement, this.getCKEditorConfig());
        // Set initial value of the note in the editor
        this.writeValue(this.model);
        // Connect to the key event in CKEditor for showing results dropdown
        this.ckeInstance.on('key', (event) => {
            if (!this.onKey(event.data.domEvent.$)) {
                event.cancel();
            }
        });
        // Connect to the change event in CKEditor for debouncing user modifications
        this.ckeInstance.on('change', () => {
            // Debounce update
            if (this.debounceTimeout) {
                clearTimeout(this.debounceTimeout);
            }
            this.debounceTimeout = setTimeout(() => {
                // Run within the context of this angular element since we don't need to cancel event
                this.zone.run(() => {
                    this.onValueChange();
                });
                this.debounceTimeout = null;
            }, 250);
        });
        // Propagate blur events from CKEditor to the Element's listeners
        this.ckeInstance.on('blur', (event) => {
            this.showPlaceholder();
            this.blur.emit(event);
        });
        // Propagate blur events from CKEditor to the Element's listeners
        this.ckeInstance.on('focus', (event) => {
            this.hidePlaceholder();
            this.focus.emit(event);
        });
        // Show placeholder if the note is empty, after the editor is instantiated
        this.ckeInstance.on('instanceReady', (event) => {
            this.showPlaceholder();
        });
    }
    /**
     * @param {?=} event
     * @return {?}
     */
    onTouched(event) {
        this.onModelTouched();
    }
    /**
     * Handles setting the model and the view from the outside caller or the user's typing
     *
     * @param {?} model A model that has a note (html content) and references (array of objects)
     * @return {?}
     */
    writeValue(model) {
        // Set value of the model
        if (model && (model.references || model.note)) {
            this.model = {
                note: model.note || '',
                references: model.references || {}
            };
        }
        else {
            this.model = {
                note: model,
                references: {}
            };
        }
        // Set the note html value in the editor
        if (this.ckeInstance) {
            this.ckeInstance.setData(this.model.note);
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onModelChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onModelTouched = fn;
    }
    /**
     * If a renderer is not provided, the QuickNote will default to using this one, an anchor tag with no href
     * @param {?} symbol
     * @param {?} item
     * @return {?}
     */
    static defaultRenderer(symbol, item) {
        return `<a>${symbol}${item.label}</a>`;
    }
    /**
     * Returns the renderer for a given tagging mode if it exists in the config, otherwise the default.
     * @param {?} taggingMode
     * @return {?}
     */
    getRenderer(taggingMode) {
        return this.config.renderer ? this.config.renderer[taggingMode] : QuickNoteElement.defaultRenderer;
    }
    /**
     * Called every time a keystroke is made in the editor. Listens for particular keys (e.g. UP arrow, ESC, etc.)
     * to handle certain behaviors of the picker.
     *
     * Runs within the context of the CKEditor, so actions that affect the view have to be run back inside of the
     * Angular zone of this class.
     *
     * @param {?} event The key press event
     * @return {?} true to allow the event to occur, false to cancel the event
     */
    onKey(event) {
        if (event.key) {
            if (this.quickNoteResults) {
                // Hide results on escape key
                if (event.keyCode === KeyCodes.ESC) {
                    this.zone.run(() => {
                        this.hideResults();
                    });
                    return false;
                }
                // Navigation inside the results
                if (event.keyCode === KeyCodes.UP) {
                    this.zone.run(() => {
                        this.quickNoteResults.instance.prevActiveMatch();
                    });
                    return false;
                }
                if (event.keyCode === KeyCodes.DOWN) {
                    this.zone.run(() => {
                        this.quickNoteResults.instance.nextActiveMatch();
                    });
                    return false;
                }
                if (event.keyCode === KeyCodes.ENTER) {
                    this.zone.run(() => {
                        this.quickNoteResults.instance.selectActiveMatch();
                    });
                    return false;
                }
            }
            else {
                // Loop through all triggers and turn on tagging mode if the user just pressed a trigger character
                let /** @type {?} */ triggers = this.config.triggers || {};
                Object.keys(triggers).forEach(key => {
                    let /** @type {?} */ trigger$$1 = triggers[key] || {};
                    if (event.key === trigger$$1) {
                        this.isTagging = true;
                        this.taggingMode = key;
                    }
                });
            }
        }
        return true;
    }
    /**
     * Debounced method that is run in the proper Angular context when the user has modified the CKEditor.
     * After the value has been updated in CKEditor, this will propagate that change to the model and listeners.
     * @return {?}
     */
    onValueChange() {
        // Get the html text in CKEditor
        let /** @type {?} */ value = this.ckeInstance.getData();
        // Remove empty 'ZERO WIDTH SPACE' characters that can get added erroneously by the editor
        let /** @type {?} */ regex = new RegExp(String.fromCharCode(8203), 'g');
        value = value.replace(regex, '');
        // Make sure that any references in the model are still valid
        this.validateReferences();
        // Possibly show results if the user has entered a search term
        this.showResults();
        // Propagate change to ngModel for form validation, and send null if the note is empty
        let /** @type {?} */ newModel = null;
        if (value) {
            newModel = {
                note: value,
                references: this.model.references
            };
        }
        // Inform listeners to the ngModel change event that something has changed
        this.onModelChange(newModel);
        // Inform listeners of the `@Output() change` event that the model has been updated
        this.change.emit(newModel);
        // Inform listeners to the ngModel touched event that something has changed
        this.onTouched();
    }
    /**
     * Creates an instance of the results (called popup) and adds all the bindings to that instance.
     * @return {?}
     */
    showResults() {
        if (this.isTagging) {
            let /** @type {?} */ searchTerm = this.getSearchTerm();
            if (searchTerm.length) {
                // Update Matches
                if (this.quickNoteResults) {
                    // Update existing list
                    this.quickNoteResults.instance.term = {
                        searchTerm: searchTerm,
                        taggingMode: this.taggingMode
                    };
                }
                else {
                    // Create the results DOM element
                    this.quickNoteResults = this.componentUtils.appendNextToLocation(this.resultsComponent, this.results);
                    this.quickNoteResults.instance.parent = this;
                    this.quickNoteResults.instance.config = this.config;
                    this.quickNoteResults.instance.term = {
                        searchTerm: searchTerm,
                        taggingMode: this.taggingMode
                    };
                    this.positionResultsDropdown();
                }
            }
            else if (this.quickNoteResults) {
                this.quickNoteResults.destroy();
                this.quickNoteResults = null;
            }
            // Tell the OutsideClick base class to start listening for an outside clicks
            this.toggleActive(null, true);
        }
    }
    /**
     * Deletes the picker results from the DOM.
     * @return {?}
     */
    hideResults() {
        this.isTagging = false;
        if (this.quickNoteResults) {
            this.quickNoteResults.destroy();
            this.quickNoteResults = null;
        }
    }
    /**
     * Handles the selection from the QuickNoteResults Component. Called by the QuickNoteResults component on it's
     * parent (this element).
     *
     * @param {?} taggingMode - type of tags we are looking for
     * @param {?} selected - selected object from the picker that has a label and value
     * @return {?}
     */
    onSelected(taggingMode, selected) {
        // Turn off tagging
        this.isTagging = false;
        // Replace searchTerm with link
        let /** @type {?} */ symbol = this.config.triggers[taggingMode];
        let /** @type {?} */ renderer = this.getRenderer(taggingMode);
        let /** @type {?} */ renderedText = renderer(symbol, selected);
        this.replaceWordAtCursor(renderedText);
        // Add the new reference, if it doesn't already exist
        this.model.references = this.model.references || {};
        this.model.references[taggingMode] = this.model.references[taggingMode] || [];
        let /** @type {?} */ matchingItems = this.model.references[taggingMode].filter(item => JSON.stringify(item) === JSON.stringify(selected));
        if (matchingItems.length === 0) {
            this.model.references[taggingMode].push(selected);
        }
        // Update the quick note with the changes due to the user's selection of an item in the dropdown
        this.onValueChange();
    }
    /**
     * Convenience method that gets the current word that the cursor is on, minus the tag.
     * Also, trims any whitespace before/after the term to aid in searching.
     * @return {?}
     */
    getSearchTerm() {
        let /** @type {?} */ word = this.getWordAtCursor().trim();
        if (this.isTagging) {
            let /** @type {?} */ symbol = this.config.triggers[this.taggingMode];
            if (!word.includes(symbol)) {
                this.hideResults();
                return '';
            }
            word = word.slice(word.indexOf(symbol) + symbol.length);
        }
        return word;
    }
    /**
     * Gets the current word that the cursor is on CKEditor. Current word starts at the beginning of the line or a
     * tag character if we are in tagging mode. Current word ends at the end of the line or an empty space.
     *
     * @return {?} plain text string (removes all html formatting)
     */
    getWordAtCursor() {
        let /** @type {?} */ range = this.ckeInstance.getSelection().getRanges()[0];
        let /** @type {?} */ start = range.startContainer;
        if (start.type === CKEDITOR.NODE_TEXT && range.startOffset) {
            let /** @type {?} */ text = start.getText();
            let /** @type {?} */ symbol = this.config.triggers[this.taggingMode];
            let /** @type {?} */ wordStart = text.lastIndexOf(symbol, range.startOffset - 1);
            let /** @type {?} */ wordEnd = text.indexOf(' ', range.startOffset + 1);
            if (wordStart === -1) {
                wordStart = 0;
            }
            if (wordEnd === -1) {
                wordEnd = text.length;
            }
            return text.substring(wordStart, wordEnd);
        }
        // Selection starts at the 0 index of the text node or there's no previous text node in contents
        return '';
    }
    /**
     * Replaces the word that the user is on with the given html.
     *
     * CKEditor gives us access to the current line of html in the editor, so we replace the content of
     * the line, replacing only the current word.
     * @param {?} newWord
     * @return {?}
     */
    replaceWordAtCursor(newWord) {
        let /** @type {?} */ originalWord = this.getWordAtCursor().trim();
        let /** @type {?} */ range = this.ckeInstance.getSelection().getRanges()[0];
        let /** @type {?} */ start = range.startContainer;
        let /** @type {?} */ parentNode = start.getParent();
        if (start.type === CKEDITOR.NODE_TEXT && parentNode) {
            let /** @type {?} */ line = parentNode.getHtml();
            let /** @type {?} */ index = line.lastIndexOf(originalWord);
            if (index >= 0) {
                // Add a space after the replaced word so that multiple references can be added back to back
                let /** @type {?} */ newLine = line.substring(0, index) + newWord + ' ' + line.substring(index + originalWord.length);
                parentNode.setHtml(newLine);
                // Place selection at the end of the line
                range.moveToPosition(parentNode, CKEDITOR.POSITION_BEFORE_END);
                this.ckeInstance.getSelection().selectRanges([range]);
            }
        }
    }
    /**
     * Returns current references, minus any from the model that have been removed from the editor.
     * @return {?}
     */
    validateReferences() {
        let /** @type {?} */ html = this.ckeInstance.document.getBody().getHtml();
        // CKEditor stopped supporting the config.forceSimpleAmpersand setting, so we have to convert '&amp;' to '&'
        // when we pull html from the editor - see: https://dev.ckeditor.com/ticket/13723
        let /** @type {?} */ ampRegex = new RegExp('&amp;', 'g');
        html = html.replace(ampRegex, '&');
        Object.keys(this.model.references).forEach(taggingMode => {
            let /** @type {?} */ array = this.model.references[taggingMode] || [];
            let /** @type {?} */ symbol = this.config.triggers[taggingMode];
            let /** @type {?} */ renderer = this.getRenderer(taggingMode);
            this.model.references[taggingMode] = array.filter(item => {
                let /** @type {?} */ renderedText = renderer(symbol, item);
                return html.includes(renderedText);
            });
            // If no references, then delete the key
            if (this.model.references[taggingMode].length === 0) {
                delete this.model.references[taggingMode];
            }
        });
    }
    /**
     * Configures the CKEditor for QuickNote functionality.
     *
     * Sets the height of the CKEditor dynamically to the height of the wrapper upon initialization.
     * Removes the toolbar on the bottom and configures a slimmed down version of the toolbar.
     * Removes plugins and turns off setting to allow browser based spell checking.
     * @return {?}
     */
    getCKEditorConfig() {
        let /** @type {?} */ editorHeight = this.wrapper.nativeElement.clientHeight - QuickNoteElement.TOOLBAR_HEIGHT;
        return {
            enterMode: CKEDITOR.ENTER_BR,
            shiftEnterMode: CKEDITOR.ENTER_P,
            disableNativeSpellChecker: false,
            height: editorHeight,
            removePlugins: 'elementspath,liststyle,tabletools,contextmenu',
            resize_enabled: false,
            toolbar: [{
                    name: 'basicstyles',
                    items: ['Styles', 'FontSize', 'Bold', 'Italic', 'Underline', 'TextColor', '-', 'NumberedList', 'BulletedList', 'Outdent', 'Indent', 'Link']
                }]
        };
    }
    /**
     * Returns the current screen position of the cursor in CKEditor, accounting for any scrolling in the editor.
     *
     * @return {?}
     */
    getCursorPosition() {
        let /** @type {?} */ range = this.ckeInstance.getSelection().getRanges()[0];
        let /** @type {?} */ parentElement = range.startContainer.$.parentElement;
        let /** @type {?} */ editorElement = this.ckeInstance.editable().$;
        // Since the editor is a text node in the DOM that does not know about it's position, a temporary element has to
        // be inserted in order to locate the cursor position.
        let /** @type {?} */ cursorElement = document.createElement('img');
        cursorElement.setAttribute('src', 'null');
        cursorElement.setAttribute('width', '0');
        cursorElement.setAttribute('height', '0');
        parentElement.appendChild(cursorElement);
        let /** @type {?} */ cursorPosition = {
            top: cursorElement.offsetTop - editorElement.scrollTop,
            left: cursorElement.offsetLeft - editorElement.scrollLeft
        };
        cursorElement.remove();
        return cursorPosition;
    }
    /**
     * Positions the results dropdown based on the location of the cursor in the text field
     * @return {?}
     */
    positionResultsDropdown() {
        const /** @type {?} */ DROPDOWN_OFFSET = 30; // The distance between the cursor and the dropdown
        const /** @type {?} */ MIN_MARGIN_TOP = DROPDOWN_OFFSET;
        const /** @type {?} */ MAX_MARGIN_TOP = this.ckeInstance.config.height + QuickNoteElement.TOOLBAR_HEIGHT;
        let /** @type {?} */ cursorPosition = this.getCursorPosition();
        let /** @type {?} */ marginTop = cursorPosition.top + QuickNoteElement.TOOLBAR_HEIGHT + DROPDOWN_OFFSET;
        // Check that the margin is within the visible bounds
        marginTop = Math.max(marginTop, MIN_MARGIN_TOP);
        marginTop = Math.min(marginTop, MAX_MARGIN_TOP);
        // Set the margin-top of the dropdown
        this.quickNoteResults.instance.element.nativeElement.style.setProperty('margin-top', marginTop + 'px');
    }
    /**
     * Show the placeholder text if the editor is empty
     * @return {?}
     */
    showPlaceholder() {
        if (!this.ckeInstance.getData()) {
            this.ckeInstance.editable().getParent().$.appendChild(this.placeholderElement);
            this.placeholderVisible = true;
        }
    }
    /**
     * Hide the placeholder text by removing the placeholder element from the DOM
     * @return {?}
     */
    hidePlaceholder() {
        if (this.placeholderVisible) {
            this.ckeInstance.editable().getParent().$.removeChild(this.placeholderElement);
            this.placeholderVisible = false;
        }
    }
    /**
     * Get or create the single placeholder object that is constructed only when needed.
     * @return {?}
     */
    get placeholderElement() {
        if (!this._placeholderElement) {
            this._placeholderElement = document.createElement('div');
            this._placeholderElement.className = 'placeholder';
            this._placeholderElement.style.cssText = 'margin: 20px; color: #AAAAAA; font-family: sans-serif; font-size: 13px; line-height: 20px; position: absolute; top: 0';
            this._placeholderElement.textContent = this.placeholder;
        }
        return this._placeholderElement;
    }
}
QuickNoteElement.TOOLBAR_HEIGHT = 40;
QuickNoteElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-quick-note',
                providers: [QUICK_NOTE_VALUE_ACCESSOR],
                template: `
        <div class="quick-note-wrapper" #wrapper>
            <textarea #host></textarea>
            <span #results></span>
        </div>
    `
            },] },
];
/**
 * @nocollapse
 */
QuickNoteElement.ctorParameters = () => [
    { type: NgZone, },
    { type: ElementRef, },
    { type: ComponentUtils, },
];
QuickNoteElement.propDecorators = {
    'wrapper': [{ type: ViewChild, args: ['wrapper',] },],
    'host': [{ type: ViewChild, args: ['host',] },],
    'results': [{ type: ViewChild, args: ['results', { read: ViewContainerRef },] },],
    'config': [{ type: Input },],
    'placeholder': [{ type: Input },],
    'focus': [{ type: Output },],
    'blur': [{ type: Output },],
    'change': [{ type: Output },],
};

// NG2
// APP
class NovoQuickNoteModule {
}
NovoQuickNoteModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, FormsModule, NovoLoadingModule, NovoListModule],
                declarations: [QuickNoteElement, QuickNoteResults],
                exports: [QuickNoteElement, QuickNoteResults],
                entryComponents: [QuickNoteResults]
            },] },
];
/**
 * @nocollapse
 */
NovoQuickNoteModule.ctorParameters = () => [];

// NG2
// APP
// Value accessor for the component (supports ngModel)
const RADIO_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => NovoRadioElement),
    multi: true
};
class NovoRadioGroup {
}
NovoRadioGroup.decorators = [
    { type: Component, args: [{
                selector: 'novo-radio-group',
                template: '<ng-content></ng-content>'
            },] },
];
/**
 * @nocollapse
 */
NovoRadioGroup.ctorParameters = () => [];
class NovoRadioElement {
    /**
     * @param {?} ref
     */
    constructor(ref) {
        this.ref = ref;
        this.button = false;
        this.theme = 'secondary';
        this.change = new EventEmitter();
        this.onModelChange = () => {
        };
        this.onModelTouched = () => {
        };
    }
    /**
     * Handles the select of the radio button, will only change if a new radio is selected
     * @param {?} event
     * @param {?} radio
     * @return {?}
     */
    select(event, radio) {
        Helpers.swallowEvent(event);
        // Only change the checked state if this is a new radio, they are not toggle buttons
        if (!radio.checked) {
            radio.checked = !radio.checked;
            this.change.emit(this.value);
            this.onModelChange(this.value);
            this.ref.markForCheck();
        }
    }
    /**
     * @param {?} model
     * @return {?}
     */
    writeValue(model) {
        this.model = model;
        this.ref.markForCheck();
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onModelChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onModelTouched = fn;
    }
}
NovoRadioElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-radio',
                providers: [RADIO_VALUE_ACCESSOR],
                template: `
        <input [name]="name" type="radio" [checked]="checked" [attr.id]="name" #radio (change)="select($event, radio)">
        <label [attr.for]="name" (click)="select($event, radio)">
            <button *ngIf="button" [ngClass]="{'unchecked': !radio.checked, 'checked': radio.checked, 'has-icon': !!icon}" [theme]="theme" [icon]="icon">{{ label }}</button>
            <div *ngIf="!button">
                <i [ngClass]="{'bhi-radio-empty': !radio.checked, 'bhi-radio-filled': radio.checked}"></i>
                {{ label }}
                <ng-content></ng-content>
            </div>
        </label>
    `,
                host: {
                    '[class.vertical]': 'vertical'
                }
            },] },
];
/**
 * @nocollapse
 */
NovoRadioElement.ctorParameters = () => [
    { type: ChangeDetectorRef, },
];
NovoRadioElement.propDecorators = {
    'name': [{ type: Input },],
    'value': [{ type: Input },],
    'checked': [{ type: Input },],
    'vertical': [{ type: Input },],
    'label': [{ type: Input },],
    'button': [{ type: Input },],
    'theme': [{ type: Input },],
    'icon': [{ type: Input },],
    'change': [{ type: Output },],
};

// NG2
// APP
class NovoRadioModule {
}
NovoRadioModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, NovoButtonModule],
                declarations: [NovoRadioElement, NovoRadioGroup],
                exports: [NovoRadioElement, NovoRadioGroup]
            },] },
];
/**
 * @nocollapse
 */
NovoRadioModule.ctorParameters = () => [];

// NG2
// APP
class NovoDropdownContainer {
    /**
     * @param {?} element
     * @param {?} renderer
     * @param {?} ref
     */
    constructor(element, renderer, ref) {
        this.element = element;
        this.renderer = renderer;
        this.ref = ref;
        this.scrollHandler = this.handleScroll.bind(this);
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        if (this.isVisible && this.position) {
            const /** @type {?} */ element = this.element.nativeElement;
            const /** @type {?} */ position = Helpers.calcPositionOffset(this.position, element, this.side);
            if (position) {
                this.renderer.setStyle(element, 'top', position.top);
                this.renderer.setStyle(element, 'left', position.left);
            }
        }
    }
    /**
     * @return {?}
     */
    handleScroll() {
        // On scroll, don't force the position to update (jump from top/middle/bottom/right)
        this.updatePosition(this.relativeElement, this.side);
    }
    /**
     * @param {?} appendToBody
     * @return {?}
     */
    show(appendToBody) {
        this.appendToBody = appendToBody;
        this.renderer.setStyle(this.element.nativeElement, 'display', 'block');
        this.renderer.setStyle(this.element.nativeElement, 'visibility', 'visible');
        this.isVisible = true;
        if (appendToBody) {
            window.addEventListener('scroll', this.scrollHandler);
        }
        this.ref.markForCheck();
    }
    /**
     * @return {?}
     */
    hide() {
        this.isVisible = false;
        this.renderer.setStyle(this.element.nativeElement, 'visibility', 'hidden');
        if (this.appendToBody) {
            window.removeEventListener('scroll', this.scrollHandler);
        }
        this.ref.markForCheck();
    }
    /**
     * @param {?} element
     * @param {?} side
     * @return {?}
     */
    updatePosition(element, side) {
        this.relativeElement = element;
        this.side = side;
        this.position = element.getBoundingClientRect();
        this.ngDoCheck();
        this.ref.markForCheck();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onKeyDown(event) {
        // Close with ESC/Enter
        if (this.isVisible && (event.keyCode === KeyCodes.ESC || event.keyCode === KeyCodes.ENTER)) {
            this.parent.toggleActive(null, false);
        }
    }
}
NovoDropdownContainer.decorators = [
    { type: Component, args: [{
                selector: 'novo-dropdown-container',
                template: '<ng-content></ng-content>'
            },] },
];
/**
 * @nocollapse
 */
NovoDropdownContainer.ctorParameters = () => [
    { type: ElementRef, },
    { type: Renderer2, },
    { type: ChangeDetectorRef, },
];
NovoDropdownContainer.propDecorators = {
    'onKeyDown': [{ type: HostListener, args: ['keydown', ['$event'],] },],
};
class NovoDropdownElement extends OutsideClick {
    /**
     * @param {?} element
     * @param {?} ref
     */
    constructor(element, ref) {
        super(element);
        this.ref = ref;
        // Append the dropdown container to the body
        this.appendToBody = false;
        // What action to perform when we recieve scroll from parent selector
        // TODO - handle "move"
        this.parentScrollAction = 'close';
        // Side the dropdown will open
        this.side = 'left';
        this.activeIndex = -1;
        this.filterTerm = '';
        // Click handler
        this.clickHandler = this.toggleActive.bind(this);
        this.closeHandler = this.toggleActive.bind(this);
        this.toggled = this.onActiveChange;
        // Listen for active change to hide/show menu
        this.onActiveChange.subscribe((active) => {
            if (active) {
                this.show();
            }
            else {
                this.hide();
            }
        });
    }
    /**
     * @param {?} items
     * @return {?}
     */
    set items(items) {
        this._items = items;
        // Get the innertext of all the items to allow for searching
        this._textItems = items.map((item) => {
            return item.element.nativeElement.innerText;
        });
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // Add a click handler to the button to toggle the menu
        let /** @type {?} */ button = this.element.nativeElement.querySelector('button');
        button.addEventListener('click', this.clickHandler);
        if (this.parentScrollSelector) {
            this.parentScrollElement = Helpers.findAncestor(this.element.nativeElement, this.parentScrollSelector);
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        // Remove listener
        let /** @type {?} */ button = this.element.nativeElement.querySelector('button');
        if (button) {
            button.removeEventListener('click', this.clickHandler);
        }
    }
    /**
     * @return {?}
     */
    show() {
        this.container.parent = this;
        this.container.show(this.appendToBody);
        this.otherElement = this.container.element;
        if (this.appendToBody) {
            this.container.updatePosition(this.element.nativeElement.children[0], this.side);
            // If append to body then rip it out of here and put on body
            window.document.body.appendChild(this.container.element.nativeElement);
            window.addEventListener('resize', this.closeHandler);
        }
        // Listen for scroll on a parent to force close
        if (this.parentScrollElement) {
            if (this.parentScrollAction === 'close') {
                this.parentScrollElement.addEventListener('scroll', this.closeHandler);
            }
        }
        this.ref.markForCheck();
    }
    /**
     * @return {?}
     */
    hide() {
        this.container.hide();
        // If append to body then rip it out of here and put on body
        if (this.appendToBody) {
            let /** @type {?} */ elm = this.container.element.nativeElement;
            elm.parentNode.removeChild(elm);
            window.removeEventListener('resize', this.closeHandler);
        }
        if (this.parentScrollElement) {
            if (this.parentScrollAction === 'close') {
                this.parentScrollElement.removeEventListener('scroll', this.closeHandler);
            }
        }
        // Clear active index
        if (this.activeIndex !== -1) {
            this._items.toArray()[this.activeIndex].active = false;
        }
        this.activeIndex = -1;
        this.ref.markForCheck();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onKeyDown(event) {
        Helpers.swallowEvent(event);
        if (this.active && event.keyCode === KeyCodes.ESC) {
            // active & esc hit -- close
            this.toggleActive();
        }
        else if (event.keyCode === KeyCodes.ENTER) {
            // enter -- perform the "click"
            this._items.toArray()[this.activeIndex].onClick();
        }
        else if (event.keyCode === KeyCodes.DOWN) {
            // down - navigate through the list ignoring disabled ones
            if (this.activeIndex !== -1) {
                this._items.toArray()[this.activeIndex].active = false;
            }
            this.activeIndex++;
            if (this.activeIndex === this._items.length) {
                this.activeIndex = 0;
            }
            while (this._items.toArray()[this.activeIndex].disabled) {
                this.activeIndex++;
                if (this.activeIndex === this._items.length) {
                    this.activeIndex = 0;
                }
            }
            this._items.toArray()[this.activeIndex].active = true;
            this.scrollToActive();
        }
        else if (event.keyCode === KeyCodes.UP) {
            // up -- navigate through the list ignoring disabled ones
            if (this.activeIndex !== -1) {
                this._items.toArray()[this.activeIndex].active = false;
            }
            this.activeIndex--;
            if (this.activeIndex < 0) {
                this.activeIndex = this._items.length - 1;
            }
            while (this._items.toArray()[this.activeIndex].disabled) {
                this.activeIndex--;
                if (this.activeIndex < 0) {
                    this.activeIndex = this._items.length - 1;
                }
            }
            this._items.toArray()[this.activeIndex].active = true;
            this.scrollToActive();
        }
        else if ((event.keyCode >= 65 && event.keyCode <= 90) || (event.keyCode >= 96 && event.keyCode <= 105) || (event.keyCode >= 48 && event.keyCode <= 57) || event.keyCode === KeyCodes.SPACE) {
            // A-Z, 0-9, space -- filter the list and scroll to active filter
            // filter has hard reset after 2s
            clearTimeout(this.filterTermTimeout);
            this.filterTermTimeout = setTimeout(() => { this.filterTerm = ''; }, 2000);
            let /** @type {?} */ char = String.fromCharCode(event.keyCode);
            this.filterTerm = this.filterTerm.concat(char);
            let /** @type {?} */ index = this._textItems.findIndex((value) => {
                return new RegExp(`^${this.filterTerm.toLowerCase()}`).test(value.trim().toLowerCase());
            });
            if (index !== -1) {
                if (this.activeIndex !== -1) {
                    this._items.toArray()[this.activeIndex].active = false;
                }
                this.activeIndex = index;
                this._items.toArray()[this.activeIndex].active = true;
                this.scrollToActive();
            }
        }
        else if ([KeyCodes.BACKSPACE, KeyCodes.DELETE].includes(event.keyCode)) {
            // backspace, delete -- remove partial filters
            clearTimeout(this.filterTermTimeout);
            this.filterTermTimeout = setTimeout(() => { this.filterTerm = ''; }, 2000);
            this.filterTerm = this.filterTerm.slice(0, -1);
        }
    }
    /**
     * @return {?}
     */
    scrollToActive() {
        let /** @type {?} */ container = this.element.nativeElement.querySelector('novo-dropdown-container');
        let /** @type {?} */ item = this._items.toArray()[this.activeIndex];
        if (container && item) {
            container.scrollTop = item.element.nativeElement.offsetTop;
        }
        else {
            // Append to body
            container = document.querySelector('body > novo-dropdown-container');
            if (container && item) {
                container.scrollTop = item.element.nativeElement.offsetTop;
            }
        }
    }
}
NovoDropdownElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-dropdown',
                template: `
        <ng-content select="button" #trigger></ng-content>
        <novo-dropdown-container class="dropdown-container {{ containerClass }}">
            <ng-content></ng-content>
        </novo-dropdown-container>
    `
            },] },
];
/**
 * @nocollapse
 */
NovoDropdownElement.ctorParameters = () => [
    { type: ElementRef, },
    { type: ChangeDetectorRef, },
];
NovoDropdownElement.propDecorators = {
    'appendToBody': [{ type: Input },],
    'parentScrollSelector': [{ type: Input },],
    'parentScrollAction': [{ type: Input },],
    'containerClass': [{ type: Input },],
    'side': [{ type: Input },],
    'toggled': [{ type: Output },],
    'container': [{ type: ViewChild, args: [NovoDropdownContainer,] },],
    'button': [{ type: ViewChild, args: ['trigger',] },],
    'onKeyDown': [{ type: HostListener, args: ['keydown', ['$event'],] },],
};
class NovoItemElement {
    /**
     * @param {?} dropdown
     * @param {?} element
     */
    constructor(dropdown, element) {
        this.dropdown = dropdown;
        this.element = element;
        this.keepOpen = false;
        this.action = new EventEmitter();
        this.active = false;
    }
    /**
     * @return {?}
     */
    onClick() {
        // Poor man's disable
        if (!this.disabled) {
            // Close if keepOpen is false
            if (!this.keepOpen) {
                this.dropdown.toggleActive();
            }
            // Emit the action
            this.action.emit();
        }
    }
}
NovoItemElement.decorators = [
    { type: Component, args: [{
                selector: 'item',
                template: '<ng-content></ng-content>',
                host: {
                    '[class.disabled]': 'disabled',
                    '[class.active]': 'active'
                }
            },] },
];
/**
 * @nocollapse
 */
NovoItemElement.ctorParameters = () => [
    { type: NovoDropdownElement, },
    { type: ElementRef, },
];
NovoItemElement.propDecorators = {
    'disabled': [{ type: Input },],
    'keepOpen': [{ type: Input },],
    'action': [{ type: Output },],
    'onClick': [{ type: HostListener, args: ['click', [],] },],
};
class NovoListElement$1 {
    /**
     * @param {?} dropdown
     */
    constructor(dropdown) {
        this.dropdown = dropdown;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.dropdown.items = this.items;
    }
}
NovoListElement$1.decorators = [
    { type: Component, args: [{
                selector: 'list',
                template: '<ng-content></ng-content>'
            },] },
];
/**
 * @nocollapse
 */
NovoListElement$1.ctorParameters = () => [
    { type: NovoDropdownElement, },
];
NovoListElement$1.propDecorators = {
    'items': [{ type: ContentChildren, args: [NovoItemElement,] },],
};
class NovoItemHeaderElement$1 {
}
NovoItemHeaderElement$1.decorators = [
    { type: Component, args: [{
                selector: 'dropdown-item-header',
                template: '<ng-content></ng-content>',
            },] },
];
/**
 * @nocollapse
 */
NovoItemHeaderElement$1.ctorParameters = () => [];

// NG2
// APP
class NovoDropdownModule {
}
NovoDropdownModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NovoDropdownElement, NovoItemElement, NovoListElement$1, NovoDropdownContainer, NovoItemHeaderElement$1],
                exports: [NovoDropdownElement, NovoItemElement, NovoListElement$1, NovoDropdownContainer, NovoItemHeaderElement$1]
            },] },
];
/**
 * @nocollapse
 */
NovoDropdownModule.ctorParameters = () => [];

var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};





function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

function isFunction(x) {
    return typeof x === 'function';
}
var isFunction_2 = isFunction;


var isFunction_1 = {
	isFunction: isFunction_2
};

var isArray_1 = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });


var isArray = {
	isArray: isArray_1
};

function isObject(x) {
    return x != null && typeof x === 'object';
}
var isObject_2 = isObject;


var isObject_1 = {
	isObject: isObject_2
};

// typeof any so that it we don't have to cast when comparing a result to the error object
var errorObject_1 = { e: {} };


var errorObject = {
	errorObject: errorObject_1
};

var tryCatchTarget;
function tryCatcher() {
    try {
        return tryCatchTarget.apply(this, arguments);
    }
    catch (e) {
        errorObject.errorObject.e = e;
        return errorObject.errorObject;
    }
}
function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
}
var tryCatch_2 = tryCatch;



var tryCatch_1 = {
	tryCatch: tryCatch_2
};

var __extends$2 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when one or more errors have occurred during the
 * `unsubscribe` of a {@link Subscription}.
 */
var UnsubscriptionError = (function (_super) {
    __extends$2(UnsubscriptionError, _super);
    function UnsubscriptionError(errors) {
        _super.call(this);
        this.errors = errors;
        var err = Error.call(this, errors ?
            errors.length + " errors occurred during unsubscription:\n  " + errors.map(function (err, i) { return ((i + 1) + ") " + err.toString()); }).join('\n  ') : '');
        this.name = err.name = 'UnsubscriptionError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return UnsubscriptionError;
}(Error));
var UnsubscriptionError_2 = UnsubscriptionError;


var UnsubscriptionError_1 = {
	UnsubscriptionError: UnsubscriptionError_2
};

/**
 * Represents a disposable resource, such as the execution of an Observable. A
 * Subscription has one important method, `unsubscribe`, that takes no argument
 * and just disposes the resource held by the subscription.
 *
 * Additionally, subscriptions may be grouped together through the `add()`
 * method, which will attach a child Subscription to the current Subscription.
 * When a Subscription is unsubscribed, all its children (and its grandchildren)
 * will be unsubscribed as well.
 *
 * @class Subscription
 */
var Subscription = (function () {
    /**
     * @param {function(): void} [unsubscribe] A function describing how to
     * perform the disposal of resources when the `unsubscribe` method is called.
     */
    function Subscription(unsubscribe) {
        /**
         * A flag to indicate whether this Subscription has already been unsubscribed.
         * @type {boolean}
         */
        this.closed = false;
        this._parent = null;
        this._parents = null;
        this._subscriptions = null;
        if (unsubscribe) {
            this._unsubscribe = unsubscribe;
        }
    }
    /**
     * Disposes the resources held by the subscription. May, for instance, cancel
     * an ongoing Observable execution or cancel any other type of work that
     * started when the Subscription was created.
     * @return {void}
     */
    Subscription.prototype.unsubscribe = function () {
        var hasErrors = false;
        var errors;
        if (this.closed) {
            return;
        }
        var _a = this, _parent = _a._parent, _parents = _a._parents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
        this.closed = true;
        this._parent = null;
        this._parents = null;
        // null out _subscriptions first so any child subscriptions that attempt
        // to remove themselves from this subscription will noop
        this._subscriptions = null;
        var index = -1;
        var len = _parents ? _parents.length : 0;
        // if this._parent is null, then so is this._parents, and we
        // don't have to remove ourselves from any parent subscriptions.
        while (_parent) {
            _parent.remove(this);
            // if this._parents is null or index >= len,
            // then _parent is set to null, and the loop exits
            _parent = ++index < len && _parents[index] || null;
        }
        if (isFunction_1.isFunction(_unsubscribe)) {
            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
            if (trial === errorObject.errorObject) {
                hasErrors = true;
                errors = errors || (errorObject.errorObject.e instanceof UnsubscriptionError_1.UnsubscriptionError ?
                    flattenUnsubscriptionErrors(errorObject.errorObject.e.errors) : [errorObject.errorObject.e]);
            }
        }
        if (isArray.isArray(_subscriptions)) {
            index = -1;
            len = _subscriptions.length;
            while (++index < len) {
                var sub = _subscriptions[index];
                if (isObject_1.isObject(sub)) {
                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
                    if (trial === errorObject.errorObject) {
                        hasErrors = true;
                        errors = errors || [];
                        var err = errorObject.errorObject.e;
                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                            errors = errors.concat(flattenUnsubscriptionErrors(err.errors));
                        }
                        else {
                            errors.push(err);
                        }
                    }
                }
            }
        }
        if (hasErrors) {
            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
        }
    };
    /**
     * Adds a tear down to be called during the unsubscribe() of this
     * Subscription.
     *
     * If the tear down being added is a subscription that is already
     * unsubscribed, is the same reference `add` is being called on, or is
     * `Subscription.EMPTY`, it will not be added.
     *
     * If this subscription is already in an `closed` state, the passed
     * tear down logic will be executed immediately.
     *
     * @param {TeardownLogic} teardown The additional logic to execute on
     * teardown.
     * @return {Subscription} Returns the Subscription used or created to be
     * added to the inner subscriptions list. This Subscription can be used with
     * `remove()` to remove the passed teardown logic from the inner subscriptions
     * list.
     */
    Subscription.prototype.add = function (teardown) {
        if (!teardown || (teardown === Subscription.EMPTY)) {
            return Subscription.EMPTY;
        }
        if (teardown === this) {
            return this;
        }
        var subscription = teardown;
        switch (typeof teardown) {
            case 'function':
                subscription = new Subscription(teardown);
            case 'object':
                if (subscription.closed || typeof subscription.unsubscribe !== 'function') {
                    return subscription;
                }
                else if (this.closed) {
                    subscription.unsubscribe();
                    return subscription;
                }
                else if (typeof subscription._addParent !== 'function' /* quack quack */) {
                    var tmp = subscription;
                    subscription = new Subscription();
                    subscription._subscriptions = [tmp];
                }
                break;
            default:
                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
        }
        var subscriptions = this._subscriptions || (this._subscriptions = []);
        subscriptions.push(subscription);
        subscription._addParent(this);
        return subscription;
    };
    /**
     * Removes a Subscription from the internal list of subscriptions that will
     * unsubscribe during the unsubscribe process of this Subscription.
     * @param {Subscription} subscription The subscription to remove.
     * @return {void}
     */
    Subscription.prototype.remove = function (subscription) {
        var subscriptions = this._subscriptions;
        if (subscriptions) {
            var subscriptionIndex = subscriptions.indexOf(subscription);
            if (subscriptionIndex !== -1) {
                subscriptions.splice(subscriptionIndex, 1);
            }
        }
    };
    Subscription.prototype._addParent = function (parent) {
        var _a = this, _parent = _a._parent, _parents = _a._parents;
        if (!_parent || _parent === parent) {
            // If we don't have a parent, or the new parent is the same as the
            // current parent, then set this._parent to the new parent.
            this._parent = parent;
        }
        else if (!_parents) {
            // If there's already one parent, but not multiple, allocate an Array to
            // store the rest of the parent Subscriptions.
            this._parents = [parent];
        }
        else if (_parents.indexOf(parent) === -1) {
            // Only add the new parent to the _parents list if it's not already there.
            _parents.push(parent);
        }
    };
    Subscription.EMPTY = (function (empty) {
        empty.closed = true;
        return empty;
    }(new Subscription()));
    return Subscription;
}());
var Subscription_2 = Subscription;
function flattenUnsubscriptionErrors(errors) {
    return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError_1.UnsubscriptionError) ? err.errors : err); }, []);
}


var Subscription_1 = {
	Subscription: Subscription_2
};

var empty = {
    closed: true,
    next: function (value) { },
    error: function (err) { throw err; },
    complete: function () { }
};


var Observer = {
	empty: empty
};

// CommonJS / Node have global context exposed as "global" variable.
// We don't want to include the whole node.d.ts this this compilation unit so we'll just fake
// the global "global" var for now.
var __window = typeof window !== 'undefined' && window;
var __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&
    self instanceof WorkerGlobalScope && self;
var __global = typeof commonjsGlobal !== 'undefined' && commonjsGlobal;
var _root = __window || __global || __self;
var root_1 = _root;
// Workaround Closure Compiler restriction: The body of a goog.module cannot use throw.
// This is needed when used with angular/tsickle which inserts a goog.module statement.
// Wrap in IIFE
(function () {
    if (!_root) {
        throw new Error('RxJS could not find any global context (window, self, global)');
    }
})();


var root = {
	root: root_1
};

var rxSubscriber = createCommonjsModule(function (module, exports) {
var Symbol = root.root.Symbol;
exports.rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?
    Symbol.for('rxSubscriber') : '@@rxSubscriber';
/**
 * @deprecated use rxSubscriber instead
 */
exports.$$rxSubscriber = exports.rxSubscriber;

});

var rxSubscriber_1 = rxSubscriber.rxSubscriber;
var rxSubscriber_2 = rxSubscriber.$$rxSubscriber;

var __extends$1 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};




/**
 * Implements the {@link Observer} interface and extends the
 * {@link Subscription} class. While the {@link Observer} is the public API for
 * consuming the values of an {@link Observable}, all Observers get converted to
 * a Subscriber, in order to provide Subscription-like capabilities such as
 * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
 * implementing operators, but it is rarely used as a public API.
 *
 * @class Subscriber<T>
 */
var Subscriber = (function (_super) {
    __extends$1(Subscriber, _super);
    /**
     * @param {Observer|function(value: T): void} [destinationOrNext] A partially
     * defined Observer or a `next` callback function.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     */
    function Subscriber(destinationOrNext, error, complete) {
        _super.call(this);
        this.syncErrorValue = null;
        this.syncErrorThrown = false;
        this.syncErrorThrowable = false;
        this.isStopped = false;
        switch (arguments.length) {
            case 0:
                this.destination = Observer.empty;
                break;
            case 1:
                if (!destinationOrNext) {
                    this.destination = Observer.empty;
                    break;
                }
                if (typeof destinationOrNext === 'object') {
                    if (destinationOrNext instanceof Subscriber) {
                        this.destination = destinationOrNext;
                        this.destination.add(this);
                    }
                    else {
                        this.syncErrorThrowable = true;
                        this.destination = new SafeSubscriber(this, destinationOrNext);
                    }
                    break;
                }
            default:
                this.syncErrorThrowable = true;
                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
                break;
        }
    }
    Subscriber.prototype[rxSubscriber.rxSubscriber] = function () { return this; };
    /**
     * A static factory for a Subscriber, given a (potentially partial) definition
     * of an Observer.
     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
     * Observer represented by the given arguments.
     */
    Subscriber.create = function (next, error, complete) {
        var subscriber = new Subscriber(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
    };
    /**
     * The {@link Observer} callback to receive notifications of type `next` from
     * the Observable, with a value. The Observable may call this method 0 or more
     * times.
     * @param {T} [value] The `next` value.
     * @return {void}
     */
    Subscriber.prototype.next = function (value) {
        if (!this.isStopped) {
            this._next(value);
        }
    };
    /**
     * The {@link Observer} callback to receive notifications of type `error` from
     * the Observable, with an attached {@link Error}. Notifies the Observer that
     * the Observable has experienced an error condition.
     * @param {any} [err] The `error` exception.
     * @return {void}
     */
    Subscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            this.isStopped = true;
            this._error(err);
        }
    };
    /**
     * The {@link Observer} callback to receive a valueless notification of type
     * `complete` from the Observable. Notifies the Observer that the Observable
     * has finished sending push-based notifications.
     * @return {void}
     */
    Subscriber.prototype.complete = function () {
        if (!this.isStopped) {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
    };
    Subscriber.prototype._next = function (value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function (err) {
        this.destination.error(err);
        this.unsubscribe();
    };
    Subscriber.prototype._complete = function () {
        this.destination.complete();
        this.unsubscribe();
    };
    Subscriber.prototype._unsubscribeAndRecycle = function () {
        var _a = this, _parent = _a._parent, _parents = _a._parents;
        this._parent = null;
        this._parents = null;
        this.unsubscribe();
        this.closed = false;
        this.isStopped = false;
        this._parent = _parent;
        this._parents = _parents;
        return this;
    };
    return Subscriber;
}(Subscription_1.Subscription));
var Subscriber_2 = Subscriber;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SafeSubscriber = (function (_super) {
    __extends$1(SafeSubscriber, _super);
    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
        _super.call(this);
        this._parentSubscriber = _parentSubscriber;
        var next;
        var context = this;
        if (isFunction_1.isFunction(observerOrNext)) {
            next = observerOrNext;
        }
        else if (observerOrNext) {
            next = observerOrNext.next;
            error = observerOrNext.error;
            complete = observerOrNext.complete;
            if (observerOrNext !== Observer.empty) {
                context = Object.create(observerOrNext);
                if (isFunction_1.isFunction(context.unsubscribe)) {
                    this.add(context.unsubscribe.bind(context));
                }
                context.unsubscribe = this.unsubscribe.bind(this);
            }
        }
        this._context = context;
        this._next = next;
        this._error = error;
        this._complete = complete;
    }
    SafeSubscriber.prototype.next = function (value) {
        if (!this.isStopped && this._next) {
            var _parentSubscriber = this._parentSubscriber;
            if (!_parentSubscriber.syncErrorThrowable) {
                this.__tryOrUnsub(this._next, value);
            }
            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._error) {
                if (!_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._error, err);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, this._error, err);
                    this.unsubscribe();
                }
            }
            else if (!_parentSubscriber.syncErrorThrowable) {
                this.unsubscribe();
                throw err;
            }
            else {
                _parentSubscriber.syncErrorValue = err;
                _parentSubscriber.syncErrorThrown = true;
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.complete = function () {
        var _this = this;
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._complete) {
                var wrappedComplete = function () { return _this._complete.call(_this._context); };
                if (!_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(wrappedComplete);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, wrappedComplete);
                    this.unsubscribe();
                }
            }
            else {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            this.unsubscribe();
            throw err;
        }
    };
    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            parent.syncErrorValue = err;
            parent.syncErrorThrown = true;
            return true;
        }
        return false;
    };
    SafeSubscriber.prototype._unsubscribe = function () {
        var _parentSubscriber = this._parentSubscriber;
        this._context = null;
        this._parentSubscriber = null;
        _parentSubscriber.unsubscribe();
    };
    return SafeSubscriber;
}(Subscriber));


var Subscriber_1 = {
	Subscriber: Subscriber_2
};

var __extends$3 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when an Observable or a sequence was queried but has no
 * elements.
 *
 * @see {@link first}
 * @see {@link last}
 * @see {@link single}
 *
 * @class EmptyError
 */
var EmptyError = (function (_super) {
    __extends$3(EmptyError, _super);
    function EmptyError() {
        var err = _super.call(this, 'no elements in sequence');
        this.name = err.name = 'EmptyError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return EmptyError;
}(Error));
var EmptyError_2 = EmptyError;


var EmptyError_1 = {
	EmptyError: EmptyError_2
};

var __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * Emits only the first value (or the first value that meets some condition)
 * emitted by the source Observable.
 *
 * <span class="informal">Emits only the first value. Or emits only the first
 * value that passes some test.</span>
 *
 * <img src="./img/first.png" width="100%">
 *
 * If called with no arguments, `first` emits the first value of the source
 * Observable, then completes. If called with a `predicate` function, `first`
 * emits the first value of the source that matches the specified condition. It
 * may also take a `resultSelector` function to produce the output value from
 * the input value, and a `defaultValue` to emit in case the source completes
 * before it is able to emit a valid value. Throws an error if `defaultValue`
 * was not provided and a matching element is not found.
 *
 * @example <caption>Emit only the first click that happens on the DOM</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.first();
 * result.subscribe(x => console.log(x));
 *
 * @example <caption>Emits the first click that happens on a DIV</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.first(ev => ev.target.tagName === 'DIV');
 * result.subscribe(x => console.log(x));
 *
 * @see {@link filter}
 * @see {@link find}
 * @see {@link take}
 *
 * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`
 * callback if the Observable completes before any `next` notification was sent.
 *
 * @param {function(value: T, index: number, source: Observable<T>): boolean} [predicate]
 * An optional function called with each item to test for condition matching.
 * @param {function(value: T, index: number): R} [resultSelector] A function to
 * produce the value on the output Observable based on the values
 * and the indices of the source Observable. The arguments passed to this
 * function are:
 * - `value`: the value that was emitted on the source.
 * - `index`: the "index" of the value from the source.
 * @param {R} [defaultValue] The default value emitted in case no valid value
 * was found on the source.
 * @return {Observable<T|R>} An Observable of the first item that matches the
 * condition.
 * @method first
 * @owner Observable
 */
function first(predicate, resultSelector, defaultValue) {
    return function (source) { return source.lift(new FirstOperator(predicate, resultSelector, defaultValue, source)); };
}
var first_2 = first;
var FirstOperator = (function () {
    function FirstOperator(predicate, resultSelector, defaultValue, source) {
        this.predicate = predicate;
        this.resultSelector = resultSelector;
        this.defaultValue = defaultValue;
        this.source = source;
    }
    FirstOperator.prototype.call = function (observer, source) {
        return source.subscribe(new FirstSubscriber(observer, this.predicate, this.resultSelector, this.defaultValue, this.source));
    };
    return FirstOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var FirstSubscriber = (function (_super) {
    __extends(FirstSubscriber, _super);
    function FirstSubscriber(destination, predicate, resultSelector, defaultValue, source) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.resultSelector = resultSelector;
        this.defaultValue = defaultValue;
        this.source = source;
        this.index = 0;
        this.hasCompleted = false;
        this._emitted = false;
    }
    FirstSubscriber.prototype._next = function (value) {
        var index = this.index++;
        if (this.predicate) {
            this._tryPredicate(value, index);
        }
        else {
            this._emit(value, index);
        }
    };
    FirstSubscriber.prototype._tryPredicate = function (value, index) {
        var result;
        try {
            result = this.predicate(value, index, this.source);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this._emit(value, index);
        }
    };
    FirstSubscriber.prototype._emit = function (value, index) {
        if (this.resultSelector) {
            this._tryResultSelector(value, index);
            return;
        }
        this._emitFinal(value);
    };
    FirstSubscriber.prototype._tryResultSelector = function (value, index) {
        var result;
        try {
            result = this.resultSelector(value, index);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this._emitFinal(result);
    };
    FirstSubscriber.prototype._emitFinal = function (value) {
        var destination = this.destination;
        if (!this._emitted) {
            this._emitted = true;
            destination.next(value);
            destination.complete();
            this.hasCompleted = true;
        }
    };
    FirstSubscriber.prototype._complete = function () {
        var destination = this.destination;
        if (!this.hasCompleted && typeof this.defaultValue !== 'undefined') {
            destination.next(this.defaultValue);
            destination.complete();
        }
        else if (!this.hasCompleted) {
            destination.error(new EmptyError_1.EmptyError);
        }
    };
    return FirstSubscriber;
}(Subscriber_1.Subscriber));

var __extends$5 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var OuterSubscriber = (function (_super) {
    __extends$5(OuterSubscriber, _super);
    function OuterSubscriber() {
        _super.apply(this, arguments);
    }
    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    OuterSubscriber.prototype.notifyError = function (error, innerSub) {
        this.destination.error(error);
    };
    OuterSubscriber.prototype.notifyComplete = function (innerSub) {
        this.destination.complete();
    };
    return OuterSubscriber;
}(Subscriber_1.Subscriber));
var OuterSubscriber_2 = OuterSubscriber;


var OuterSubscriber_1 = {
	OuterSubscriber: OuterSubscriber_2
};

var isArrayLike_1 = (function (x) { return x && typeof x.length === 'number'; });


var isArrayLike = {
	isArrayLike: isArrayLike_1
};

function isPromise(value) {
    return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
}
var isPromise_2 = isPromise;


var isPromise_1 = {
	isPromise: isPromise_2
};

function toSubscriber(nextOrObserver, error, complete) {
    if (nextOrObserver) {
        if (nextOrObserver instanceof Subscriber_1.Subscriber) {
            return nextOrObserver;
        }
        if (nextOrObserver[rxSubscriber.rxSubscriber]) {
            return nextOrObserver[rxSubscriber.rxSubscriber]();
        }
    }
    if (!nextOrObserver && !error && !complete) {
        return new Subscriber_1.Subscriber(Observer.empty);
    }
    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
}
var toSubscriber_2 = toSubscriber;


var toSubscriber_1 = {
	toSubscriber: toSubscriber_2
};

var observable = createCommonjsModule(function (module, exports) {
function getSymbolObservable(context) {
    var $$observable;
    var Symbol = context.Symbol;
    if (typeof Symbol === 'function') {
        if (Symbol.observable) {
            $$observable = Symbol.observable;
        }
        else {
            $$observable = Symbol('observable');
            Symbol.observable = $$observable;
        }
    }
    else {
        $$observable = '@@observable';
    }
    return $$observable;
}
exports.getSymbolObservable = getSymbolObservable;
exports.observable = getSymbolObservable(root.root);
/**
 * @deprecated use observable instead
 */
exports.$$observable = exports.observable;

});

var observable_1 = observable.getSymbolObservable;
var observable_2 = observable.observable;
var observable_3 = observable.$$observable;

/* tslint:disable:no-empty */
function noop() { }
var noop_2 = noop;


var noop_1 = {
	noop: noop_2
};

/* tslint:enable:max-line-length */
function pipe() {
    var fns = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        fns[_i - 0] = arguments[_i];
    }
    return pipeFromArray(fns);
}
var pipe_2 = pipe;
/* @internal */
function pipeFromArray(fns) {
    if (!fns) {
        return noop_1.noop;
    }
    if (fns.length === 1) {
        return fns[0];
    }
    return function piped(input) {
        return fns.reduce(function (prev, fn) { return fn(prev); }, input);
    };
}
var pipeFromArray_1 = pipeFromArray;


var pipe_1 = {
	pipe: pipe_2,
	pipeFromArray: pipeFromArray_1
};

/**
 * A representation of any set of values over any amount of time. This is the most basic building block
 * of RxJS.
 *
 * @class Observable<T>
 */
var Observable$2 = (function () {
    /**
     * @constructor
     * @param {Function} subscribe the function that is called when the Observable is
     * initially subscribed to. This function is given a Subscriber, to which new values
     * can be `next`ed, or an `error` method can be called to raise an error, or
     * `complete` can be called to notify of a successful completion.
     */
    function Observable$$1(subscribe) {
        this._isScalar = false;
        if (subscribe) {
            this._subscribe = subscribe;
        }
    }
    /**
     * Creates a new Observable, with this Observable as the source, and the passed
     * operator defined as the new observable's operator.
     * @method lift
     * @param {Operator} operator the operator defining the operation to take on the observable
     * @return {Observable} a new observable with the Operator applied
     */
    Observable$$1.prototype.lift = function (operator) {
        var observable$$1 = new Observable$$1();
        observable$$1.source = this;
        observable$$1.operator = operator;
        return observable$$1;
    };
    /**
     * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.
     *
     * <span class="informal">Use it when you have all these Observables, but still nothing is happening.</span>
     *
     * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It
     * might be for example a function that you passed to a {@link create} static factory, but most of the time it is
     * a library implementation, which defines what and when will be emitted by an Observable. This means that calling
     * `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often
     * thought.
     *
     * Apart from starting the execution of an Observable, this method allows you to listen for values
     * that an Observable emits, as well as for when it completes or errors. You can achieve this in two
     * following ways.
     *
     * The first way is creating an object that implements {@link Observer} interface. It should have methods
     * defined by that interface, but note that it should be just a regular JavaScript object, which you can create
     * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular do
     * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also
     * that your object does not have to implement all methods. If you find yourself creating a method that doesn't
     * do anything, you can simply omit it. Note however, that if `error` method is not provided, all errors will
     * be left uncaught.
     *
     * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.
     * This means you can provide three functions as arguments to `subscribe`, where first function is equivalent
     * of a `next` method, second of an `error` method and third of a `complete` method. Just as in case of Observer,
     * if you do not need to listen for something, you can omit a function, preferably by passing `undefined` or `null`,
     * since `subscribe` recognizes these functions by where they were placed in function call. When it comes
     * to `error` function, just as before, if not provided, errors emitted by an Observable will be thrown.
     *
     * Whatever style of calling `subscribe` you use, in both cases it returns a Subscription object.
     * This object allows you to call `unsubscribe` on it, which in turn will stop work that an Observable does and will clean
     * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback
     * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.
     *
     * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.
     * It is an Observable itself that decides when these functions will be called. For example {@link of}
     * by default emits all its values synchronously. Always check documentation for how given Observable
     * will behave when subscribed and if its default behavior can be modified with a {@link Scheduler}.
     *
     * @example <caption>Subscribe with an Observer</caption>
     * const sumObserver = {
     *   sum: 0,
     *   next(value) {
     *     console.log('Adding: ' + value);
     *     this.sum = this.sum + value;
     *   },
     *   error() { // We actually could just remove this method,
     *   },        // since we do not really care about errors right now.
     *   complete() {
     *     console.log('Sum equals: ' + this.sum);
     *   }
     * };
     *
     * Rx.Observable.of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.
     * .subscribe(sumObserver);
     *
     * // Logs:
     * // "Adding: 1"
     * // "Adding: 2"
     * // "Adding: 3"
     * // "Sum equals: 6"
     *
     *
     * @example <caption>Subscribe with functions</caption>
     * let sum = 0;
     *
     * Rx.Observable.of(1, 2, 3)
     * .subscribe(
     *   function(value) {
     *     console.log('Adding: ' + value);
     *     sum = sum + value;
     *   },
     *   undefined,
     *   function() {
     *     console.log('Sum equals: ' + sum);
     *   }
     * );
     *
     * // Logs:
     * // "Adding: 1"
     * // "Adding: 2"
     * // "Adding: 3"
     * // "Sum equals: 6"
     *
     *
     * @example <caption>Cancel a subscription</caption>
     * const subscription = Rx.Observable.interval(1000).subscribe(
     *   num => console.log(num),
     *   undefined,
     *   () => console.log('completed!') // Will not be called, even
     * );                                // when cancelling subscription
     *
     *
     * setTimeout(() => {
     *   subscription.unsubscribe();
     *   console.log('unsubscribed!');
     * }, 2500);
     *
     * // Logs:
     * // 0 after 1s
     * // 1 after 2s
     * // "unsubscribed!" after 2.5s
     *
     *
     * @param {Observer|Function} observerOrNext (optional) Either an observer with methods to be called,
     *  or the first of three possible handlers, which is the handler for each value emitted from the subscribed
     *  Observable.
     * @param {Function} error (optional) A handler for a terminal event resulting from an error. If no error handler is provided,
     *  the error will be thrown as unhandled.
     * @param {Function} complete (optional) A handler for a terminal event resulting from successful completion.
     * @return {ISubscription} a subscription reference to the registered handlers
     * @method subscribe
     */
    Observable$$1.prototype.subscribe = function (observerOrNext, error, complete) {
        var operator = this.operator;
        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
        if (operator) {
            operator.call(sink, this.source);
        }
        else {
            sink.add(this.source ? this._subscribe(sink) : this._trySubscribe(sink));
        }
        if (sink.syncErrorThrowable) {
            sink.syncErrorThrowable = false;
            if (sink.syncErrorThrown) {
                throw sink.syncErrorValue;
            }
        }
        return sink;
    };
    Observable$$1.prototype._trySubscribe = function (sink) {
        try {
            return this._subscribe(sink);
        }
        catch (err) {
            sink.syncErrorThrown = true;
            sink.syncErrorValue = err;
            sink.error(err);
        }
    };
    /**
     * @method forEach
     * @param {Function} next a handler for each value emitted by the observable
     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise
     * @return {Promise} a promise that either resolves on observable completion or
     *  rejects with the handled error
     */
    Observable$$1.prototype.forEach = function (next, PromiseCtor) {
        var _this = this;
        if (!PromiseCtor) {
            if (root.root.Rx && root.root.Rx.config && root.root.Rx.config.Promise) {
                PromiseCtor = root.root.Rx.config.Promise;
            }
            else if (root.root.Promise) {
                PromiseCtor = root.root.Promise;
            }
        }
        if (!PromiseCtor) {
            throw new Error('no Promise impl found');
        }
        return new PromiseCtor(function (resolve, reject) {
            // Must be declared in a separate statement to avoid a RefernceError when
            // accessing subscription below in the closure due to Temporal Dead Zone.
            var subscription;
            subscription = _this.subscribe(function (value) {
                if (subscription) {
                    // if there is a subscription, then we can surmise
                    // the next handling is asynchronous. Any errors thrown
                    // need to be rejected explicitly and unsubscribe must be
                    // called manually
                    try {
                        next(value);
                    }
                    catch (err) {
                        reject(err);
                        subscription.unsubscribe();
                    }
                }
                else {
                    // if there is NO subscription, then we're getting a nexted
                    // value synchronously during subscription. We can just call it.
                    // If it errors, Observable's `subscribe` will ensure the
                    // unsubscription logic is called, then synchronously rethrow the error.
                    // After that, Promise will trap the error and send it
                    // down the rejection path.
                    next(value);
                }
            }, reject, resolve);
        });
    };
    Observable$$1.prototype._subscribe = function (subscriber) {
        return this.source.subscribe(subscriber);
    };
    /**
     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
     * @method Symbol.observable
     * @return {Observable} this instance of the observable
     */
    Observable$$1.prototype[observable.observable] = function () {
        return this;
    };
    /* tslint:enable:max-line-length */
    /**
     * Used to stitch together functional operators into a chain.
     * @method pipe
     * @return {Observable} the Observable result of all of the operators having
     * been called in the order they were passed in.
     *
     * @example
     *
     * import { map, filter, scan } from 'rxjs/operators';
     *
     * Rx.Observable.interval(1000)
     *   .pipe(
     *     filter(x => x % 2 === 0),
     *     map(x => x + x),
     *     scan((acc, x) => acc + x)
     *   )
     *   .subscribe(x => console.log(x))
     */
    Observable$$1.prototype.pipe = function () {
        var operations = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            operations[_i - 0] = arguments[_i];
        }
        if (operations.length === 0) {
            return this;
        }
        return pipe_1.pipeFromArray(operations)(this);
    };
    /* tslint:enable:max-line-length */
    Observable$$1.prototype.toPromise = function (PromiseCtor) {
        var _this = this;
        if (!PromiseCtor) {
            if (root.root.Rx && root.root.Rx.config && root.root.Rx.config.Promise) {
                PromiseCtor = root.root.Rx.config.Promise;
            }
            else if (root.root.Promise) {
                PromiseCtor = root.root.Promise;
            }
        }
        if (!PromiseCtor) {
            throw new Error('no Promise impl found');
        }
        return new PromiseCtor(function (resolve, reject) {
            var value;
            _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });
        });
    };
    // HACK: Since TypeScript inherits static properties too, we have to
    // fight against TypeScript here so Subject can have a different static create signature
    /**
     * Creates a new cold Observable by calling the Observable constructor
     * @static true
     * @owner Observable
     * @method create
     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
     * @return {Observable} a new cold observable
     */
    Observable$$1.create = function (subscribe) {
        return new Observable$$1(subscribe);
    };
    return Observable$$1;
}());
var Observable_2 = Observable$2;


var Observable_1 = {
	Observable: Observable_2
};

var iterator = createCommonjsModule(function (module, exports) {
function symbolIteratorPonyfill(root$$2) {
    var Symbol = root$$2.Symbol;
    if (typeof Symbol === 'function') {
        if (!Symbol.iterator) {
            Symbol.iterator = Symbol('iterator polyfill');
        }
        return Symbol.iterator;
    }
    else {
        // [for Mozilla Gecko 27-35:](https://mzl.la/2ewE1zC)
        var Set_1 = root$$2.Set;
        if (Set_1 && typeof new Set_1()['@@iterator'] === 'function') {
            return '@@iterator';
        }
        var Map_1 = root$$2.Map;
        // required for compatability with es6-shim
        if (Map_1) {
            var keys = Object.getOwnPropertyNames(Map_1.prototype);
            for (var i = 0; i < keys.length; ++i) {
                var key = keys[i];
                // according to spec, Map.prototype[@@iterator] and Map.orototype.entries must be equal.
                if (key !== 'entries' && key !== 'size' && Map_1.prototype[key] === Map_1.prototype['entries']) {
                    return key;
                }
            }
        }
        return '@@iterator';
    }
}
exports.symbolIteratorPonyfill = symbolIteratorPonyfill;
exports.iterator = symbolIteratorPonyfill(root.root);
/**
 * @deprecated use iterator instead
 */
exports.$$iterator = exports.iterator;

});

var iterator_1 = iterator.symbolIteratorPonyfill;
var iterator_2 = iterator.iterator;
var iterator_3 = iterator.$$iterator;

var __extends$6 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var InnerSubscriber = (function (_super) {
    __extends$6(InnerSubscriber, _super);
    function InnerSubscriber(parent, outerValue, outerIndex) {
        _super.call(this);
        this.parent = parent;
        this.outerValue = outerValue;
        this.outerIndex = outerIndex;
        this.index = 0;
    }
    InnerSubscriber.prototype._next = function (value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
    };
    InnerSubscriber.prototype._error = function (error) {
        this.parent.notifyError(error, this);
        this.unsubscribe();
    };
    InnerSubscriber.prototype._complete = function () {
        this.parent.notifyComplete(this);
        this.unsubscribe();
    };
    return InnerSubscriber;
}(Subscriber_1.Subscriber));
var InnerSubscriber_2 = InnerSubscriber;


var InnerSubscriber_1 = {
	InnerSubscriber: InnerSubscriber_2
};

function subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {
    var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);
    if (destination.closed) {
        return null;
    }
    if (result instanceof Observable_1.Observable) {
        if (result._isScalar) {
            destination.next(result.value);
            destination.complete();
            return null;
        }
        else {
            destination.syncErrorThrowable = true;
            return result.subscribe(destination);
        }
    }
    else if (isArrayLike.isArrayLike(result)) {
        for (var i = 0, len = result.length; i < len && !destination.closed; i++) {
            destination.next(result[i]);
        }
        if (!destination.closed) {
            destination.complete();
        }
    }
    else if (isPromise_1.isPromise(result)) {
        result.then(function (value) {
            if (!destination.closed) {
                destination.next(value);
                destination.complete();
            }
        }, function (err) { return destination.error(err); })
            .then(null, function (err) {
            // Escaping the Promise trap: globally throw unhandled errors
            root.root.setTimeout(function () { throw err; });
        });
        return destination;
    }
    else if (result && typeof result[iterator.iterator] === 'function') {
        var iterator$$1 = result[iterator.iterator]();
        do {
            var item = iterator$$1.next();
            if (item.done) {
                destination.complete();
                break;
            }
            destination.next(item.value);
            if (destination.closed) {
                break;
            }
        } while (true);
    }
    else if (result && typeof result[observable.observable] === 'function') {
        var obs = result[observable.observable]();
        if (typeof obs.subscribe !== 'function') {
            destination.error(new TypeError('Provided object does not correctly implement Symbol.observable'));
        }
        else {
            return obs.subscribe(new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex));
        }
    }
    else {
        var value = isObject_1.isObject(result) ? 'an invalid object' : "'" + result + "'";
        var msg = ("You provided " + value + " where a stream was expected.")
            + ' You can provide an Observable, Promise, Array, or Iterable.';
        destination.error(new TypeError(msg));
    }
    return null;
}
var subscribeToResult_2 = subscribeToResult;


var subscribeToResult_1 = {
	subscribeToResult: subscribeToResult_2
};

var __extends$4 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/* tslint:enable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable, emitting values only from the most recently projected Observable.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link switch}.</span>
 *
 * <img src="./img/switchMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an (so-called "inner") Observable. Each time it observes one of these
 * inner Observables, the output Observable begins emitting the items emitted by
 * that inner Observable. When a new inner Observable is emitted, `switchMap`
 * stops emitting items from the earlier-emitted inner Observable and begins
 * emitting items from the new one. It continues to behave like this for
 * subsequent inner Observables.
 *
 * @example <caption>Rerun an interval Observable on every click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatMap}
 * @see {@link exhaustMap}
 * @see {@link mergeMap}
 * @see {@link switch}
 * @see {@link switchMapTo}
 *
 * @param {function(value: T, ?index: number): ObservableInput} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An Observable that emits the result of applying the
 * projection function (and the optional `resultSelector`) to each item emitted
 * by the source Observable and taking only the values from the most recently
 * projected inner Observable.
 * @method switchMap
 * @owner Observable
 */
function switchMap$1(project, resultSelector) {
    return function switchMapOperatorFunction(source) {
        return source.lift(new SwitchMapOperator(project, resultSelector));
    };
}
var switchMap_2 = switchMap$1;
var SwitchMapOperator = (function () {
    function SwitchMapOperator(project, resultSelector) {
        this.project = project;
        this.resultSelector = resultSelector;
    }
    SwitchMapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project, this.resultSelector));
    };
    return SwitchMapOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SwitchMapSubscriber = (function (_super) {
    __extends$4(SwitchMapSubscriber, _super);
    function SwitchMapSubscriber(destination, project, resultSelector) {
        _super.call(this, destination);
        this.project = project;
        this.resultSelector = resultSelector;
        this.index = 0;
    }
    SwitchMapSubscriber.prototype._next = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (error) {
            this.destination.error(error);
            return;
        }
        this._innerSub(result, value, index);
    };
    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {
        var innerSubscription = this.innerSubscription;
        if (innerSubscription) {
            innerSubscription.unsubscribe();
        }
        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, result, value, index));
    };
    SwitchMapSubscriber.prototype._complete = function () {
        var innerSubscription = this.innerSubscription;
        if (!innerSubscription || innerSubscription.closed) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapSubscriber.prototype._unsubscribe = function () {
        this.innerSubscription = null;
    };
    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {
        this.remove(innerSub);
        this.innerSubscription = null;
        if (this.isStopped) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (this.resultSelector) {
            this._tryNotifyNext(outerValue, innerValue, outerIndex, innerIndex);
        }
        else {
            this.destination.next(innerValue);
        }
    };
    SwitchMapSubscriber.prototype._tryNotifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {
        var result;
        try {
            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return SwitchMapSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

// CDK
/**
 * Injection token that determines the scroll handling while the autocomplete panel is open.
 */
const DEFAULT_OVERLAY_SCROLL_STRATEGY = new InjectionToken('novo-overlay-scroll-strategy');
/**
 * \@docs-private
 * @param {?} overlay
 * @return {?}
 */
function DEFAULT_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay$$1) {
    return () => overlay$$1.scrollStrategies.reposition();
}
/**
 * \@docs-private
 */
const DEFAULT_OVERLAY_SCROLL_STRATEGY_PROVIDER = {
    provide: DEFAULT_OVERLAY_SCROLL_STRATEGY,
    deps: [Overlay],
    useFactory: DEFAULT_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY,
};
class NovoOverlayTemplate {
    /**
     * @param {?} _overlay
     * @param {?} _viewContainerRef
     * @param {?} _zone
     * @param {?} _changeDetectorRef
     * @param {?} _scrollStrategy
     * @param {?} _document
     */
    constructor(_overlay, _viewContainerRef, _zone, _changeDetectorRef, _scrollStrategy, _document) {
        this._overlay = _overlay;
        this._viewContainerRef = _viewContainerRef;
        this._zone = _zone;
        this._changeDetectorRef = _changeDetectorRef;
        this._scrollStrategy = _scrollStrategy;
        this._document = _document;
        this.id = `novo-overlay-${Date.now()}`;
        this.position = 'default';
        this.closeOnSelect = true;
        this.select = new EventEmitter();
        this.closing = new EventEmitter();
        this._panelOpen = false;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._destroyPanel();
    }
    /**
     * @return {?}
     */
    get panelOpen() {
        return this._panelOpen;
    }
    /**
     * Opens the autocomplete suggestion panel.
     * @return {?}
     */
    openPanel() {
        //if (!this.overlayTemplate) {
        //throw getMdAutocompleteMissingPanelError();
        //}
        if (!this._overlayRef) {
            this._createOverlay(this.template);
        }
        else {
            /** Update the panel width, in case the host width has changed */
            this._overlayRef.getConfig().width = this._getHostWidth();
            this._overlayRef.updateSize();
            this._overlayRef.updatePosition();
        }
        if (this._overlayRef && !this._overlayRef.hasAttached()) {
            this._overlayRef.attach(this._portal);
            this._closingActionsSubscription = this._subscribeToClosingActions();
        }
        this._panelOpen = true;
        this._changeDetectorRef.markForCheck();
        setTimeout(() => this._overlayRef.updatePosition());
    }
    /**
     * Closes the autocomplete suggestion panel.
     * @return {?}
     */
    closePanel() {
        this._zone.run(() => {
            if (this._overlayRef && this._overlayRef.hasAttached()) {
                this._overlayRef.detach();
                this._closingActionsSubscription.unsubscribe();
            }
            this.closing.emit(true);
            if (this._panelOpen) {
                this._panelOpen = false;
                // We need to trigger change detection manually, because
                // `fromEvent` doesn't seem to do it at the proper time.
                // This ensures that the placeholder is reset when the
                // user clicks outside.
                this._changeDetectorRef.markForCheck();
            }
        });
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onClosingAction(event) {
        this.closePanel();
    }
    /**
     * A stream of actions that should close the autocomplete panel, including
     * when an option is selected, on blur, and when TAB is pressed.
     * @return {?}
     */
    get panelClosingActions() {
        return merge$1(
        //this.overlayTemplate._keyManager.tabOut,
        this._outsideClickStream);
    }
    /**
     * Stream of clicks outside of the autocomplete panel.
     * @return {?}
     */
    get _outsideClickStream() {
        if (!this._document) {
            return of$1(null);
        }
        return merge$1(fromEvent$1(this._document, 'click'), fromEvent$1(this._document, 'touchend'))
            .pipe(filter$1((event) => {
            const /** @type {?} */ clickTarget = (event.target);
            const /** @type {?} */ clicked = this._panelOpen &&
                clickTarget !== this._getConnectedElement().nativeElement &&
                (!this._getConnectedElement().nativeElement.contains(clickTarget)) &&
                (!!this._overlayRef && !this._overlayRef.overlayElement.contains(clickTarget));
            if (this._panelOpen && !!this._overlayRef && this._overlayRef.overlayElement.contains(clickTarget) && this.closeOnSelect) {
                this.select.emit(event);
            }
            return clicked;
        }));
    }
    /**
     * This method listens to a stream of panel closing actions and resets the
     * stream every time the option list changes.
     * @return {?}
     */
    _subscribeToClosingActions() {
        const /** @type {?} */ firstStable = this._zone.onStable.asObservable().pipe(first_2());
        //const valueChanges = Observable.from(this.value);
        // When the zone is stable initially, and when the option list changes...
        return merge$1(firstStable)
            .pipe(
        // create a new stream of panelClosingActions, replacing any previous streams
        // that were created, and flatten it so our stream only emits closing events...
        switchMap_2(() => {
            return this.panelClosingActions;
        }), 
        // when the first closing event occurs...
        first_2())
            .subscribe(event => this.onClosingAction(event));
    }
    /**
     * Destroys the autocomplete suggestion panel.
     * @return {?}
     */
    _destroyPanel() {
        if (this._overlayRef) {
            this.closePanel();
            this._overlayRef.dispose();
            this._overlayRef = null;
        }
    }
    /**
     * @param {?} template
     * @return {?}
     */
    _createOverlay(template) {
        this._portal = new TemplatePortal(template, this._viewContainerRef);
        this._overlayRef = this._overlay.create(this._getOverlayConfig());
        this._overlayRef.getConfig().width = this._getHostWidth();
    }
    /**
     * @return {?}
     */
    _getOverlayConfig() {
        const /** @type {?} */ overlayState = new OverlayConfig();
        overlayState.positionStrategy = this._getOverlayPosition();
        //overlayState.width = this._getHostWidth();
        overlayState.direction = 'ltr';
        overlayState.scrollStrategy = this._scrollStrategy();
        return overlayState;
    }
    /**
     * @return {?}
     */
    _getOverlayPosition() {
        switch (this.position) {
            case 'center':
                this._positionStrategy = this._overlay.position()
                    .connectedTo(this._getConnectedElement(), { originX: 'start', originY: 'center' }, { overlayX: 'start', overlayY: 'center' })
                    .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'top' })
                    .withFallbackPosition({ originX: 'start', originY: 'bottom' }, { overlayX: 'start', overlayY: 'bottom' });
                break;
            default:
                this._positionStrategy = this._overlay.position()
                    .connectedTo(this._getConnectedElement(), { originX: 'start', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' })
                    .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' });
                break;
        }
        return this._positionStrategy;
    }
    /**
     * @return {?}
     */
    _getConnectedElement() {
        return this.parent;
    }
    /**
     * Returns the width of the input element, so the panel width can match it.
     * @return {?}
     */
    _getHostWidth() {
        return this._getConnectedElement().nativeElement.getBoundingClientRect().width;
    }
}
NovoOverlayTemplate.decorators = [
    { type: Component, args: [{
                selector: 'novo-overlay-template',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: `
    <ng-template>
        <div class="novo-overlay-panel" role="listbox" [id]="id" #panel>
            <ng-content></ng-content>
        </div>
    </ng-template>
  `
            },] },
];
/**
 * @nocollapse
 */
NovoOverlayTemplate.ctorParameters = () => [
    { type: Overlay, },
    { type: ViewContainerRef, },
    { type: NgZone, },
    { type: ChangeDetectorRef, },
    { type: undefined, decorators: [{ type: Inject, args: [DEFAULT_OVERLAY_SCROLL_STRATEGY,] },] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] },] },
];
NovoOverlayTemplate.propDecorators = {
    'template': [{ type: ViewChild, args: [TemplateRef,] },],
    'panel': [{ type: ViewChild, args: ['panel',] },],
    'parent': [{ type: Input },],
    'position': [{ type: Input },],
    'closeOnSelect': [{ type: Input },],
    'select': [{ type: Output },],
    'closing': [{ type: Output },],
};

// NG2
// APP
class NovoOverlayModule {
}
NovoOverlayModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, FormsModule, OverlayModule],
                declarations: [NovoOverlayTemplate],
                exports: [NovoOverlayTemplate],
                providers: [DEFAULT_OVERLAY_SCROLL_STRATEGY_PROVIDER]
            },] },
];
/**
 * @nocollapse
 */
NovoOverlayModule.ctorParameters = () => [];

// NG2
// APP
// Value accessor for the component (supports ngModel)
const SELECT_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => NovoSelectElement),
    multi: true
};
class NovoSelectElement {
    /**
     * @param {?} element
     * @param {?} labels
     */
    constructor(element, labels) {
        this.element = element;
        this.labels = labels;
        this.placeholder = 'Select...';
        this.onSelect = new EventEmitter();
        this.selectedIndex = -1;
        this.empty = true;
        this.header = {
            open: false,
            valid: true,
            value: ''
        };
        this.onModelChange = () => { };
        this.onModelTouched = () => { };
        this.filterTerm = '';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.ngOnChanges();
    }
    /**
     * @param {?=} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this.readonly = this.readonly === true;
        if (this.options && this.options.length && typeof this.options[0] === 'string') {
            this.filteredOptions = this.options.map((item) => {
                return { value: item, label: item };
            });
        }
        else {
            this.filteredOptions = (this.options || []).filter((item) => {
                return !item.readOnly;
            });
            this.filteredOptions.forEach(element => {
                element.active = false;
            });
        }
        if (!this.model && !this.createdItem) {
            this.clear();
        }
        else if (this.createdItem) {
            let /** @type {?} */ item = this.options.find(i => i.label === this.createdItem);
            let /** @type {?} */ index = this.options.indexOf(item);
            this.select(item, index);
        }
        else {
            this.writeValue(this.model);
        }
        if (this.panelOpen) {
            this.openPanel();
        }
    }
    /**
     * BEGIN: Convienient Panel Methods.
     * @return {?}
     */
    openPanel() {
        this.overlay.openPanel();
    }
    /**
     * @return {?}
     */
    closePanel() {
        this.overlay.closePanel();
    }
    /**
     * @return {?}
     */
    get panelOpen() {
        return this.overlay && this.overlay.panelOpen;
    }
    /**
     * This method closes the panel, and if a value is specified, also sets the associated
     * control to that value. It will also mark the control as dirty if this interaction
     * stemmed from the user.
     * @param {?} event
     * @return {?}
     */
    setValueAndClose(event) {
        if (event.value && event.index >= 0) {
            this.select(event.value, event.index);
        }
        this.closePanel();
    }
    /**
     * @param {?} option
     * @param {?} i
     * @param {?=} fireEvents
     * @return {?}
     */
    select(option, i, fireEvents = true) {
        if (this.selected) {
            this.selected.active = false;
        }
        this.selectedIndex = i;
        this.selected = option;
        this.selected.active = true;
        this.empty = false;
        if (fireEvents) {
            this.onModelChange(this.selected.value);
            this.onSelect.emit({ selected: this.selected.value });
        }
    }
    /**
     * @return {?}
     */
    clear() {
        this.selected = {
            label: this.placeholder,
            value: null,
            active: false
        };
        this.header = {
            open: false,
            valid: true,
            value: ''
        };
        this.selectedIndex = -1;
        this.empty = true;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onKeyDown(event) {
        if (this.panelOpen) {
            if (!this.header.open) {
                // Prevent Scrolling
                event.preventDefault();
            }
            // Close popup on escape key
            if (event.keyCode === KeyCodes.ESC) {
                this.closePanel();
                return;
            }
            if (event.keyCode === KeyCodes.ENTER) {
                if (this.header.open && this.header.value) {
                    this.saveHeader();
                    return;
                }
                this.setValueAndClose({ value: this.filteredOptions[this.selectedIndex], index: this.selectedIndex });
                return;
            }
            if (event.keyCode === KeyCodes.UP && this.selectedIndex > 0) {
                this.selectedIndex--;
                this.select(this.filteredOptions[this.selectedIndex], this.selectedIndex);
                this.scrollToSelected();
            }
            else if (event.keyCode === KeyCodes.DOWN && this.selectedIndex < this.filteredOptions.length - 1) {
                this.selectedIndex++;
                this.select(this.filteredOptions[this.selectedIndex], this.selectedIndex);
                this.scrollToSelected();
                if (this.header.open) {
                    this.toggleHeader(null, false);
                }
            }
            else if (event.keyCode === KeyCodes.UP && this.selectedIndex === 0) {
                this.selectedIndex--;
                this.toggleHeader(null, true);
            }
            else if (event.keyCode >= 65 && event.keyCode <= 90 || event.keyCode === KeyCodes.SPACE) {
                clearTimeout(this.filterTermTimeout);
                this.filterTermTimeout = setTimeout(() => { this.filterTerm = ''; }, 2000);
                let /** @type {?} */ char = String.fromCharCode(event.keyCode);
                this.filterTerm = this.filterTerm.concat(char);
                // let element = this.element.nativeElement;
                // let list = element.querySelector('.novo-select-list');
                // let item = element.querySelector(`[data-automation-value^="${this.filterTerm}" i]`);
                let /** @type {?} */ item = this.filteredOptions.find(i => i.label.toUpperCase().indexOf(this.filterTerm) === 0);
                if (item) {
                    this.select(item, this.filteredOptions.indexOf(item));
                    this.scrollToSelected();
                }
            }
            else if ([KeyCodes.BACKSPACE, KeyCodes.DELETE].includes(event.keyCode)) {
                clearTimeout(this.filterTermTimeout);
                this.filterTermTimeout = setTimeout(() => { this.filterTerm = ''; }, 2000);
                this.filterTerm = this.filterTerm.slice(0, -1);
            }
        }
        else {
            if ([KeyCodes.DOWN, KeyCodes.UP].includes(event.keyCode)) {
                this.panelOpen ? this.closePanel() : this.openPanel();
            }
        }
    }
    /**
     * @return {?}
     */
    scrollToSelected() {
        this.scrollToIndex(this.selectedIndex);
    }
    /**
     * @param {?} index
     * @return {?}
     */
    scrollToIndex(index) {
        let /** @type {?} */ element = this.overlay._overlayRef.overlayElement;
        let /** @type {?} */ list = element.querySelector('.novo-select-list');
        let /** @type {?} */ items = list.querySelectorAll('li');
        let /** @type {?} */ item = items[this.headerConfig ? index + 1 : index];
        if (item) {
            list.scrollTop = item.offsetTop;
        }
    }
    /**
     * @param {?} event
     * @param {?} forceValue
     * @return {?}
     */
    toggleHeader(event, forceValue) {
        if (event) {
            event.stopPropagation();
            event.preventDefault();
        }
        // Reverse the active property (if forceValue, use that)
        this.header = {
            open: forceValue !== undefined ? forceValue : !this.header.open,
            value: '',
            valid: true
        };
    }
    /**
     * @param {?} match
     * @param {?} query
     * @return {?}
     */
    highlight(match, query) {
        // Replaces the capture string with a the same string inside of a "strong" tag
        return query ? match.replace(new RegExp(this.escapeRegexp(query), 'gi'), '<strong>$&</strong>') : match;
    }
    /**
     * @param {?} queryToEscape
     * @return {?}
     */
    escapeRegexp(queryToEscape) {
        // Ex: if the capture is "a" the result will be \a
        return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
    }
    /**
     * @return {?}
     */
    saveHeader() {
        if (this.header.value) {
            this.headerConfig.onSave(this.header.value);
            this.createdItem = this.header.value;
            this.closePanel();
        }
        else {
            this.header.valid = false;
        }
    }
    /**
     * @param {?} model
     * @return {?}
     */
    writeValue(model) {
        this.model = model;
        if (this.options) {
            let /** @type {?} */ item = this.filteredOptions.find(i => i.value === model);
            if (!item && !Helpers.isEmpty(model)) {
                item = {
                    label: model,
                    value: model
                };
                if (!item.readOnly) {
                    this.options.unshift(item);
                }
            }
            if (item) {
                this.select(item, this.filteredOptions.indexOf(item), false);
                this.empty = false;
            }
            else {
                this.clear();
            }
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onModelChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onModelTouched = fn;
    }
}
NovoSelectElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-select',
                providers: [SELECT_VALUE_ACCESSOR],
                template: `
        <div (click)="openPanel()" tabIndex="0" type="button" [class.empty]="empty">{{selected.label}}<i class="bhi-collapse"></i></div>
        <novo-overlay-template [parent]="element" position="center">
            <ul class="novo-select-list" tabIndex="-1" [class.header]="headerConfig" [class.active]="panelOpen">
                <ng-content></ng-content>
                <li *ngIf="headerConfig" class="select-header" [class.open]="header.open">
                    <button  *ngIf="!header.open" (click)="toggleHeader($event); false" tabIndex="-1" type="button" class="header"><i class="bhi-add-thin"></i>&nbsp;{{headerConfig.label}}</button>
                    <div *ngIf="header.open" [ngClass]="{active: header.open}">
                        <input autofocus type="text" [placeholder]="headerConfig.placeholder" [attr.id]="name" autocomplete="false" [(ngModel)]="header.value" [ngClass]="{invalid: !header.valid}"/>
                        <footer>
                            <button (click)="toggleHeader($event, false)">{{labels.cancel}}</button>
                            <button (click)="saveHeader()" class="primary">{{labels.save}}</button>
                        </footer>
                    </div>
                </li>
                <li *ngFor="let option of filteredOptions; let i = index" [ngClass]="{active: option.active}" (click)="setValueAndClose({value: option, index: i})" [attr.data-automation-value]="option.label">
                    <span [innerHtml]="highlight(option.label, filterTerm)"></span>
                    <i *ngIf="option.active" class="bhi-check"></i>
                </li>
            </ul>
        </novo-overlay-template>
    `,
                host: {
                    '(keydown)': 'onKeyDown($event)'
                }
            },] },
];
/**
 * @nocollapse
 */
NovoSelectElement.ctorParameters = () => [
    { type: ElementRef, },
    { type: NovoLabelService, },
];
NovoSelectElement.propDecorators = {
    'name': [{ type: Input },],
    'options': [{ type: Input },],
    'placeholder': [{ type: Input },],
    'readonly': [{ type: Input },],
    'headerConfig': [{ type: Input },],
    'onSelect': [{ type: Output },],
    'overlay': [{ type: ViewChild, args: [NovoOverlayTemplate,] },],
    'onKeyDown': [{ type: HostListener, args: ['keydown', ['$event'],] },],
};

// NG2
// APP
class NovoSelectModule {
}
NovoSelectModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, FormsModule, OverlayModule, NovoOverlayModule],
                declarations: [NovoSelectElement],
                exports: [NovoSelectElement]
            },] },
];
/**
 * @nocollapse
 */
NovoSelectModule.ctorParameters = () => [];

// NG2
// APP
// Value accessor for the component (supports ngModel)
const SWITCH_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => NovoSwitchElement),
    multi: true
};
class NovoSwitchElement {
    /**
     * @param {?} ref
     */
    constructor(ref) {
        this.ref = ref;
        this.onChange = new EventEmitter();
        this._disabled = false;
        this.onModelChange = () => {
        };
        this.onModelTouched = () => {
        };
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this._disabled = (!value);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onKeydown(event) {
        if (event.keyCode === KeyCodes.SPACE) {
            event.preventDefault();
            this.toggle(event);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    toggle(event) {
        if (event) {
            event.stopPropagation();
            event.preventDefault();
        }
        if (this.disabled) {
            return;
        }
        this.model = !this.model;
        this.onChange.next(this.model);
        this.onModelChange(this.model);
        this.ref.markForCheck();
    }
    /**
     * @param {?} model
     * @return {?}
     */
    writeValue(model) {
        this.model = model;
        this.ref.markForCheck();
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onModelChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onModelTouched = fn;
    }
}
NovoSwitchElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-switch',
                providers: [SWITCH_VALUE_ACCESSOR],
                template: `
        <div (click)="toggle($event)">
            <div class="novo-switch-container">
                <div class="novo-switch-bar"></div>
                <div class="novo-switch-thumb-container">
                    <div class="novo-switch-thumb"></div>
                </div>
            </div>
            <div class="novo-switch-label"><ng-content></ng-content></div>
        </div>
    `,
                host: {
                    'role': 'checkbox',
                    '[attr.aria-checked]': 'model',
                    '[attr.aria-disabled]': 'disabled',
                    '(keydown)': 'onKeydown($event)',
                    '[class]': 'theme'
                }
            },] },
];
/**
 * @nocollapse
 */
NovoSwitchElement.ctorParameters = () => [
    { type: ChangeDetectorRef, },
];
NovoSwitchElement.propDecorators = {
    'theme': [{ type: Input },],
    'onChange': [{ type: Output },],
    'disabled': [{ type: Input, args: ['disabled',] },],
};

// NG2
// APP
class NovoSwitchModule {
}
NovoSwitchModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, FormsModule],
                declarations: [NovoSwitchElement],
                exports: [NovoSwitchElement]
            },] },
];
/**
 * @nocollapse
 */
NovoSwitchModule.ctorParameters = () => [];

// NG2
// Vendor
// Value accessor for the component (supports ngModel)
const PICKER_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => NovoPickerElement),
    multi: true
};
/**
 * \@name Picker
 *
 * \@description This class is the directive definition of the Picker. If you add and attribute of `picker` to an input,
 * it will create an instance of the picker which wraps the input in all of the picker HTML elements and functionality.
 * Picker should be added as a two-way bound ngModel instance `[(picker)]=""` in order to have the picker options
 * dynamically populate.
 */
class NovoPickerElement {
    /**
     * @param {?} element
     * @param {?} componentUtils
     * @param {?} ref
     */
    constructor(element, componentUtils, ref) {
        this.element = element;
        this.componentUtils = componentUtils;
        this.ref = ref;
        this.closeOnSelect = true;
        this.selected = [];
        // Deprecated
        this.appendToBody = false;
        // Deprecated
        this.parentScrollAction = 'close';
        // Side the dropdown will open
        this.side = 'left';
        // Autoselects the first option in the results
        this.autoSelectFirstOption = true;
        this._disablePickerInput = false;
        // Emitter for selects
        this.changed = new EventEmitter();
        this.select = new EventEmitter();
        this.focus = new EventEmitter();
        this.blur = new EventEmitter();
        this.typing = new EventEmitter();
        this.isStatic = true;
        this.term = '';
        this.onModelChange = () => { };
        this.onModelTouched = () => { };
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set disablePickerInput(v) {
        this._disablePickerInput = coerceBooleanProperty(v);
    }
    /**
     * @return {?}
     */
    get disablePickerInput() {
        return this._disablePickerInput;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.overrideElement) {
            this.element = this.overrideElement;
        }
        if (this.appendToBody) {
            console.warn(`'appendToBody' has been deprecated. Please remove this attribute.`);
        }
        // Custom results template
        this.resultsComponent = this.config.resultsTemplate || PickerResults;
        // Get all distinct key up events from the input and only fire if long enough and distinct
        //let input = this.element.nativeElement.querySelector('input');
        const /** @type {?} */ pasteObserver = Observable$1.fromEvent(this.input.nativeElement, 'paste')
            .debounceTime(250)
            .distinctUntilChanged();
        pasteObserver.subscribe((event) => this.onDebouncedKeyup(event), err => this.hideResults(err));
        const /** @type {?} */ keyboardObserver = Observable$1.fromEvent(this.input.nativeElement, 'keyup')
            .debounceTime(250)
            .distinctUntilChanged();
        keyboardObserver.subscribe((event) => this.onDebouncedKeyup(event), err => this.hideResults(err));
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onDebouncedKeyup(event) {
        if ([KeyCodes.ESC, KeyCodes.UP, KeyCodes.DOWN, KeyCodes.ENTER, KeyCodes.TAB].includes(event['keyCode'])) {
            return;
        }
        this.show(((event.target)).value);
    }
    /**
     * BEGIN: Convienient Panel Methods.
     * @return {?}
     */
    openPanel() {
        this.container.openPanel();
    }
    /**
     * @return {?}
     */
    closePanel() {
        this.container.closePanel();
    }
    /**
     * @return {?}
     */
    get panelOpen() {
        return this.container && this.container.panelOpen;
    }
    /**
     * END: Convienient Panel Methods.
     * @param {?=} term
     * @return {?}
     */
    show(term) {
        this.openPanel();
        // Show the results inside
        this.showResults(term);
    }
    /**
     * @return {?}
     */
    hide() {
        this.closePanel();
        this.ref.markForCheck();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onKeyDown(event) {
        if (this.disablePickerInput) {
            Helpers.swallowEvent(event);
        }
        if (this.panelOpen && !this.disablePickerInput) {
            if (event.keyCode === KeyCodes.ESC || event.keyCode === KeyCodes.TAB) {
                this.hideResults();
                return;
            }
            if (event.keyCode === KeyCodes.UP) {
                this.popup.instance.prevActiveMatch();
                this.ref.markForCheck();
                return;
            }
            if (event.keyCode === KeyCodes.DOWN) {
                this.popup.instance.nextActiveMatch();
                this.ref.markForCheck();
                return;
            }
            if (event.keyCode === KeyCodes.ENTER) {
                this.popup.instance.selectActiveMatch();
                this.ref.markForCheck();
                return;
            }
            if (event.keyCode === KeyCodes.BACKSPACE && !Helpers.isBlank(this._value)) {
                this.clearValue(false);
                this.closePanel();
            }
        }
    }
    /**
     * @param {?} wipeTerm
     * @return {?}
     */
    clearValue(wipeTerm) {
        this._value = null;
        this.select.emit(this._value);
        this.changed.emit({ value: this._value, rawValue: { label: '', value: this._value } });
        this.onModelChange(this._value);
        if (wipeTerm) {
            this.term = null;
            this.hideResults();
        }
        this.ref.markForCheck();
    }
    /**
     * \@name onFocus
     * \@description When the input's focus event is called this method calls the debounced function that displays the
     * results.
     * @param {?} event
     * @return {?}
     */
    onFocus(event) {
        this.show();
        this.focus.emit(event);
    }
    /**
     * \@name showResults
     *
     * \@description This method creates an instance of the results (called popup) and adds all the bindings to that
     * instance.
     * @param {?=} term
     * @return {?}
     */
    showResults(term) {
        // Update Matches
        if (this.popup) {
            // Update existing list or create the DOM element
            this.popup.instance.config = this.config;
            this.popup.instance.term = this.term;
            this.popup.instance.selected = this.selected;
            this.popup.instance.autoSelectFirstOption = this.autoSelectFirstOption;
            this.ref.markForCheck();
        }
        else {
            this.popup = this.componentUtils.appendNextToLocation(this.resultsComponent, this.results);
            this.popup.instance.parent = this;
            this.popup.instance.config = this.config;
            this.popup.instance.term = this.term;
            this.popup.instance.selected = this.selected;
            this.popup.instance.autoSelectFirstOption = this.autoSelectFirstOption;
            this.popup.instance.overlay = this.container._overlayRef;
            this.ref.markForCheck();
        }
    }
    /**
     * \@name hideResults
     *
     * \@description - This method deletes the picker results from the DOM.
     * @param {?=} err
     * @return {?}
     */
    hideResults(err) {
        if (this.popup) {
            this.popup.destroy();
            this.popup = null;
        }
        this.hide();
    }
    /**
     * @return {?}
     */
    get value() {
        return this._value;
    }
    /**
     * @param {?} selected
     * @return {?}
     */
    set value(selected) {
        if (!selected) {
            this.term = '';
            this._value = null;
            this.onModelChange(this._value);
        }
        else if (selected.value !== this._value) {
            this.term = this.clearValueOnSelect ? '' : selected.label;
            this._value = selected.value;
            this.changed.emit({ value: selected.value, rawValue: { label: this.term, value: selected.value } });
            this.select.emit(selected);
            this.onModelChange(selected.value);
        }
        else {
            this.changed.emit({ value: selected.value, rawValue: { label: this.term, value: this._value } });
            this.select.emit(selected);
        }
        this.ref.markForCheck();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    checkTerm(event) {
        this.typing.emit(event);
        if (!event || !event.length) {
            this._value = null;
            this.onModelChange(this._value);
        }
        this.ref.markForCheck();
    }
    /**
     * @param {?=} event
     * @return {?}
     */
    onTouched(event) {
        this.onModelTouched();
        this.blur.emit(event);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (this.clearValueOnSelect) {
            this.term = '';
        }
        else {
            if (typeof value === 'string') {
                this.term = value;
            }
            else if (value && value.label) {
                this.term = value.label;
            }
            else if (value && value.firstName) {
                this.term = `${value.firstName} ${value.lastName}`;
            }
            else if (value && value.name) {
                this.term = value.name;
            }
            else if (this.config.getLabels && typeof this.config.getLabels === 'function') {
                this.config.getLabels(value).then(result => {
                    if (result) {
                        this.term = result.label || '';
                    }
                    else {
                        this.term = value;
                    }
                });
            }
            else {
                this.term = value || '';
            }
        }
        this._value = value;
        this.ref.markForCheck();
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onModelChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onModelTouched = fn;
    }
}
NovoPickerElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-picker',
                providers: [PICKER_VALUE_ACCESSOR],
                template: `
        <i class="bhi-more" *ngIf="config?.entityIcon && !_value"></i>
        <i class="bhi-{{ config?.entityIcon }} entity-icon {{ config?.entityIcon }}" *ngIf="config?.entityIcon && _value"></i>
        <input
            type="text"
            [(ngModel)]="term"
            [class.entity-picker]="config.entityIcon"
            [class.entity-selected]="config?.entityIcon && _value"
            (ngModelChange)="checkTerm($event)"
            [placeholder]="placeholder"
            (keydown)="onKeyDown($event)"
            (focus)="onFocus($event)"
            (click)="onFocus($event)"
            (blur)="onTouched($event)"
            autocomplete="off" #input />
        <i class="bhi-search" *ngIf="!_value || clearValueOnSelect"></i>
        <i class="bhi-times" [class.entity-selected]="config?.entityIcon && _value" *ngIf="_value && !clearValueOnSelect" (click)="clearValue(true)"></i>
        <novo-overlay-template class="picker-results-container" [parent]="element">
            <span #results></span>
            <ng-content></ng-content>
        </novo-overlay-template>
    `
            },] },
];
/**
 * @nocollapse
 */
NovoPickerElement.ctorParameters = () => [
    { type: ElementRef, },
    { type: ComponentUtils, },
    { type: ChangeDetectorRef, },
];
NovoPickerElement.propDecorators = {
    'results': [{ type: ViewChild, args: ['results', { read: ViewContainerRef },] },],
    'config': [{ type: Input },],
    'placeholder': [{ type: Input },],
    'clearValueOnSelect': [{ type: Input },],
    'closeOnSelect': [{ type: Input },],
    'selected': [{ type: Input },],
    'appendToBody': [{ type: Input },],
    'parentScrollSelector': [{ type: Input },],
    'parentScrollAction': [{ type: Input },],
    'containerClass': [{ type: Input },],
    'side': [{ type: Input },],
    'autoSelectFirstOption': [{ type: Input },],
    'overrideElement': [{ type: Input },],
    'disablePickerInput': [{ type: Input },],
    'changed': [{ type: Output },],
    'select': [{ type: Output },],
    'focus': [{ type: Output },],
    'blur': [{ type: Output },],
    'typing': [{ type: Output },],
    'container': [{ type: ViewChild, args: [NovoOverlayTemplate,] },],
    'input': [{ type: ViewChild, args: ['input',] },],
};

// NG2
// APP
class NovoPickerContainer {
    /**
     * @param {?} element
     * @param {?} renderer
     */
    constructor(element, renderer) {
        this.element = element;
        this.renderer = renderer;
        this.scrollHandler = this.handleScroll.bind(this);
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        if (this.isVisible && this.position) {
            const /** @type {?} */ element = this.element.nativeElement;
            const /** @type {?} */ position = Helpers.calcPositionOffset(this.position, element, this.side);
            if (position) {
                this.renderer.setStyle(element, 'top', position.top);
                this.renderer.setStyle(element, 'left', position.left);
                this.renderer.setStyle(element, 'width', position.width);
            }
        }
    }
    /**
     * @return {?}
     */
    handleScroll() {
        // On scroll, don't force the position to update (jump from top/middle/bottom/right)
        this.updatePosition(this.relativeElement, this.side);
    }
    /**
     * @param {?} appendToBody
     * @return {?}
     */
    show(appendToBody) {
        this.appendToBody = appendToBody;
        this.renderer.setStyle(this.element.nativeElement, 'display', 'block');
        this.renderer.setStyle(this.element.nativeElement, 'visibility', 'visible');
        this.isVisible = true;
        if (appendToBody) {
            window.addEventListener('scroll', this.scrollHandler);
        }
    }
    /**
     * @return {?}
     */
    hide() {
        this.isVisible = false;
        this.renderer.setStyle(this.element.nativeElement, 'visibility', 'hidden');
        if (this.appendToBody) {
            window.removeEventListener('scroll', this.scrollHandler);
        }
    }
    /**
     * @param {?} element
     * @param {?} side
     * @return {?}
     */
    updatePosition(element, side) {
        this.relativeElement = element;
        this.side = side;
        this.position = element.getBoundingClientRect();
        this.ngDoCheck();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onKeyDown(event) {
        // Close with ESC/Enter
        if (this.isVisible && (event.keyCode === KeyCodes.ESC || event.keyCode === KeyCodes.ENTER)) {
            //this.parent.toggleActive(null, false);
        }
    }
}
NovoPickerContainer.decorators = [
    { type: Component, args: [{
                selector: 'novo-picker-container',
                template: '<ng-content></ng-content>'
            },] },
];
/**
 * @nocollapse
 */
NovoPickerContainer.ctorParameters = () => [
    { type: ElementRef, },
    { type: Renderer2, },
];
NovoPickerContainer.propDecorators = {
    'onKeyDown': [{ type: HostListener, args: ['keydown', ['$event'],] },],
};

// NG2
// Vendor
// APP
class EntityPickerResult {
    /**
     * @param {?} labels
     */
    constructor(labels) {
        this.labels = labels;
    }
    /**
     * \@name escapeRegexp
     * \@description This function captures the whole query string and replace it with the string that will be used to
     * match.
     * @param {?} queryToEscape
     *
     * @return {?}
     */
    escapeRegexp(queryToEscape) {
        // Ex: if the capture is "a" the result will be \a
        return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
    }
    /**
     * \@name highlight
     * \@description This function should return a <strong>-tag wrapped HTML string.
     * @param {?} match
     * @param {?} query
     *
     * @return {?}
     */
    highlight(match, query) {
        // Replaces the capture string with a the same string inside of a "strong" tag
        return query && match ? match.replace(new RegExp(this.escapeRegexp(query), 'gi'), '<strong>$&</strong>') : match;
    }
    /**
     * @param {?=} result
     * @return {?}
     */
    getIconForResult(result) {
        if (result) {
            switch (result.searchEntity) {
                case 'ClientContact':
                    return 'person contact';
                case 'ClientCorporation':
                    return 'company';
                case 'Opportunity':
                    return 'opportunity';
                case 'Candidate':
                    return 'candidate';
                case 'Lead':
                    return 'lead';
                case 'JobOrder':
                    return 'job';
                case 'Placement':
                    return 'star placement';
                case 'CorporateUser':
                    return 'user';
                default:
                    return '';
            }
        }
        return '';
    }
    /**
     * @param {?=} date
     * @return {?}
     */
    renderTimestamp(date) {
        let /** @type {?} */ timestamp = '';
        if (date) {
            timestamp = this.labels.formatDateWithFormat(date, { year: 'numeric', month: 'numeric', day: 'numeric' });
        }
        return timestamp;
    }
    /**
     * @param {?=} result
     * @return {?}
     */
    getNameForResult(result) {
        if (result) {
            switch (result.searchEntity) {
                case 'Lead':
                case 'CorporateUser':
                case 'ClientContact':
                case 'Candidate':
                case 'Person':
                    if ('firstName' in result) {
                        return `${result.firstName} ${result.lastName}`.trim();
                    }
                    return `${result.name || ''}`.trim();
                case 'ClientCorporation':
                    return `${result.name || ''}`.trim();
                case 'Opportunity':
                case 'JobOrder':
                    return `${result.title || ''}`.trim();
                case 'Placement':
                    let /** @type {?} */ label = '';
                    if (result.candidate) {
                        label = `${result.candidate.firstName} ${result.candidate.lastName}`.trim();
                    }
                    if (result.jobOrder) {
                        label = `${label} - ${result.jobOrder.title}`.trim();
                    }
                    return label;
                default:
                    return `${result.name || ''}`.trim();
            }
        }
        return '';
    }
}
EntityPickerResult.decorators = [
    { type: Component, args: [{
                selector: 'entity-picker-result',
                template: `
        <novo-list-item *ngIf="match.data">
            <item-header>
                <item-avatar [icon]="getIconForResult(match.data)"></item-avatar>
                <item-title>
                    <span [innerHtml]="highlight(getNameForResult(match.data), term)"></span>
                </item-title>
            </item-header>
            <item-content direction="horizontal">
                <!-- COMPANY 1 -->
                <p class="company" *ngIf="match.data.companyName || match.data?.clientCorporation?.name">
                    <i class="bhi-company"></i>
                    <span [innerHtml]="highlight(match.data.companyName || match.data?.clientCorporation?.name, term)"></span>
                </p>
                <!-- CLIENT CONTACT -->
                <p class="contact" *ngIf="match.data?.clientContact?.firstName">
                    <i class="bhi-person contact person"></i>
                    <span [innerHtml]="highlight(match.data.clientContact.firstName + ' ' + match.data.clientContact.lastName, term)"></span>
                </p>
                <!-- CANDIDATE -->
                <p class="candidate" *ngIf="match.data.candidate && match.data.searchEntity === 'Placement'">
                    <i class="bhi-candidate"></i>
                    <span [innerHtml]="highlight((match.data.candidate.firstName + ' ' + match.data.candidate.lastName), term)"></span>
                </p>
                <!-- START & END DATE -->
                <p class="start-date" *ngIf="match.data.dateBegin && match.data.searchEntity === 'Placement'">
                    <i class="bhi-calendar"></i>
                    <span [innerHtml]="renderTimestamp(match.data.dateBegin) + ' - ' + renderTimestamp(match.data.dateEnd)"></span>
                </p>
                <!-- EMAIL -->
                <p class="email" *ngIf="match.data.email">
                    <i class="bhi-email"></i>
                    <span [innerHtml]="highlight(match.data.email, term)"></span>
                </p>
                <!-- PHONE -->
                <p class="phone" *ngIf="match.data.phone">
                    <i class="bhi-phone"></i>
                    <span [innerHtml]="highlight(match.data.phone, term)"></span>
                </p>
                <!-- ADDRESS -->
                <p class="location" *ngIf="match.data.address && (match.data.address.city || match.data.address.state)">
                    <i class="bhi-location"></i>
                    <span *ngIf="match.data.address.city" [innerHtml]="highlight(match.data.address.city, term)"></span>
                    <span *ngIf="match.data.address.city && match.data.address.state">, </span>
                    <span *ngIf="match.data.address.state" [innerHtml]="highlight(match.data.address.state, term)"></span>
                </p>
                <!-- STATUS -->
                <p class="status" *ngIf="match.data.status">
                    <i class="bhi-info"></i>
                    <span [innerHtml]="highlight(match.data.status, term)"></span>
                </p>
            </item-content>
        </novo-list-item>
    `
            },] },
];
/**
 * @nocollapse
 */
EntityPickerResult.ctorParameters = () => [
    { type: NovoLabelService, },
];
EntityPickerResult.propDecorators = {
    'match': [{ type: Input },],
    'term': [{ type: Input },],
};
class EntityPickerResults extends BasePickerResults {
    /**
     * @param {?} element
     * @param {?} labels
     * @param {?} ref
     */
    constructor(element, labels, ref) {
        super(element, ref);
        this.labels = labels;
        this.select = new EventEmitter();
    }
    /**
     * @return {?}
     */
    getListElement() {
        return this.element.nativeElement.querySelector('novo-list');
    }
    /**
     * @param {?=} event
     * @param {?=} item
     * @return {?}
     */
    selectMatch(event, item) {
        this.select.next(item);
        return super.selectMatch(event, item);
    }
}
EntityPickerResults.decorators = [
    { type: Component, args: [{
                selector: 'entity-picker-results',
                template: `
        <novo-list *ngIf="matches.length > 0" direction="vertical">
            <entity-picker-result *ngFor="let match of matches"
                    [match]="match"
                    [term]="term"
                    (click)="selectMatch($event, match)"
                    [ngClass]="{active: isActive(match)}"
                    (mouseenter)="selectActive(match)"
                    [class.disabled]="preselected(match)">
            </entity-picker-result>
            <novo-loading theme="line" *ngIf="isLoading && matches.length > 0"></novo-loading>
        </novo-list>
        <p class="picker-error" *ngIf="hasError">{{ labels.pickerError }}</p>
        <p class="picker-null-results" *ngIf="!isLoading && !matches.length && !hasError">{{ labels.pickerEmpty }}</p>
    `
            },] },
];
/**
 * @nocollapse
 */
EntityPickerResults.ctorParameters = () => [
    { type: ElementRef, },
    { type: NovoLabelService, },
    { type: ChangeDetectorRef, },
];
EntityPickerResults.propDecorators = {
    'select': [{ type: Output },],
};

// NG2
// APP
// Vendor
/**
 * \@name: ChecklistPickerResults
 *
 * \@description This is the actual list of matches that gets injected into the DOM.
 */
class ChecklistPickerResults extends BasePickerResults {
    /**
     * @param {?} element
     * @param {?} labels
     * @param {?} ref
     */
    constructor(element, labels, ref) {
        super(element, ref);
        this.labels = labels;
    }
    /**
     * @return {?}
     */
    search() {
        let /** @type {?} */ options = this.config.options;
        //only set this the first time
        return Observable$1.fromPromise(new Promise((resolve, reject) => {
            // Check if there is match data
            if (options) {
                // Resolve the data
                if (Array.isArray(options)) {
                    this.isStatic = true;
                    // Arrays are returned immediately
                    resolve(options);
                }
                else {
                    // All other kinds of data are rejected
                    reject('The data provided is not an array or a promise');
                    throw new Error('The data provided is not an array or a promise');
                }
            }
            else {
                // No data gets rejected
                reject('error');
            }
        }));
    }
    /**
     * \@name filterData=
     * \@description This function loops through the picker options and creates a filtered list of objects that contain
     * the newSearch.
     * @param {?} matches - Collection of objects=
     *
     * @return {?}
     */
    filterData(matches) {
        if (this.term && matches) {
            this.filteredMatches = matches.map(section => {
                let /** @type {?} */ items = section.originalData.filter((match) => {
                    return ~String(match.label).toLowerCase().indexOf(this.term.toLowerCase());
                });
                section.data = items;
                return section;
            }, this);
            return this.filteredMatches;
        }
        else if (this.term === '') {
            matches.forEach(section => {
                section.data = section.originalData;
            });
            return matches;
        }
        // Show no recent results template
        return matches;
    }
    /**
     * \@name selectMatch
     * \@description
     * @param {?} event
     * @param {?} item
     *
     * @return {?}
     */
    selectMatch(event, item) {
        Helpers.swallowEvent(event);
        if (item.indeterminate) {
            item.indeterminate = false;
            item.checked = true;
        }
        else {
            item.checked = !item.checked;
        }
        let /** @type {?} */ selected = this.activeMatch;
        if (selected) {
            this.parent.value = selected;
        }
        this.ref.markForCheck();
        return false;
    }
}
ChecklistPickerResults.decorators = [
    { type: Component, args: [{
                selector: 'checklist-picker-results',
                host: {
                    'class': 'active picker-results'
                },
                template: `
        <novo-loading theme="line" *ngIf="isLoading && !matches.length"></novo-loading>
        <ul *ngIf="matches.length > 0">
            <span *ngFor="let section of matches; let i = index">
                <li class="header caption" *ngIf="section.data.length > 0">{{ section.label || section.type }}</li>
                <li
                    *ngFor="let match of section.data; let i = index" [ngClass]="{checked: match.checked}"
                    (click)="selectMatch($event, match)"
                    [class.active]="match === activeMatch"
                    (mouseenter)="selectActive(match)">
                    <label>
                        <i [ngClass]="{'bhi-checkbox-empty': !match.checked, 'bhi-checkbox-filled': match.checked, 'bhi-checkbox-indeterminate': match.indeterminate }"></i>
                        {{match.label}}
                    </label>
                </li>
            </span>
        </ul>
        <p class="picker-error" *ngIf="hasError">{{ labels.pickerError }}</p>
        <p class="picker-null-results" *ngIf="!isLoading && !matches.length && !hasError">{{ labels.pickerEmpty }}</p>
    `
            },] },
];
/**
 * @nocollapse
 */
ChecklistPickerResults.ctorParameters = () => [
    { type: ElementRef, },
    { type: NovoLabelService, },
    { type: ChangeDetectorRef, },
];

class GroupedMultiPickerResults extends BasePickerResults {
    /**
     * @param {?} element
     * @param {?} renderer
     * @param {?} labels
     * @param {?} ref
     */
    constructor(element, renderer, labels, ref) {
        super(element, ref);
        this.renderer = renderer;
        this.labels = labels;
        this.customFilterEnabled = false;
        this.placeholder = '';
        this.internalMap = new Map();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set term(value) {
        // Display all only will work for static categories
        if (this.config.displayAll && this.config.getItemsForCategoryAsync) {
            throw new Error('[GroupedMultiPickerResults] - you can only have `displayAll` with a static `categoryMap`. Not available with `getItemsForCategoryAsync`');
        }
        // Custom filter
        if (this.config.customFilter) {
            this.customFilterEnabled = true;
            this.customFilterLabel = this.config.customFilter.label;
            this.customFilterValue = !!this.config.customFilter.defaultFilterValue;
            this.ref.markForCheck();
            if (!this.customFilterLabel || !this.config.customFilter.matchFunction) {
                throw new Error('[GroupedMultiPickerResults] - custom filter/matchFunction set no label was provided!');
            }
        }
        else {
            this.customFilterEnabled = false;
        }
        // Configure ALL
        if (this.config.displayAll && !this.selectedCategory) {
            this.setAllCategory();
        }
        // Placeholder
        if (this.config.placeholder) {
            this.placeholder = this.config.placeholder;
        }
        // Focus
        setTimeout(() => {
            this.inputElement.nativeElement.focus();
        });
    }
    /**
     * @return {?}
     */
    get categories() {
        if (this.config.categories || this.config.categoryMap) {
            return this.config.categories || Array.from(this.config.categoryMap.values()).filter((category) => {
                return category.value !== 'all';
            });
        }
        return [];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // Subscribe to keyboard events and debounce
        this.keyboardSubscription = Observable$1.fromEvent(this.inputElement.nativeElement, 'keyup')
            .debounceTime(350)
            .distinctUntilChanged()
            .subscribe((event) => {
            this.searchTerm = event.target['value'];
            this.matches = this.filterData();
            this.ref.markForCheck();
        });
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        // Cleanup
        this.keyboardSubscription.unsubscribe();
    }
    /**
     * @return {?}
     */
    setAllCategory() {
        // If we have display all, set the all categories up
        if (this.config.displayAll) {
            this.selectedCategory = { value: 'all', label: 'all' };
            let /** @type {?} */ allItems = [];
            Array.from(this.config.categoryMap.values())
                .filter((category) => {
                return category.value !== 'all';
            })
                .forEach((v) => allItems.push(...v.items));
            this.matches = this.filter(allItems);
            this.config.categoryMap.set('all', { value: 'all', label: 'All', items: allItems });
            this.ref.markForCheck();
        }
    }
    /**
     * @param {?} category
     * @return {?}
     */
    selectCategory(category) {
        // Scroll to top
        this.renderer.setProperty(this.listElement.element.nativeElement, 'scrollTop', 0);
        // Set focus
        this.inputElement.nativeElement.focus();
        // Find new items
        let /** @type {?} */ key = category.value;
        this.selectedCategory = category;
        // Clear
        this.matches = [];
        this.ref.markForCheck();
        // New matches
        this.getNewMatches(category, key);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    clearSearchTerm(event) {
        Helpers.swallowEvent(event);
        this.searchTerm = '';
        this.selectCategory({ value: this.selectedCategory.value, label: this.selectedCategory.label });
        this.ref.markForCheck();
    }
    /**
     * @param {?=} event
     * @param {?=} item
     * @return {?}
     */
    selectMatch(event, item) {
        // Set focus
        this.inputElement.nativeElement.focus();
        return super.selectMatch(event, item);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    fireCustomFilter(value) {
        this.customFilterValue = value;
        // Clear cache map
        this.internalMap.clear();
        // Only fire if we have a selected category
        if (this.selectCategory) {
            // Find new items
            let /** @type {?} */ key = this.selectedCategory.value;
            // Get new matches
            this.getNewMatches(this.selectedCategory, key);
            this.ref.markForCheck();
        }
        // Focus
        setTimeout(() => {
            this.inputElement.nativeElement.focus();
        });
    }
    /**
     * @return {?}
     */
    filterData() {
        if (this.selectedCategory) {
            if (this.config.categoryMap) {
                return this.filter(this.config.categoryMap.get(this.selectedCategory.value).items);
            }
            else {
                return this.filter(this.internalMap.get(this.selectedCategory.value).items);
            }
        }
        return [];
    }
    /**
     * @param {?} category
     * @param {?} key
     * @return {?}
     */
    getNewMatches(category, key) {
        // Get new matches
        if (this.config.categoryMap) {
            this.matches = this.filter(this.config.categoryMap.get(key).items);
            this.ref.markForCheck();
        }
        else {
            if (!this.config.getItemsForCategoryAsync) {
                throw new Error('The "config" for the Chips must include a function "getItemsForCategoryAsync(categoryKey: string)" to retrieve the items by category. Or if you have static data provide a "categoryMap"');
            }
            if (!this.internalMap.get(key)) {
                this.isLoading = true;
                this.config.getItemsForCategoryAsync(key, this.customFilterValue).then((items) => {
                    this.internalMap.set(key, { value: category.value, label: category.label, items: items });
                    this.matches = this.filter(items, true);
                    this.isLoading = false;
                    this.ref.markForCheck();
                    setTimeout(() => {
                        this.inputElement.nativeElement.focus();
                    });
                });
            }
            else {
                this.matches = this.filter(this.internalMap.get(key).items);
                this.ref.markForCheck();
            }
        }
    }
    /**
     * @param {?} array
     * @param {?=} ignoreCustomFilter
     * @return {?}
     */
    filter(array, ignoreCustomFilter = false) {
        let /** @type {?} */ matches = array;
        if (this.searchTerm && this.searchTerm.length !== 0 && this.selectedCategory) {
            matches = matches.filter((match) => {
                return ~String(match.label).toLowerCase().indexOf(this.searchTerm.toLowerCase());
            });
        }
        if (this.customFilterEnabled && this.config.customFilter.matchFunction && !ignoreCustomFilter) {
            matches = matches.filter((match) => {
                return this.config.customFilter.matchFunction(match, this.customFilterValue);
            });
        }
        return matches;
    }
}
GroupedMultiPickerResults.decorators = [
    { type: Component, args: [{
                selector: 'grouped-multi-picker-results',
                template: `
        <div class="grouped-multi-picker-groups">
            <novo-list direction="vertical">
                <novo-list-item
                    *ngIf="config.displayAll"
                    (click)="selectCategory({ value: 'all', label: 'all' })"
                    [class.active]="selectedCategory?.value === 'all'"
                    data-automation-id="display-all"
                    [class.disabled]="isLoading">
                    <item-content>
                        <span data-automation-id="label">{{ labels.all }}</span>
                    </item-content>
                    <item-end>
                        <i class="bhi-next"></i>
                    </item-end>
                </novo-list-item>
                <novo-list-item
                    *ngFor="let category of categories"
                    (click)="selectCategory(category)"
                    [class.active]="selectedCategory?.value === category.value"
                    [attr.data-automation-id]="category.label"
                    [class.disabled]="isLoading">
                    <item-content>
                        <span data-automation-id="label">{{ category.label }}</span>
                    </item-content>
                    <item-end>
                        <i class="bhi-next"></i>
                    </item-end>
                </novo-list-item>
            </novo-list>
            <footer class="grouped-multi-picker-groups-footer" *ngIf="customFilterEnabled" data-automation-id="footer" [class.disabled]="isLoading">
                <novo-switch [(ngModel)]="customFilterValue" (onChange)="fireCustomFilter($event)" data-automation-id="switch"></novo-switch>
                <label data-automation-id="label">{{ customFilterLabel }}</label>
            </footer>
        </div>
        <div class="grouped-multi-picker-matches">
            <div class="grouped-multi-picker-input-container" [hidden]="!selectedCategory" data-automation-id="input-container">
                <input autofocus #input [(ngModel)]="searchTerm" [disabled]="isLoading" data-automation-id="input" [placeholder]="placeholder"/>
                <i class="bhi-search" *ngIf="!searchTerm" [class.disabled]="isLoading" data-automation-id="seach-icon"></i>
                <i class="bhi-times" *ngIf="searchTerm" (click)="clearSearchTerm($event)" [class.disabled]="isLoading" data-automation-id="remove-icon"></i>
            </div>
            <div class="grouped-multi-picker-list-container">
                <novo-list direction="vertical" #list>
                    <novo-list-item
                        *ngFor="let match of matches"
                        (click)="selectMatch($event)"
                        [class.active]="match === activeMatch"
                        (mouseenter)="selectActive(match)"
                        [class.disabled]="preselected(match)"
                        [attr.data-automation-id]="match.label"
                        [class.disabled]="isLoading">
                        <item-content>
                            <span>{{ match.label }}</span>
                        </item-content>
                    </novo-list-item>
                </novo-list>
                <div class="grouped-multi-picker-no-results" *ngIf="matches.length === 0 && !isLoading && selectedCategory" data-automation-id="empty-message">
                    {{ labels.groupedMultiPickerEmpty }}
                </div>
                <div class="grouped-multi-picker-no-category" *ngIf="matches.length === 0 && !isLoading && !selectedCategory" data-automation-id="select-category-message">
                    {{ labels.groupedMultiPickerSelectCategory }}
                </div>
                <div class="grouped-multi-picker-loading" *ngIf="isLoading" data-automation-id="loading-message">
                    <novo-loading theme="line"></novo-loading>
                </div>
            </div>
        </div>
    `
            },] },
];
/**
 * @nocollapse
 */
GroupedMultiPickerResults.ctorParameters = () => [
    { type: ElementRef, },
    { type: Renderer2, },
    { type: NovoLabelService, },
    { type: ChangeDetectorRef, },
];
GroupedMultiPickerResults.propDecorators = {
    'inputElement': [{ type: ViewChild, args: ['input',] },],
    'listElement': [{ type: ViewChild, args: ['list',] },],
};

// NG2
// APP
class NovoPickerModule {
}
NovoPickerModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, FormsModule, NovoLoadingModule, NovoListModule, OverlayModule, NovoOverlayModule, NovoSwitchModule],
                declarations: [NovoPickerElement, NovoPickerContainer, PickerResults, EntityPickerResult, EntityPickerResults, ChecklistPickerResults, GroupedMultiPickerResults],
                exports: [NovoPickerElement, NovoPickerContainer, PickerResults, EntityPickerResult, EntityPickerResults, ChecklistPickerResults, GroupedMultiPickerResults],
                entryComponents: [PickerResults, EntityPickerResult, EntityPickerResults, ChecklistPickerResults, GroupedMultiPickerResults]
            },] },
];
/**
 * @nocollapse
 */
NovoPickerModule.ctorParameters = () => [];

// NG2
// APP
// Value accessor for the component (supports ngModel)
const SEARCH_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => NovoSearchBoxElement),
    multi: true
};
class NovoSearchBoxElement {
    /**
     * @param {?} element
     * @param {?} labels
     * @param {?} _changeDetectorRef
     * @param {?} _zone
     */
    constructor(element, labels, _changeDetectorRef, _zone) {
        this.element = element;
        this.labels = labels;
        this._changeDetectorRef = _changeDetectorRef;
        this._zone = _zone;
        this.icon = 'search';
        this.placeholder = 'Search...';
        this.alwaysOpen = false;
        this.theme = 'positive';
        this.closeOnSelect = true;
        this.searchChanged = new EventEmitter();
        this.focused = false;
        /**
         * View -> model callback called when value changes
         */
        this._onChange = () => { };
        /**
         * View -> model callback called when autocomplete has been touched
         */
        this._onTouched = () => { };
    }
    /**
     * \@name showFasterFind
     * \@description This function shows the picker and adds the active class (for animation)
     * @param {?=} event
     * @param {?=} forceClose
     * @return {?}
     */
    showSearch(event, forceClose = false) {
        if (!this.panelOpen) {
            // Reset search
            // Set focus on search
            setTimeout(() => {
                let /** @type {?} */ element = this.input.nativeElement;
                if (element) {
                    element.focus();
                }
            }, 10);
        }
    }
    /**
     * @return {?}
     */
    onFocus() {
        this._zone.run(() => {
            this.focused = true;
            this.openPanel();
        });
    }
    /**
     * @return {?}
     */
    onBlur() {
        this.focused = false;
    }
    /**
     * BEGIN: Convienient Panel Methods.
     * @return {?}
     */
    openPanel() {
        this.overlay.openPanel();
    }
    /**
     * @return {?}
     */
    closePanel() {
        this.overlay.closePanel();
    }
    /**
     * @return {?}
     */
    get panelOpen() {
        return this.overlay && this.overlay.panelOpen;
    }
    /**
     * @return {?}
     */
    get active() {
        return this.panelOpen || this.alwaysOpen;
    }
    /**
     * END: Convienient Panel Methods.
     * @param {?} event
     * @return {?}
     */
    _handleKeydown(event) {
        if ((event.keyCode === ESCAPE || event.keyCode === ENTER || event.keyCode === TAB) && this.panelOpen) {
            this.closePanel();
            event.stopPropagation();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    _handleInput(event) {
        if (document.activeElement === event.target) {
            this._onChange(((event.target)).value);
            if (this.debounceSearchChange) {
                clearTimeout(this.debounceSearchChange);
            }
            this.debounceSearchChange = setTimeout(() => {
                this.searchChanged.emit(((event.target)).value);
            }, 400);
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this._setValue(value);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this._onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    _setValue(value) {
        this.value = value;
        let /** @type {?} */ toDisplay = value;
        if (value && this.displayField) {
            toDisplay = value.hasOwnProperty(this.displayField) ? value[this.displayField] : value;
        }
        // Simply falling back to an empty string if the display value is falsy does not work properly.
        // The display value can also be the number zero and shouldn't fall back to an empty string.
        this.displayValue = toDisplay ? toDisplay : '';
        this.input.nativeElement.value = this.displayValue;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * This method closes the panel, and if a value is specified, also sets the associated
     * control to that value. It will also mark the control as dirty if this interaction
     * stemmed from the user.
     * @param {?} event
     * @return {?}
     */
    setValueAndClose(event) {
        if (event && event.value) {
            this._setValue(event.value);
            this._onChange(event.value);
        }
        this.closePanel();
    }
    /**
     * Clear any previous selected option and emit a selection change event for this option
     * @param {?} skip
     * @return {?}
     */
    clearValue(skip) {
        this.writeValue(null);
        this._onChange(null);
    }
}
NovoSearchBoxElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-search',
                providers: [SEARCH_VALUE_ACCESSOR],
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: `
        <!-- SEARCH ICON -->
        <button theme="fab" [color]="theme" [icon]="icon" (click)="showSearch()" [tooltip]="hint" tooltipPosition="bottom" data-automation-id="novo-search-fab"></button>
        <!-- SEARCH INPUT -->
        <input type="text" [attr.name]="name" [attr.value]="displayValue" [attr.placeholder]="placeholder" (focus)="onFocus()" (blur)="onBlur()" (keydown)="_handleKeydown($event)" (input)="_handleInput($event)" #input data-automation-id="novo-search-input"/>
        <!-- SEARCH OVERLAY -->
        <novo-overlay-template [parent]="element" [closeOnSelect]="closeOnSelect" (select)="closePanel()" (closing)="onBlur()">
            <ng-content></ng-content>
        </novo-overlay-template>
    `
            },] },
];
/**
 * @nocollapse
 */
NovoSearchBoxElement.ctorParameters = () => [
    { type: ElementRef, },
    { type: NovoLabelService, },
    { type: ChangeDetectorRef, },
    { type: NgZone, },
];
NovoSearchBoxElement.propDecorators = {
    'name': [{ type: Input },],
    'icon': [{ type: Input },],
    'placeholder': [{ type: Input },],
    'alwaysOpen': [{ type: Input },],
    'theme': [{ type: Input },],
    'closeOnSelect': [{ type: Input },],
    'displayField': [{ type: Input },],
    'displayValue': [{ type: Input },],
    'hint': [{ type: Input },],
    'searchChanged': [{ type: Output },],
    'focused': [{ type: HostBinding, args: ['class.focused',] },],
    'overlay': [{ type: ViewChild, args: [NovoOverlayTemplate,] },],
    'input': [{ type: ViewChild, args: ['input',] },],
    'active': [{ type: HostBinding, args: ['class.active',] },],
};

// NG2
// APP
class NovoSearchBoxModule {
}
NovoSearchBoxModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, NovoButtonModule, NovoPickerModule, NovoTooltipModule, OverlayModule, NovoOverlayModule],
                declarations: [NovoSearchBoxElement],
                exports: [NovoSearchBoxElement]
            },] },
];
/**
 * @nocollapse
 */
NovoSearchBoxModule.ctorParameters = () => [];

// NG2
// Vendor
const dragula$1 = dragulaImported;
class NovoDragulaService {
    constructor() {
        this.cancel = new EventEmitter();
        this.cloned = new EventEmitter();
        this.drag = new EventEmitter();
        this.dragend = new EventEmitter();
        this.drop = new EventEmitter();
        this.out = new EventEmitter();
        this.over = new EventEmitter();
        this.remove = new EventEmitter();
        this.shadow = new EventEmitter();
        this.dropModel = new EventEmitter();
        this.removeModel = new EventEmitter();
        this.events = [
            'cancel',
            'cloned',
            'drag',
            'dragend',
            'drop',
            'out',
            'over',
            'remove',
            'shadow',
            'dropModel',
            'removeModel'
        ];
        this.bags = [];
    }
    /**
     * \@name add
     * @param {?} name
     * @param {?} drake
     * @return {?}
     */
    add(name, drake) {
        let /** @type {?} */ bag = this.find(name);
        if (bag) {
            throw new Error(`Bag named: ${name} already exists.`);
        }
        bag = {
            name: name,
            drake: drake
        };
        this.bags.push(bag);
        if (drake.models) {
            this.handleModels(name, drake);
        }
        if (!bag.initEvents) {
            this.setupEvents(bag);
        }
        return bag;
    }
    /**
     * \@name find
     * @param {?} name
     * @return {?}
     */
    find(name) {
        for (let /** @type {?} */ i = 0; i < this.bags.length; i++) {
            if (this.bags[i].name === name) {
                return this.bags[i];
            }
        }
        return null;
    }
    /**
     * \@name destroy
     * @param {?} name
     * @return {?}
     */
    destroy(name) {
        let /** @type {?} */ bag = this.find(name);
        let /** @type {?} */ i = this.bags.indexOf(bag);
        this.bags.splice(i, 1);
        bag.drake.destroy();
    }
    /**
     * \@name setOptions
     * @param {?} name
     * @param {?} options
     * @return {?}
     */
    setOptions(name, options) {
        let /** @type {?} */ bag = this.add(name, dragula$1(options));
        this.handleModels(name, bag.drake);
    }
    /**
     * \@name handleModels
     * @param {?} name
     * @param {?} drake
     * @return {?}
     */
    handleModels(name, drake) {
        let /** @type {?} */ dragElm;
        let /** @type {?} */ dragIndex;
        let /** @type {?} */ dropIndex;
        let /** @type {?} */ sourceModel;
        drake.on('remove', (el, source) => {
            if (!drake.models) {
                return;
            }
            sourceModel = drake.models[drake.containers.indexOf(source)];
            sourceModel.splice(dragIndex, 1);
            this.removeModel.emit([name, el, source]);
        });
        drake.on('drag', (el, source) => {
            dragElm = el;
            dragIndex = this.domIndexOf(el, source);
        });
        drake.on('drop', (dropElm, target, source) => {
            if (!drake.models) {
                return;
            }
            dropIndex = this.domIndexOf(dropElm, target);
            sourceModel = drake.models[drake.containers.indexOf(source)];
            if (target === source) {
                sourceModel.splice(dropIndex, 0, sourceModel.splice(dragIndex, 1)[0]);
            }
            else {
                let /** @type {?} */ notCopy = dragElm === dropElm;
                let /** @type {?} */ targetModel = drake.models[drake.containers.indexOf(target)];
                let /** @type {?} */ dropElmModel = notCopy ? sourceModel[dragIndex] : JSON.parse(JSON.stringify(sourceModel[dragIndex]));
                if (notCopy) {
                    sourceModel.splice(dragIndex, 1);
                }
                targetModel.splice(dropIndex, 0, dropElmModel);
                target.removeChild(dropElm); // element must be removed for ngFor to apply correctly
            }
            this.dropModel.emit([name, dropElm, target, source]);
        });
    }
    /**
     * \@name setupEvents
     * @param {?} bag
     * @return {?}
     */
    setupEvents(bag) {
        bag.initEvents = true;
        let /** @type {?} */ that = this;
        let /** @type {?} */ emitter = (type) => {
            /**
             * @return {?}
             */
            function replicate() {
                let /** @type {?} */ args = Array.prototype.slice.call(arguments);
                that[type].emit([bag.name].concat(args));
            }
            bag.drake.on(type, replicate);
        };
        this.events.forEach(emitter);
    }
    /**
     * \@name domIndexOf
     * @param {?} child
     * @param {?} parent
     * @return {?}
     */
    domIndexOf(child, parent) {
        return Array.prototype.indexOf.call(parent.children, child);
    }
}
NovoDragulaService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
NovoDragulaService.ctorParameters = () => [];

// NG2
// Vendor
const dragula = dragulaImported;
// APP
class NovoDragulaElement {
    /**
     * @param {?} element
     * @param {?} dragulaService
     */
    constructor(element, dragulaService) {
        this.dragulaService = dragulaService;
        this.drake = null;
        this.container = element.nativeElement;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        let /** @type {?} */ bag = this.dragulaService.find(this.bag);
        if (bag) {
            this.drake = bag.drake;
            this.checkModel();
            this.drake.containers.push(this.container);
        }
        else {
            this.drake = dragula({
                containers: [this.container]
            });
            this.checkModel();
            this.dragulaService.add(this.bag, this.drake);
        }
    }
    /**
     * @return {?}
     */
    checkModel() {
        if (this.dragulaModel) {
            if (this.drake.models) {
                this.drake.models.push(this.dragulaModel);
            }
            else {
                this.drake.models = [this.dragulaModel];
            }
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes && changes.dragulaModel) {
            if (this.drake) {
                if (this.drake.models) {
                    let /** @type {?} */ modelIndex = this.drake.models.indexOf(changes.dragulaModel.previousValue);
                    this.drake.models.splice(modelIndex, 1, changes.dragulaModel.currentValue);
                }
                else {
                    this.drake.models = [changes.dragulaModel.currentValue];
                }
            }
        }
    }
}
NovoDragulaElement.decorators = [
    { type: Directive, args: [{
                selector: '[dragula]'
            },] },
];
/**
 * @nocollapse
 */
NovoDragulaElement.ctorParameters = () => [
    { type: ElementRef, },
    { type: NovoDragulaService, },
];
NovoDragulaElement.propDecorators = {
    'bag': [{ type: Input, args: ['dragula',] },],
    'dragulaModel': [{ type: Input },],
};

// NG2
// APP
class NovoDragulaModule {
}
NovoDragulaModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NovoDragulaElement],
                exports: [NovoDragulaElement]
            },] },
];
/**
 * @nocollapse
 */
NovoDragulaModule.ctorParameters = () => [];

// NG2
// APP
class NovoSliderElement {
    /**
     * @param {?} element
     * @param {?} labels
     */
    constructor(element, labels) {
        this.element = element;
        this.labels = labels;
        this.currentSlide = 0;
        this.start = true;
        this.end = true;
        this.currSlides = ['active'];
        this.handleKeyDownFunc = this.handleKeyDown.bind(this);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        for (let /** @type {?} */ i = 0; i < this.slides; i++) {
            this.currSlides[i] = (i > 0) ? 'inactive' : 'active';
        }
        // Catch Tab Events
        this.element.nativeElement.addEventListener('keydown', this.handleKeyDownFunc);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.element.nativeElement.removeEventListener('keydown', this.handleKeyDownFunc);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    handleKeyDown(event) {
        if (event.keyCode === 9) {
            event.stopImmediatePropagation();
            event.preventDefault();
        }
    }
    /**
     * @param {?} direction
     * @return {?}
     */
    changeSlide(direction) {
        if (direction === 'next') {
            if (this.currentSlide === this.slides - 1) {
                return;
            }
            this.currentSlide++;
        }
        else {
            if (this.currentSlide === 0) {
                return;
            }
            this.currentSlide--;
        }
        for (let /** @type {?} */ i = 0; i < this.slides; i++) {
            this.currSlides[i] = 'inactive';
        }
        this.currSlides[this.currentSlide] = 'active';
        this.start = (this.currentSlide === 0);
        this.end = (this.currentSlide === this.slides - 1);
        this.currentClass = `slide-${this.currentSlide}`;
    }
}
NovoSliderElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-slider',
                template: `
        <section class="slides">
            <ng-content select="div[slide]"></ng-content>
        </section>
        <div class="controls">
            <button *ngIf="!start" theme="icon" icon="previous" (click)="changeSlide('back')"></button>
            <div class="indicators">
                <div class="indicator-circle" *ngFor="let indicator of currSlides; let i = index" [ngClass]="indicator"></div>
            </div>
            <button *ngIf="!end" theme="primary" icon="next" (click)="changeSlide('next')">{{ labels.next }}</button>
            <ng-content select="button" *ngIf="end"></ng-content>
        </div>
    `,
                host: {
                    '[class]': 'currentClass'
                }
            },] },
];
/**
 * @nocollapse
 */
NovoSliderElement.ctorParameters = () => [
    { type: ElementRef, },
    { type: NovoLabelService, },
];
NovoSliderElement.propDecorators = {
    'slides': [{ type: Input },],
};

// NG2
// APP
class NovoSliderModule {
}
NovoSliderModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, NovoButtonModule],
                declarations: [NovoSliderElement],
                exports: [NovoSliderElement]
            },] },
];
/**
 * @nocollapse
 */
NovoSliderModule.ctorParameters = () => [];

// NG2
// Vendor
// Value accessor for the component (supports ngModel)
const CHIPS_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => NovoChipsElement),
    multi: true
};
class NovoChipElement {
    constructor() {
        this.select = new EventEmitter();
        this.remove = new EventEmitter();
    }
    /**
     * @param {?} type
     * @return {?}
     */
    set type(type) {
        this._type = type ? type.toLowerCase() : null;
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onRemove(e) {
        if (e) {
            e.stopPropagation();
            e.preventDefault();
        }
        this.remove.emit(e);
        return false;
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onSelect(e) {
        if (e) {
            e.stopPropagation();
            e.preventDefault();
        }
        this.select.emit(e);
        return false;
    }
}
NovoChipElement.decorators = [
    { type: Component, args: [{
                selector: 'chip,novo-chip',
                template: `
        <span (click)="onSelect($event)" (mouseover)="onSelect($event)" [ngClass]="_type">
            <i *ngIf="_type" class="bhi-circle"></i>
            <span><ng-content></ng-content></span>
        </span>
        <i class="bhi-close" (click)="onRemove($event)"></i>
    `
            },] },
];
/**
 * @nocollapse
 */
NovoChipElement.ctorParameters = () => [];
NovoChipElement.propDecorators = {
    'type': [{ type: Input },],
    'select': [{ type: Output },],
    'remove': [{ type: Output },],
};
class NovoChipsElement {
    /**
     * @param {?} element
     * @param {?} componentUtils
     * @param {?} labels
     */
    constructor(element, componentUtils, labels) {
        this.element = element;
        this.componentUtils = componentUtils;
        this.labels = labels;
        this.closeOnSelect = false;
        this.placeholder = '';
        this._disablePickerInput = false;
        this.changed = new EventEmitter();
        this.focus = new EventEmitter();
        this.blur = new EventEmitter();
        this.typing = new EventEmitter();
        this.items = [];
        this.selected = null;
        this.config = {};
        // private data model
        this._value = '';
        this._items = new ReplaySubject$1(1);
        // Placeholders for the callbacks
        this.onModelChange = () => {
        };
        this.onModelTouched = () => {
        };
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set disablePickerInput(v) {
        this._disablePickerInput = coerceBooleanProperty(v);
    }
    /**
     * @return {?}
     */
    get disablePickerInput() {
        return this._disablePickerInput;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.setItems();
    }
    /**
     * @return {?}
     */
    get value() {
        return this._value;
    }
    /**
     * @param {?} selected
     * @return {?}
     */
    set value(selected) {
        this.itemToAdd = '';
        if (selected !== this._value) {
            this._value = selected;
            this.changed.emit({ value: selected, rawValue: this.items });
            this.onModelChange(selected);
        }
    }
    /**
     * @return {?}
     */
    clearValue() {
        this.items = [];
        this._items.next(this.items);
        this.value = null;
        this.changed.emit({ value: this.value, rawValue: this.items });
        this.onModelChange(this.value);
    }
    /**
     * @return {?}
     */
    setItems() {
        this.items = [];
        if (this.model && Array.isArray(this.model)) {
            let /** @type {?} */ noLabels = [];
            for (let /** @type {?} */ value of this.model) {
                let /** @type {?} */ label;
                if (this.source && this.source.format && Helpers.validateInterpolationProps(this.source.format, value)) {
                    label = Helpers.interpolate(this.source.format, value);
                }
                if (this.source && label && label !== this.source.format) {
                    this.items.push({
                        value,
                        label
                    });
                }
                else if (this.source.getLabels && typeof this.source.getLabels === 'function') {
                    noLabels.push(value);
                }
                else if (this.source.options && Array.isArray(this.source.options)) {
                    this.items.push(this.getLabelFromOptions(value));
                }
                else {
                    this.items.push({
                        value,
                        label: value
                    });
                }
            }
            if (noLabels.length > 0 && this.source && this.source.getLabels && typeof this.source.getLabels === 'function') {
                this.source.getLabels(noLabels).then(result => {
                    for (let /** @type {?} */ value of result) {
                        if (value.hasOwnProperty('label')) {
                            this.items.push({
                                value,
                                label: value.label
                            });
                        }
                        else if (this.source.options && Array.isArray(this.source.options)) {
                            this.items.push(this.getLabelFromOptions(value));
                        }
                        else {
                            this.items.push(value);
                        }
                    }
                    this._items.next(this.items);
                });
            }
        }
        this.changed.emit({ value: this.model, rawValue: this.items });
        this._items.next(this.items);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    getLabelFromOptions(value) {
        let /** @type {?} */ optLabel = this.source.options.find(val => val.value === value);
        return {
            value,
            label: optLabel ? optLabel.label : value
        };
    }
    /**
     * @param {?=} event
     * @return {?}
     */
    deselectAll(event) {
        this.selected = null;
        this.hidePreview();
    }
    /**
     * @param {?=} event
     * @param {?=} item
     * @return {?}
     */
    select(event, item) {
        this.blur.emit(event);
        this.deselectAll();
        this.selected = item;
        this.showPreview();
    }
    /**
     * @param {?=} event
     * @return {?}
     */
    onTyping(event) {
        this.typing.emit(event);
    }
    /**
     * @param {?=} event
     * @return {?}
     */
    onFocus(event) {
        this.deselectAll();
        this.element.nativeElement.classList.add('selected');
        this.focus.emit(event);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    add(event) {
        if (event && !(event instanceof Event)) {
            this.items.push(event);
            this.value = this.items.map(i => i.value);
            // Set focus on the picker
            let /** @type {?} */ input = this.element.nativeElement.querySelector('novo-picker > input');
            if (input) {
                input.focus();
            }
        }
        this._items.next(this.items);
    }
    /**
     * @param {?} event
     * @param {?} item
     * @return {?}
     */
    remove(event, item) {
        if (event) {
            event.stopPropagation();
            event.preventDefault();
        }
        this.items.splice(this.items.indexOf(item), 1);
        this.deselectAll();
        this.value = this.items.map(i => i.value);
        this.changed.emit({ value: this.value.length ? this.value : '', rawValue: this.items });
        this.onModelChange(this.value.length ? this.value : '');
        this._items.next(this.items);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onKeyDown(event) {
        if (event.keyCode === KeyCodes.BACKSPACE) {
            if (event.target && event.target.value.length === 0 && this.items.length) {
                if (event) {
                    event.stopPropagation();
                    event.preventDefault();
                }
                if (this.selected) {
                    this.remove(event, this.selected);
                }
                else {
                    this.select(event, this.items[this.items.length - 1]);
                }
            }
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onTouched(e) {
        this.element.nativeElement.classList.remove('selected');
        this.onModelTouched();
        this.blur.emit(e);
    }
    /**
     * @param {?} model
     * @return {?}
     */
    writeValue(model) {
        this.model = model;
        this.setItems();
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onModelChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onModelTouched = fn;
    }
    /**
     * \@name showPreview
     *
     * \@description This method creates an instance of the preview (called popup) and adds all the bindings to that
     * instance. Will reuse the popup or create a new one if it does not already exist. Will only work if there is
     * a previewTemplate given in the config.
     * @return {?}
     */
    showPreview() {
        if (this.source.previewTemplate) {
            if (!this.popup) {
                this.popup = this.componentUtils.appendNextToLocation(this.source.previewTemplate, this.preview);
            }
            this.popup.instance.match = this.selected;
        }
    }
    /**
     * \@name hidePreview
     *
     * \@description - This method deletes the preview popup from the DOM.
     * @return {?}
     */
    hidePreview() {
        if (this.popup) {
            this.popup.destroy();
            this.popup = null;
        }
    }
}
NovoChipsElement.decorators = [
    { type: Component, args: [{
                selector: 'chips,novo-chips',
                providers: [CHIPS_VALUE_ACCESSOR],
                template: `
        <chip
            *ngFor="let item of _items | async"
            [type]="type || item?.value?.searchEntity"
            [class.selected]="item == selected"
            (remove)="remove($event, item)"
            (select)="select($event, item)">
            {{ item.label }}
        </chip>
        <div class="chip-input-container">
            <novo-picker
                clearValueOnSelect="true"
                [closeOnSelect]="closeOnSelect"
                [config]="source"
                [disablePickerInput]="disablePickerInput"
                [placeholder]="placeholder"
                [(ngModel)]="itemToAdd"
                (select)="add($event)"
                (keydown)="onKeyDown($event)"
                (focus)="onFocus($event)"
                (typing)="onTyping($event)"
                (blur)="onTouched($event)"
                [selected]="items"
                [overrideElement]="element">
            </novo-picker>
        </div>
        <div class="preview-container">
            <span #preview></span>
        </div>
        <i class="bhi-search" [class.has-value]="items.length"></i>
        <label class="clear-all" *ngIf="items.length" (click)="clearValue()">{{ labels.clearAll }} <i class="bhi-times"></i></label>
   `,
                host: {
                    '[class.with-value]': 'items.length > 0'
                }
            },] },
];
/**
 * @nocollapse
 */
NovoChipsElement.ctorParameters = () => [
    { type: ElementRef, },
    { type: ComponentUtils, },
    { type: NovoLabelService, },
];
NovoChipsElement.propDecorators = {
    'closeOnSelect': [{ type: Input },],
    'placeholder': [{ type: Input },],
    'source': [{ type: Input },],
    'type': [{ type: Input },],
    'disablePickerInput': [{ type: Input },],
    'changed': [{ type: Output },],
    'focus': [{ type: Output },],
    'blur': [{ type: Output },],
    'typing': [{ type: Output },],
    'preview': [{ type: ViewChild, args: ['preview', { read: ViewContainerRef },] },],
    'value': [{ type: Input },],
};

// NG2
// APP
class NovoChipsModule {
}
NovoChipsModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, FormsModule, NovoPickerModule],
                declarations: [NovoChipElement, NovoChipsElement],
                exports: [NovoChipElement, NovoChipsElement]
            },] },
];
/**
 * @nocollapse
 */
NovoChipsModule.ctorParameters = () => [];

// NG2
// Vendor
// APP
// Value accessor for the component (supports ngModel)
const DATE_PICKER_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => NovoDatePickerElement),
    multi: true
};

class NovoDatePickerElement {
    /**
     * @param {?} labels
     * @param {?} element
     */
    constructor(labels, element) {
        this.labels = labels;
        this.element = element;
        this.weekStart = 0;
        // Select callback for output
        this.onSelect = new EventEmitter(false);
        // List of all the weekdays
        this.weekdays = [];
        // List of all months
        this.months = [];
        // List of all years (generated in ngOnInit)
        this.years = [];
        // Default view mode (select days)
        this.view = 'days';
        this.rangeSelectMode = 'startDate';
        this.onModelChange = () => { };
        this.onModelTouched = () => { };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // Determine the year array
        let /** @type {?} */ now = new Date();
        let /** @type {?} */ start = this.minYear ? Number(this.minYear) : now.getFullYear() - 100;
        let /** @type {?} */ end = this.maxYear ? Number(this.maxYear) : now.getFullYear() + 10;
        for (let /** @type {?} */ i = start; i <= end; i++) {
            this.years.push(i);
        }
        // Set weekdays / months
        this.weekdays = this.setupWeekdays();
        this.months = this.labels.getMonths();
        // Set labels
        this.selectedLabel = this.labels.startDate;
        this.selected2Label = this.labels.endDate;
        this.updateView(this.model, false, true);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        let /** @type {?} */ weekRangeSelectChange = changes['weekRangeSelect'];
        if (weekRangeSelectChange && weekRangeSelectChange.currentValue !== weekRangeSelectChange.previousValue && !weekRangeSelectChange.firstChange) {
            this.clearRange();
        }
        let /** @type {?} */ weekStartChanges = changes['weekStart'];
        if (weekStartChanges && weekStartChanges.currentValue !== weekStartChanges.previousValue && !weekStartChanges.firstChange) {
            this.weekdays = this.setupWeekdays();
            this.updateView(this.model, false, false);
        }
    }
    /**
     * @return {?}
     */
    setupWeekdays() {
        let /** @type {?} */ weekdays = this.labels.getWeekdays();
        // Weekstart must be 0-6 (Sunday - Saturday)
        if (!Helpers.isBlank(this.weekStart) && this.weekStart > 0 && this.weekStart <= 6) {
            let /** @type {?} */ newStart = weekdays.splice(this.weekStart);
            weekdays = [...newStart, ...weekdays];
        }
        return weekdays;
    }
    /**
     * @param {?} range
     * @param {?} day
     * @param {?} selected
     * @param {?} selected2
     * @param {?} hoverDay
     * @param {?} rangeSelectMode
     * @param {?} weekRangeSelect
     * @return {?}
     */
    isSelectingRange(range, day, selected, selected2, hoverDay, rangeSelectMode, weekRangeSelect) {
        if (range && !weekRangeSelect) {
            let /** @type {?} */ isRangeModeEndDate = rangeSelectMode === 'endDate' && (selected && selected2 && isAfter(day, selected2) && isBefore(day, hoverDay));
            let /** @type {?} */ isRangeModeStartDate = rangeSelectMode === 'startDate' && (selected && selected2 && isBefore(day, selected) && isAfter(day, hoverDay));
            let /** @type {?} */ isNotSelected = !selected && selected2 && isBefore(day, selected2) && isAfter(day, hoverDay);
            let /** @type {?} */ isNotSelected2 = selected && !selected2 && isAfter(day, selected) && isBefore(day, hoverDay);
            return isNotSelected2 || isNotSelected || isRangeModeStartDate || isRangeModeEndDate;
        }
        return false;
    }
    /**
     * @param {?} range
     * @param {?} day
     * @param {?} selected
     * @param {?} selected2
     * @return {?}
     */
    isEndFill(range, day, selected, selected2) {
        if (range && selected2 && selected) {
            return !isSameDay(selected, selected2) && isSameDay(day, selected2) && isAfter(day, selected);
        }
        return false;
    }
    /**
     * @param {?} range
     * @param {?} day
     * @param {?} selected
     * @param {?} selected2
     * @return {?}
     */
    isStartFill(range, day, selected, selected2) {
        if (range && selected2 && selected) {
            return !isSameDay(selected, selected2) && isSameDay(day, selected) && isBefore(day, selected2);
        }
        return false;
    }
    /**
     * @param {?} range
     * @param {?} day
     * @param {?} selected
     * @param {?} selected2
     * @return {?}
     */
    isFiller(range, day, selected, selected2) {
        if (range && selected2 && selected) {
            return (isAfter(day, selected) && isBefore(day, selected2)) || isSameDay(day, selected) || isSameDay(day, selected2);
        }
        return false;
    }
    /**
     * @param {?} range
     * @param {?} day
     * @param {?} selected
     * @param {?} selected2
     * @return {?}
     */
    isSelected(range, day, selected, selected2) {
        if (range) {
            return day && (selected && (day.getDate() === selected.getDate() && day.getMonth() === selected.getMonth() && day.getFullYear() === selected.getFullYear()) || (selected2 && (day.getDate() === selected2.getDate() && day.getMonth() === selected2.getMonth() && day.getFullYear() === selected2.getFullYear())));
        }
        return day.getDate() === selected.getDate() && day.getMonth() === selected.getMonth() && day.getFullYear() === selected.getFullYear();
    }
    /**
     * @param {?} day
     * @param {?} start
     * @param {?} end
     * @return {?}
     */
    isDisabled(day, start, end) {
        return isBefore(day, start) || isAfter(day, end);
    }
    /**
     * @param {?} date
     * @param {?} fireEvents
     * @param {?} markedSelected
     * @return {?}
     */
    updateView(date, fireEvents, markedSelected) {
        if (date && date.startDate === null) {
            this.clearRange();
        }
        else {
            if (!date) {
                this.clearRange();
            }
            let /** @type {?} */ value = date ? new Date(date) : new Date();
            value = this.removeTime(value);
            this.month = new Date(value);
            this.monthLabel = this.labels.formatDateWithFormat(this.month, { month: 'short' });
            let /** @type {?} */ start = new Date(value.getTime());
            start.setDate(1);
            this.removeTime(start.setDate(1));
            this.buildMonth(start, this.month);
            if (markedSelected) {
                this.select(null, { date: value }, fireEvents);
            }
        }
    }
    /**
     * @return {?}
     */
    setToday() {
        let /** @type {?} */ tmp = new Date();
        this.updateView(tmp, true, true);
        // Go back to days
        this.open(null, 'days');
    }
    /**
     * @return {?}
     */
    clearRange() {
        this.selected = null;
        this.selectedLabel = this.labels.startDate;
        this.selected2 = null;
        this.selected2Label = this.labels.endDate;
    }
    /**
     * @param {?} month
     * @return {?}
     */
    setMonth(month) {
        let /** @type {?} */ date = this.month ? this.month : new Date();
        let /** @type {?} */ tmp = setMonth(date, month);
        this.updateView(tmp, true, false);
        // Go back to days
        this.open(null, 'days');
    }
    /**
     * @param {?} year
     * @return {?}
     */
    setYear(year) {
        let /** @type {?} */ date = this.month ? this.month : new Date();
        let /** @type {?} */ tmp = setYear(date, year);
        this.updateView(tmp, true, false);
        // Go back to days
        this.open(null, 'days');
    }
    /**
     * @param {?} event
     * @param {?} day
     * @param {?} fireEvents
     * @return {?}
     */
    select(event, day, fireEvents) {
        Helpers.swallowEvent(event);
        if (this.range) {
            if (this.weekRangeSelect) {
                this.selected = startOfWeek(day.date, { weekStartsOn: this.weekStart });
                this.selected2 = endOfWeek(day.date, { weekStartsOn: this.weekStart });
                this.selectedLabel = this.labels.formatDateWithFormat(this.selected, {
                    month: 'short',
                    day: '2-digit',
                    year: 'numeric'
                });
                this.selected2Label = this.labels.formatDateWithFormat(this.selected2, {
                    month: 'short',
                    day: '2-digit',
                    year: 'numeric'
                });
                // Make sure to fire this, since we default to the current week selected!
                if (!fireEvents && this.weekRangeSelect) {
                    this.fireRangeSelect();
                }
            }
            else if (this.rangeSelectMode === 'startDate') {
                // SET START DATE
                this.selected = startOfDay(day.date);
                this.selectedLabel = this.labels.formatDateWithFormat(this.selected, {
                    month: 'short',
                    day: '2-digit',
                    year: 'numeric'
                });
                if (this.selected2 && isAfter(day.date, this.selected2)) {
                    // CLEAR END DATE
                    this.selected2 = null;
                    this.selected2Label = this.labels.endDate;
                }
                if (event) {
                    this.rangeSelectMode = 'endDate';
                }
            }
            else if (this.rangeSelectMode === 'endDate') {
                // SET END DATE
                this.selected2 = endOfDay(day.date);
                this.selected2Label = this.labels.formatDateWithFormat(this.selected2, {
                    month: 'short',
                    day: '2-digit',
                    year: 'numeric'
                });
                if (this.selected && isBefore(day.date, this.selected)) {
                    // CLEAR START DATE
                    this.selected = null;
                    this.selectedLabel = this.labels.startDate;
                }
                if (event) {
                    this.rangeSelectMode = 'startDate';
                }
            }
        }
        else {
            this.selected = day.date;
            this.selectedLabel = this.labels.formatDateWithFormat(this.selected, {
                month: 'short',
                day: '2-digit',
                year: 'numeric'
            });
            this.updateHeading();
        }
        if (fireEvents && this.selected) {
            // Emit our output
            if (this.range && this.selected && this.selected2) {
                this.fireRangeSelect();
                // Also, update the ngModel
                this.onModelChange({
                    startDate: this.selected,
                    endDate: this.selected2 ? this.selected2 : null
                });
                this.model = {
                    startDate: this.selected,
                    endDate: this.selected2 ? this.selected2 : null
                };
            }
            if (!this.range) {
                this.onSelect.next({
                    month: this.labels.formatDateWithFormat(this.selected, { month: 'long' }),
                    year: this.selected.getFullYear(),
                    day: this.labels.formatDateWithFormat(this.selected, { weekday: 'long' }),
                    date: this.selected
                });
                // Also, update the ngModel
                this.onModelChange(this.selected);
                this.model = this.selected;
            }
        }
    }
    /**
     * @return {?}
     */
    fireRangeSelect() {
        // Make sure the start date is before the end date
        if (isBefore(this.selected, this.selected2)) {
            this.onSelect.next({
                startDate: {
                    month: this.labels.formatDateWithFormat(this.selected, { month: 'long' }),
                    year: this.selected.getFullYear(),
                    day: this.labels.formatDateWithFormat(this.selected, { weekday: 'long' }),
                    date: this.selected
                },
                endDate: {
                    month: this.labels.formatDateWithFormat(this.selected2, { month: 'long' }),
                    year: this.selected2.getFullYear(),
                    day: this.labels.formatDateWithFormat(this.selected2, { weekday: 'long' }),
                    date: this.selected2
                }
            });
        }
    }
    /**
     * @param {?} event
     * @param {?} type
     * @return {?}
     */
    open(event, type) {
        Helpers.swallowEvent(event);
        // If they click the toggle two time in a row, close it (go back to days)
        if (type === this.view) {
            this.view = 'days';
        }
        else {
            this.view = type;
        }
        // Make sure to scroll the selected one into view
        if (this.view === 'years' || this.view === 'months') {
            setTimeout(() => {
                let /** @type {?} */ container = this.element.nativeElement.querySelector(`.calendar-content.${this.view}`);
                let /** @type {?} */ selectedItem = this.element.nativeElement.querySelector(`.calendar-content.${this.view} .${this.view === 'years' ? 'year' : 'month'}.selected`);
                if (container && selectedItem) {
                    container.scrollTop = selectedItem.offsetTop - 100;
                }
            });
        }
        this.updateHeading();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    prevMonth(event) {
        Helpers.swallowEvent(event);
        let /** @type {?} */ tmp = subMonths(this.month, 1);
        this.updateView(tmp, false, false);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    nextMonth(event) {
        Helpers.swallowEvent(event);
        let /** @type {?} */ tmp = addMonths(this.month, 1);
        this.updateView(tmp, false, false);
    }
    /**
     * @return {?}
     */
    updateHeading() {
        if (!this.selected) {
            return;
        }
        this.heading = {
            month: this.labels.formatDateWithFormat(this.selected, { month: 'long' }),
            year: this.selected.getFullYear(),
            day: this.labels.formatDateWithFormat(this.selected, { weekday: 'long' }),
            date: this.selected.getDate()
        };
    }
    /**
     * Remove the time aspect of the date
     * @param {?} date
     * @return {?} with time stripped out
     */
    removeTime(date) {
        let /** @type {?} */ ret = new Date(date);
        ret.setHours(12);
        ret.setSeconds(0);
        ret.setMilliseconds(0);
        return ret;
    }
    /**
     * @param {?} start
     * @param {?} month
     * @return {?}
     */
    buildMonth(start, month) {
        // Reset the weeks
        this.weeks = [];
        // House keeping variables to know when we are done building the month
        let /** @type {?} */ done = false, /** @type {?} */ date = startOfWeek(start, { weekStartsOn: this.weekStart }), /** @type {?} */ monthIndex = date.getMonth(), /** @type {?} */ count = 0;
        while (!done) {
            // Build the days for the weeks
            this.weeks.push({ days: this.buildWeek(new Date(date.getTime()), month) });
            // Increment variables for the next iteration
            date = addDays(date, 7);
            done = count++ > 2 && monthIndex !== date.getMonth();
            monthIndex = date.getMonth();
        }
    }
    /**
     * @param {?} date
     * @param {?} month
     * @return {?}
     */
    buildWeek(date, month) {
        // Build out of the days of the week
        let /** @type {?} */ days = [];
        // Iterate over the days of the week
        for (let /** @type {?} */ i = 0; i < 7; i++) {
            // Push a variable on the day array with lots of helpers to make the template easier
            days.push({
                name: this.weekdays[i],
                number: date.getDate(),
                isToday: isToday(date),
                date: date
            });
            // Increment for the next iteration
            date = addDays(date, 1);
        }
        return days;
    }
    /**
     * @param {?} range
     * @return {?}
     */
    toggleRangeSelect(range) {
        this.rangeSelectMode = range;
    }
    /**
     * @param {?} event
     * @param {?} day
     * @return {?}
     */
    rangeHover(event, day) {
        this.hoverDay = day.date;
    }
    /**
     * @param {?} model
     * @return {?}
     */
    writeValue(model) {
        this.model = model;
        if (Helpers.isDate(model)) {
            this.updateView(model, false, true);
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onModelChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onModelTouched = fn;
    }
}
NovoDatePickerElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-date-picker',
                providers: [DATE_PICKER_VALUE_ACCESSOR],
                animations: [
                    trigger$1('startDateTextState', [
                        state$1('startDate', style$1({
                            'opacity': '1.0'
                        })),
                        state$1('endDate', style$1({
                            'opacity': '0.6'
                        })),
                        transition$1('startDate <=> endDate', animate$1('200ms ease-in'))
                    ]),
                    trigger$1('endDateTextState', [
                        state$1('startDate', style$1({
                            'opacity': '0.6'
                        })),
                        state$1('endDate', style$1({
                            'opacity': '1.0'
                        })),
                        transition$1('startDate <=> endDate', animate$1('200ms ease-in'))
                    ]),
                    trigger$1('indicatorState', [
                        state$1('startDate', style$1({
                            'transform': 'translateX(0%)'
                        })),
                        state$1('endDate', style$1({
                            'transform': 'translateX(100%)'
                        })),
                        transition$1('startDate <=> endDate', animate$1('200ms ease-in'))
                    ])
                ],
                template: `
        <div class="calendar">
            <div class="calendar-top" *ngIf="!inline && !range">
                <h4 class="day" [attr.data-automation-id]="heading?.day">{{heading?.day}}</h4>
                <h2 class="month" [attr.data-automation-id]="heading?.month">{{heading?.month}}</h2>
                <h1 class="date" [attr.data-automation-id]="heading?.date">{{heading?.date}}</h1>
                <h3 class="year" [attr.data-automation-id]="heading?.year">{{heading?.year}}</h3>
            </div>
            <div class="date-range-tabs" *ngIf="range" [class.week-select-mode]="weekRangeSelect">
                <span class="range-tab" (click)="toggleRangeSelect('startDate')" [@startDateTextState]="rangeSelectMode" data-automation-id="calendar-start-date">{{selectedLabel}}</span>
                <span class="range-tab" (click)="toggleRangeSelect('endDate')" [@endDateTextState]="rangeSelectMode" data-automation-id="calendar-end-date">{{selected2Label}}</span>
                <i class="indicator" [@indicatorState]="rangeSelectMode"></i>
            </div>
            <div class="calendar-header">
                <span class="previous" (click)="prevMonth($event)" data-automation-id="calendar-previous"></span>
                <span class="heading">
                    <span class="month" (click)="open($event, 'months')" data-automation-id="header-month">{{monthLabel}}</span>
                    <span class="year" (click)="open($event, 'years')" data-automation-id="header-year">{{month?.getFullYear()}}</span>
                </span>
                <span class="next" (click)="nextMonth($event)" data-automation-id="calendar-next"></span>
            </div>
            <table class="calendar-content days" cellspacing="0" cellpadding="0" [hidden]="!(view=='days')">
                <thead>
                    <tr>
                        <th *ngFor="let day of weekdays" title="{{day}}" class="weekday" [attr.data-automation-id]="day.substr(0, 2)">{{day.substr(0, 2)}}</th>
                    </tr>
                </thead>
                <tbody>
                    <tr *ngFor="let week of weeks">
                        <td *ngFor="let day of week.days" [ngClass]="{
                            today: day.isToday,
                            'notinmonth': day.date.getMonth() !== this.month.getMonth(),
                            selected: isSelected(range, day.date, selected, selected2),
                            filler: isFiller(range, day.date, selected, selected2),
                            startfill: isStartFill(range, day.date, selected, selected2),
                            endfill: isEndFill(range, day.date, selected, selected2),
                            'selecting-range': isSelectingRange(range, day.date, selected, selected2, hoverDay, rangeSelectMode, weekRangeSelect)
                           }" (click)="select($event, day, true)" (mouseover)="rangeHover($event, day)" [attr.data-automation-id]="day.number">
                            <button class="day" [attr.data-automation-id]="day.number" [disabled]="isDisabled(day.date, start, end)">{{day.number}}</button>
                        </td>
                    </tr>
                </tbody>
            </table>
            <section class="calendar-content months" [hidden]="view !== 'months'">
                <div *ngFor="let month of months;let i = index" (click)="setMonth(i)">
                    <div class="month" [ngClass]="{selected: i === selected?.getMonth()}" [attr.data-automation-id]="month">{{month}}</div>
                </div>
            </section>
            <section class="calendar-content years" [hidden]="view !== 'years'">
                <div *ngFor="let year of years" (click)="setYear(year)">
                    <div class="year" [ngClass]="{selected: year == selected?.getFullYear()}" [attr.data-automation-id]="year">{{year}}</div>
                </div>
            </section>
            <div class="calendar-footer">
                <span (click)="setToday()" class="today" data-automation-id="calendar-today">{{ labels.today }}</span>
            </div>
        </div>
    `
            },] },
];
/**
 * @nocollapse
 */
NovoDatePickerElement.ctorParameters = () => [
    { type: NovoLabelService, },
    { type: ElementRef, },
];
NovoDatePickerElement.propDecorators = {
    'minYear': [{ type: Input },],
    'maxYear': [{ type: Input },],
    'start': [{ type: Input },],
    'end': [{ type: Input },],
    'inline': [{ type: Input },],
    'range': [{ type: Input },],
    'weekRangeSelect': [{ type: Input },],
    'weekStart': [{ type: Input },],
    'onSelect': [{ type: Output },],
    'template': [{ type: ViewChild, args: [TemplateRef,] },],
};

// NG2
// APP
class DateFormatService {
    /**
     * @param {?} labels
     */
    constructor(labels) {
        this.labels = labels;
    }
    /**
     * @param {?} militaryTime
     * @return {?}
     */
    getTimeMask(militaryTime) {
        let /** @type {?} */ mask = [/\d/, /\d/, /:/, /\d/, /\d/], /** @type {?} */ timeFormatArray = [];
        let /** @type {?} */ timeFormat = this.labels.timeFormatPlaceholderAM.toLowerCase();
        if (militaryTime) {
            return mask;
        }
        else {
            timeFormatArray = timeFormat.split('hh:mm');
            if (timeFormatArray && timeFormatArray.length) {
                mask = [];
                for (let /** @type {?} */ timeFormatPart of timeFormatArray) {
                    if (timeFormatPart === '') {
                        mask = mask.concat([/\d/, /\d|:/, /:|\d/, /\d|\w|\s/, /\d|\s|\w/]);
                    }
                    else if (timeFormatPart.length) {
                        for (let /** @type {?} */ i = 0; i < timeFormatPart.length; i++) {
                            mask.push(/\s|\w|\d|\./);
                        }
                    }
                }
            }
        }
        return mask;
    }
    /**
     * @return {?}
     */
    getDateMask() {
        return [/\d/, /\d|\/|\.|\-/, /\/|\.|\-|\d/, /\d|\/|\.|\-/, /\d|\/|\.|\-/, /\d|\/|\.|\-/, /\d|\/|\.|\-/, /\d|\/|\.|\-/, /\d/, /\d/];
    }
    /**
     * @param {?} militaryTime
     * @return {?}
     */
    getTimePlaceHolder(militaryTime) {
        if (militaryTime) {
            return this.labels.timeFormatPlaceholder24Hour;
        }
        return this.labels.timeFormatPlaceholderAM;
    }
    /**
     * @param {?} dateString
     * @return {?}
     */
    parseDateString(dateString) {
        let /** @type {?} */ dateFormat = this.labels.dateFormat, /** @type {?} */ dateFormatRegex = /(\w+)[\/|\.|\-](\w+)[\/|\.|\-](\w+)/gi, /** @type {?} */ dateValueRegex = /(\d+)[\/|\.|\-](\d+)[\/|\.|\-](\d+)/gi, /** @type {?} */ dateFormatTokens, /** @type {?} */ dateValueTokens, /** @type {?} */ year, /** @type {?} */ month, /** @type {?} */ day, /** @type {?} */ date = new Date();
        if (Helpers.isEmpty(dateFormat)) {
            // Default to MM/dd/yyyy
            dateFormat = 'mm/dd/yyyy';
        }
        else {
            dateFormat = dateFormat.toLowerCase();
        }
        dateFormatTokens = dateFormatRegex.exec(dateFormat);
        dateValueTokens = dateValueRegex.exec(dateString);
        if (dateFormatTokens && dateFormatTokens.length === 4 && dateValueTokens && dateValueTokens.length === 4) {
            for (let /** @type {?} */ i = 1; i < 4; i++) {
                if (dateFormatTokens[i].includes('m')) {
                    month = parseInt(dateValueTokens[i]) - 1;
                }
                else if (dateFormatTokens[i].includes('d')) {
                    day = parseInt(dateValueTokens[i]);
                }
                else {
                    year = parseInt(dateValueTokens[i]);
                }
            }
            if (month >= 0 && month <= 11 && year > 1900 && day > 0 && day <= 31) {
                date = new Date(year, month, day);
            }
        }
        else if (dateFormatTokens && dateFormatTokens.length === 4 && dateString.length >= 1) {
            let /** @type {?} */ twoTokens = /\d{1,4}(\/|\.|\-)(\d{1,2})/.exec(dateString);
            let /** @type {?} */ oneToken = /^(\d{1,4})$/.exec(dateString);
            let /** @type {?} */ delimiter = /\w+(\/|\.|\-)\w+[\/|\.|\-]\w+/gi.exec(dateFormat);
            let /** @type {?} */ dateStringWithDelimiter = dateString[dateString.length - 1].match(/\/|\.|\-/);
            if (twoTokens && twoTokens.length === 3 && this.isValidDatePart(twoTokens[2], dateFormatTokens[2]) && !dateStringWithDelimiter) {
                dateString = `${dateString}${delimiter[1]}`;
            }
            else if (oneToken && oneToken.length === 2 && this.isValidDatePart(oneToken[1], dateFormatTokens[1]) && !dateStringWithDelimiter) {
                dateString = `${dateString}${delimiter[1]}`;
            }
        }
        return [date, dateString];
    }
    /**
     * @param {?} timeString
     * @param {?} militaryTime
     * @return {?}
     */
    parseTimeString(timeString, militaryTime) {
        let /** @type {?} */ value = new Date(), /** @type {?} */ timeStringParts;
        let /** @type {?} */ amFormat = this.labels.timeFormatAM;
        let /** @type {?} */ pmFormat = this.labels.timeFormatPM;
        if (!(timeString && timeString.includes(':'))) {
            return [value, timeString];
        }
        if (!militaryTime && amFormat && pmFormat) {
            let /** @type {?} */ splits = [], /** @type {?} */ pm = false;
            amFormat = this.labels.timeFormatAM.toLowerCase();
            pmFormat = this.labels.timeFormatPM.toLowerCase();
            timeString = timeString.toLowerCase();
            if (timeString.includes(amFormat)) {
                splits = timeString.split(amFormat);
            }
            else if (timeString.includes(pmFormat)) {
                splits = timeString.split(pmFormat);
                pm = true;
            }
            if (splits && splits.length) {
                for (let /** @type {?} */ item of splits) {
                    if (item && item.trim().includes(':')) {
                        timeStringParts = item.trim().split(':');
                    }
                }
            }
            if (timeStringParts && timeStringParts.length && timeStringParts.length === 2) {
                let /** @type {?} */ hours = parseInt(timeStringParts[0]);
                if (hours === 12 && pm) {
                    hours = 12;
                }
                else if (pm) {
                    hours = hours + 12;
                }
                else if (hours === 12) {
                    hours = 0;
                }
                value.setHours(hours);
                value.setMinutes(parseInt(timeStringParts[1]));
                value.setSeconds(0);
            }
        }
        else {
            timeStringParts = /(\d{1,2}):(\d{2})/.exec(timeString);
            if (timeStringParts && timeStringParts.length && timeStringParts.length === 3) {
                value.setHours(parseInt(timeStringParts[1]));
                value.setMinutes(parseInt(timeStringParts[2]));
                value.setSeconds(0);
            }
        }
        return [value, timeString];
    }
    /**
     * @param {?} dateTimeString
     * @param {?} militaryTime
     * @param {?} type
     * @return {?}
     */
    parseString(dateTimeString, militaryTime, type) {
        switch (type) {
            case 'date':
                return this.parseDateString(dateTimeString);
            case 'time':
                return this.parseTimeString(dateTimeString, militaryTime);
            default:
                return;
        }
    }
    /**
     * @param {?} value
     * @param {?} format
     * @return {?}
     */
    isValidDatePart(value, format) {
        let /** @type {?} */ datePart = parseInt(value);
        if (format.includes('m') && (datePart >= 2 || value.length === 2)) {
            return true;
        }
        else if (format.includes('d') && (datePart >= 4 || value.length === 2)) {
            return true;
        }
        else if (format.includes('y') && datePart >= 1000) {
            return true;
        }
        return false;
    }
}
DateFormatService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
DateFormatService.ctorParameters = () => [
    { type: NovoLabelService, },
];

// NG
// Value accessor for the component (supports ngModel)
const DATE_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => NovoDatePickerInputElement),
    multi: true
};
class NovoDatePickerInputElement {
    /**
     * @param {?} element
     * @param {?} labels
     * @param {?} dateFormatService
     * @param {?} _changeDetectorRef
     */
    constructor(element, labels, dateFormatService, _changeDetectorRef) {
        this.element = element;
        this.labels = labels;
        this.dateFormatService = dateFormatService;
        this._changeDetectorRef = _changeDetectorRef;
        /**
         * View -> model callback called when value changes
         */
        this._onChange = () => { };
        /**
         * View -> model callback called when autocomplete has been touched
         */
        this._onTouched = () => { };
        this.maskOptions = {
            mask: this.dateFormatService.getDateMask(),
            keepCharPositions: true,
            guide: false
        };
        this.placeholder = this.labels.dateFormatPlaceholder;
    }
    /**
     * BEGIN: Convienient Panel Methods.
     * @return {?}
     */
    openPanel() {
        this.overlay.openPanel();
    }
    /**
     * @return {?}
     */
    closePanel() {
        this.overlay.closePanel();
    }
    /**
     * @return {?}
     */
    get panelOpen() {
        return this.overlay && this.overlay.panelOpen;
    }
    /**
     * END: Convienient Panel Methods.
     * @param {?} event
     * @return {?}
     */
    _handleKeydown(event) {
        if ((event.keyCode === ESCAPE || event.keyCode === ENTER || event.keyCode === TAB) && this.panelOpen) {
            this.closePanel();
            event.stopPropagation();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    _handleInput(event) {
        if (document.activeElement === event.target) {
            this._onChange(((event.target)).value);
            let [dateTimeValue, formatted] = this.dateFormatService.parseString(((event.target)).value, false, 'date');
            if (dateTimeValue && dateTimeValue.getTime() > 0) {
                this._setTriggerValue(dateTimeValue);
            }
            this.openPanel();
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        Promise.resolve(null).then(() => this._setTriggerValue(value));
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this._onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    _setTriggerValue(value) {
        const /** @type {?} */ toDisplay = value;
        // Simply falling back to an empty string if the display value is falsy does not work properly.
        // The display value can also be the number zero and shouldn't fall back to an empty string.
        const /** @type {?} */ inputValue = toDisplay !== null ? toDisplay : '';
        this.value = inputValue;
        this.formattedValue = this.formatDateValue(inputValue);
        this._changeDetectorRef.markForCheck();
    }
    /**
     * This method closes the panel, and if a value is specified, also sets the associated
     * control to that value. It will also mark the control as dirty if this interaction
     * stemmed from the user.
     * @param {?} event
     * @return {?}
     */
    setValueAndClose(event) {
        if (event && event.date) {
            this._setTriggerValue(event.date);
            this._onChange(event.date);
        }
        this.closePanel();
    }
    /**
     * Clear any previous selected option and emit a selection change event for this option
     * @param {?} skip
     * @return {?}
     */
    clearValue(skip) {
        this.writeValue(null);
        this._onChange(null);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    formatDateValue(value) {
        if (!value) {
            return '';
        }
        return this.labels.formatDateWithFormat(value, {
            month: 'numeric',
            day: 'numeric',
            year: 'numeric'
        });
    }
    /**
     * @return {?}
     */
    get hasValue() {
        return !Helpers.isEmpty(this.value);
    }
}
NovoDatePickerInputElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-date-picker-input',
                providers: [DATE_VALUE_ACCESSOR],
                template: `
        <input type="text" [name]="name" [value]="formattedValue" [textMask]="maskOptions" [placeholder]="placeholder" (focus)="openPanel()" (keydown)="_handleKeydown($event)" (input)="_handleInput($event)" #input/>
        <i *ngIf="!hasValue" (click)="openPanel()" class="bhi-calendar"></i>
        <i *ngIf="hasValue" (click)="clearValue()" class="bhi-times"></i>

        <novo-overlay-template [parent]="element">
            <novo-date-picker inline="true" (onSelect)="setValueAndClose($event)" [ngModel]="value"></novo-date-picker>
        </novo-overlay-template>
  `
            },] },
];
/**
 * @nocollapse
 */
NovoDatePickerInputElement.ctorParameters = () => [
    { type: ElementRef, },
    { type: NovoLabelService, },
    { type: DateFormatService, },
    { type: ChangeDetectorRef, },
];
NovoDatePickerInputElement.propDecorators = {
    'name': [{ type: Input },],
    'placeholder': [{ type: Input },],
    'maskOptions': [{ type: Input },],
    'overlay': [{ type: ViewChild, args: [NovoOverlayTemplate,] },],
};

// NG2
// Vendor
// APP
class NovoDatePickerModule {
}
NovoDatePickerModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, FormsModule, NovoOverlayModule, TextMaskModule],
                declarations: [NovoDatePickerElement, NovoDatePickerInputElement],
                exports: [NovoDatePickerElement, NovoDatePickerInputElement]
            },] },
];
/**
 * @nocollapse
 */
NovoDatePickerModule.ctorParameters = () => [];

// NG2
// APP
// Value accessor for the component (supports ngModel)
const TIME_PICKER_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => NovoTimePickerElement),
    multi: true
};
class NovoTimePickerElement {
    constructor() {
        this.military = false;
        this.inline = false;
        this.onSelect = new EventEmitter();
        this.hours = 12;
        this.minutes = 0;
        this.value = null;
        this.MERIDIANS = ['am', 'pm'];
        this.MINUTES = ['05', '10', '15', '20', '25', '30', '35', '40', '45', '50', '55', '00'];
        this.HOURS = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'];
        this.onModelChange = () => {
        };
        this.onModelTouched = () => {
        };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.military) {
            this.HOURS = ['0', ...this.HOURS, '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23'];
        }
        this.ngOnChanges();
    }
    /**
     * @param {?=} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (this.model) {
            this.init(this.model, false);
        }
        else {
            this.init(new Date(), false);
        }
    }
    /**
     * @param {?} value
     * @param {?} dispatch
     * @return {?}
     */
    init(value, dispatch) {
        let /** @type {?} */ _value = new Date(value);
        let /** @type {?} */ hours = _value.getHours();
        let /** @type {?} */ minutes = _value.getMinutes();
        if (!this.military) {
            this.meridian = hours >= 12 ? 'pm' : 'am';
            hours = hours % 12;
            hours = hours || 12;
        }
        minutes = minutes < 10 ? `0${minutes}` : minutes;
        this.setHours(null, hours, dispatch);
        this.setMinutes(null, minutes, dispatch);
        this.checkBetween(minutes);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    checkBetween(value) {
        this.inBetween = this.MINUTES.indexOf(String(value)) < 0;
    }
    /**
     * @param {?} event
     * @param {?} hours
     * @param {?} dispatch
     * @return {?}
     */
    setHours(event, hours, dispatch) {
        Helpers.swallowEvent(event);
        this.hours = hours;
        this.hoursClass = `hour-${hours}`;
        this.activeHour = hours;
        if (dispatch) {
            this.dispatchChange();
        }
    }
    /**
     * @param {?} event
     * @param {?} minutes
     * @param {?} dispatch
     * @return {?}
     */
    setMinutes(event, minutes, dispatch) {
        Helpers.swallowEvent(event);
        this.minutes = minutes;
        this.minutesClass = `min-${minutes}`;
        this.activeMinute = minutes;
        this.checkBetween(minutes);
        if (dispatch) {
            this.dispatchChange();
        }
    }
    /**
     * @param {?} event
     * @param {?} period
     * @param {?} dispatch
     * @return {?}
     */
    setPeriod(event, period, dispatch) {
        Helpers.swallowEvent(event);
        this.meridian = period;
        if (dispatch) {
            this.dispatchChange();
        }
    }
    /**
     * @return {?}
     */
    dispatchChange() {
        let /** @type {?} */ hours = Number(this.hours);
        if (!this.military) {
            hours = this.meridian === 'pm' ? hours + 12 : hours;
            // Special case for 12
            if (this.meridian === 'pm' && hours === 24) {
                hours = 12;
            }
            else if (this.meridian === 'am' && hours === 12) {
                hours = 0;
            }
        }
        let /** @type {?} */ value = new Date();
        value.setHours(hours);
        value.setMinutes(this.minutes);
        value.setSeconds(0);
        this.onSelect.next({
            hours: hours,
            minutes: this.minutes,
            meridian: this.meridian,
            date: value,
            text: `${this.hours}:${this.minutes} ${this.meridian}`
        });
        this.onModelChange(value);
    }
    /**
     * @param {?} model
     * @return {?}
     */
    writeValue(model) {
        this.model = model;
        if (Helpers.isDate(model)) {
            this.init(model, false);
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onModelChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onModelTouched = fn;
    }
}
NovoTimePickerElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-time-picker',
                providers: [TIME_PICKER_VALUE_ACCESSOR],
                template: `
        <div class="digital" [class.inline]="inline" [class.military]="military">
            <div class="digital--inner">
                <span class="digital--clock" *ngIf="!inline">
                    <span class="hours" data-automation-id="novo-time-picker-hours">{{hours}}</span>:<span class="minutes" data-automation-id="novo-time-picker-minutes">{{minutes}}</span>
                </span>
                <div class="control-block" *ngIf="!military">
                    <span *ngFor="let period of MERIDIANS" class="digital--period" [class.active]="meridian==period" (click)="setPeriod($event, period, true)" [attr.data-automation-id]="period">{{period}}</span>
                </div>
            </div>
        </div>
        <div class="analog">
            <div class="analog--inner">
                <div class="analog--face">
                    <span class="analog--center"></span>
                    <span class="analog--hand--hours" [ngClass]="hoursClass">
                        <span class="analog--ball"></span>
                    </span>
                    <span class="analog--hand--minutes" [ngClass]="minutesClass">
                        <span class="analog--ball" [ngClass]="{between: inBetween}"></span>
                    </span>
                </div>
                <div class="analog--hours">
                    <span *ngFor="let hour of HOURS" class="analog--hour" [ngClass]="{active: activeHour == hour}" (click)="setHours($event, hour, true)" [attr.data-automation-id]="hour">{{hour}}</span>
                </div>
                <div class="analog--minutes">
                    <span *ngFor="let minute of MINUTES" class="analog--minute" [ngClass]="{active: activeMinute == minute}" (click)="setMinutes($event, minute, true)" [attr.data-automation-id]="minute">{{minute}}</span>
                </div>
            </div>
        </div>
    `,
                host: {
                    '[class.military]': 'military'
                }
            },] },
];
/**
 * @nocollapse
 */
NovoTimePickerElement.ctorParameters = () => [];
NovoTimePickerElement.propDecorators = {
    'military': [{ type: Input },],
    'inline': [{ type: Input },],
    'onSelect': [{ type: Output },],
};

// NG
// App
// Value accessor for the component (supports ngModel)
const DATE_VALUE_ACCESSOR$1 = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => NovoTimePickerInputElement),
    multi: true
};
class NovoTimePickerInputElement {
    /**
     * @param {?} element
     * @param {?} labels
     * @param {?} dateFormatService
     * @param {?} _changeDetectorRef
     */
    constructor(element, labels, dateFormatService, _changeDetectorRef) {
        this.element = element;
        this.labels = labels;
        this.dateFormatService = dateFormatService;
        this._changeDetectorRef = _changeDetectorRef;
        /**
         * View -> model callback called when value changes
         */
        this._onChange = () => { };
        /**
         * View -> model callback called when autocomplete has been touched
         */
        this._onTouched = () => { };
        this.military = false;
        this.maskOptions = {
            mask: this.dateFormatService.getTimeMask(this.military),
            keepCharPositions: true,
            guide: false
        };
        this.placeholder = this.labels.dateFormatPlaceholder;
    }
    /**
     * BEGIN: Convienient Panel Methods.
     * @return {?}
     */
    openPanel() {
        this.overlay.openPanel();
    }
    /**
     * @return {?}
     */
    closePanel() {
        this.overlay.closePanel();
    }
    /**
     * @return {?}
     */
    get panelOpen() {
        return this.overlay && this.overlay.panelOpen;
    }
    /**
     * END: Convienient Panel Methods.
     * @param {?} event
     * @return {?}
     */
    _handleKeydown(event) {
        if ((event.keyCode === ESCAPE || event.keyCode === ENTER || event.keyCode === TAB) && this.panelOpen) {
            this.closePanel();
            event.stopPropagation();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    _handleInput(event) {
        if (document.activeElement === event.target) {
            this._onChange(((event.target)).value);
            let [dateTimeValue, formatted] = this.dateFormatService.parseString(((event.target)).value, this.military, 'time');
            if (dateTimeValue && dateTimeValue.getTime() > 0) {
                this._setTriggerValue(dateTimeValue);
            }
            this.openPanel();
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        Promise.resolve(null).then(() => this._setTriggerValue(value));
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this._onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    _setTriggerValue(value) {
        const /** @type {?} */ toDisplay = value;
        // Simply falling back to an empty string if the display value is falsy does not work properly.
        // The display value can also be the number zero and shouldn't fall back to an empty string.
        const /** @type {?} */ inputValue = toDisplay !== null ? toDisplay : '';
        // If it's used within a `MdFormField`, we should set it through the property so it can go
        // through change detection.
        //this._element.nativeElement.value = inputValue;
        this.value = inputValue;
        this.formattedValue = this.formatDateValue(inputValue);
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    setValue(event) {
        if (event && event.date) {
            this._setTriggerValue(event.date);
            this._onChange(event.date);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    setValueAndClose(event) {
        this.setValue(event);
        this.closePanel();
    }
    /**
     * Clear any previous selected option and emit a selection change event for this option
     * @param {?} skip
     * @return {?}
     */
    clearValue(skip) {
        this.writeValue(null);
        this._onChange(null);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    formatDateValue(value) {
        if (!value) {
            return '';
        }
        return this.labels.formatDateWithFormat(value, {
            hour: 'numeric',
            minute: 'numeric'
        });
    }
    /**
     * @return {?}
     */
    get hasValue() {
        return !Helpers.isEmpty(this.value);
    }
}
NovoTimePickerInputElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-time-picker-input',
                providers: [DATE_VALUE_ACCESSOR$1],
                template: `
        <input type="text" [name]="name" [value]="formattedValue" [textMask]="maskOptions" [placeholder]="placeholder" (focus)="openPanel()" (keydown)="_handleKeydown($event)" (input)="_handleInput($event)" #input/>
        <i *ngIf="!hasValue" (click)="openPanel()" class="bhi-clock"></i>
        <i *ngIf="hasValue" (click)="clearValue()" class="bhi-times"></i>

        <novo-overlay-template [parent]="element">
            <novo-time-picker inline="true" (onSelect)="setValue($event)" [ngModel]="value"></novo-time-picker>
        </novo-overlay-template>
  `
            },] },
];
/**
 * @nocollapse
 */
NovoTimePickerInputElement.ctorParameters = () => [
    { type: ElementRef, },
    { type: NovoLabelService, },
    { type: DateFormatService, },
    { type: ChangeDetectorRef, },
];
NovoTimePickerInputElement.propDecorators = {
    'name': [{ type: Input },],
    'placeholder': [{ type: Input },],
    'military': [{ type: Input },],
    'maskOptions': [{ type: Input },],
    'overlay': [{ type: ViewChild, args: [NovoOverlayTemplate,] },],
};

// NG2
// Vendor
// APP
class NovoTimePickerModule {
}
NovoTimePickerModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, FormsModule, TextMaskModule, NovoOverlayModule],
                declarations: [NovoTimePickerElement, NovoTimePickerInputElement],
                exports: [NovoTimePickerElement, NovoTimePickerInputElement]
            },] },
];
/**
 * @nocollapse
 */
NovoTimePickerModule.ctorParameters = () => [];

// NG2
// Vendor
// APP
// Value accessor for the component (supports ngModel)
const DATE_TIME_PICKER_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => NovoDateTimePickerElement),
    multi: true
};
class NovoDateTimePickerElement {
    /**
     * @param {?} labels
     * @param {?} element
     */
    constructor(labels, element) {
        this.labels = labels;
        this.element = element;
        // Select callback for output
        this.onSelect = new EventEmitter(false);
        this.componentTabState = 'date';
        this.datePickerValue = new Date();
        this.timePickerValue = new Date();
        this.onModelChange = () => { };
        this.onModelTouched = () => { };
    }
    /**
     * @param {?} tab
     * @return {?}
     */
    toggleView(tab) {
        this.componentTabState = tab;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setDateLabels(value) {
        this.selectedLabel = this.labels.formatDateWithFormat(value, {
            month: 'short',
            day: '2-digit',
            year: 'numeric'
        });
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setTimeLabels(value) {
        let /** @type {?} */ hours = value.getHours();
        let /** @type {?} */ minutes = value.getMinutes();
        this.meridian = value.toLocaleTimeString().slice(-2);
        if (!this.military) {
            hours = this.meridian === 'PM' && hours > 12 ? hours - 12 : hours;
            // Special case for 12
            if (this.meridian === 'PM' && hours === 24) {
                hours = 12;
            }
            else if (this.meridian === 'AM' && hours === 0) {
                hours = 12;
            }
        }
        this.hours = hours.toString().length === 1 ? `0${hours.toString()}` : hours.toString();
        this.minutes = minutes.toString().length === 1 ? `0${minutes.toString()}` : minutes.toString();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onDateSelected(event) {
        this.datePickerValue = event.date;
        this.model = this.createFullDateValue(this.datePickerValue, this.timePickerValue);
        this.setDateLabels(this.model);
        this.onModelChange(this.model);
        this.onSelect.emit({ date: this.model });
        this.toggleView('time');
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onTimeSelected(event) {
        this.timePickerValue = event.date;
        this.model = this.createFullDateValue(this.datePickerValue, this.timePickerValue);
        this.setTimeLabels(this.model);
        this.onModelChange(this.model);
        this.onSelect.emit({ date: this.model });
    }
    /**
     * @param {?} datePickerValue
     * @param {?} timePickerValue
     * @return {?}
     */
    createFullDateValue(datePickerValue, timePickerValue) {
        return setMilliseconds(setSeconds(setMinutes(setHours(datePickerValue, getHours(timePickerValue)), getMinutes(timePickerValue)), getSeconds(timePickerValue)), getMilliseconds(timePickerValue));
    }
    /**
     * @param {?} model
     * @return {?}
     */
    writeValue(model) {
        this.model = model;
        if (Helpers.isEmpty(model)) {
            this.model = new Date();
        }
        else if (!isNaN(model)) {
            this.model = new Date(model);
        }
        this.datePickerValue = this.model;
        this.timePickerValue = this.model;
        if (Helpers.isDate(this.model)) {
            this.setDateLabels(this.model);
            this.setTimeLabels(this.model);
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onModelChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onModelTouched = fn;
    }
}
NovoDateTimePickerElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-date-time-picker',
                providers: [DATE_TIME_PICKER_VALUE_ACCESSOR],
                animations: [
                    trigger('dateTextState', [
                        state('date', style({
                            'opacity': '1.0'
                        })),
                        state('time', style({
                            'opacity': '0.6'
                        })),
                        transition('date <=> time', animate('200ms ease-in'))
                    ]),
                    trigger('timeTextState', [
                        state('date', style({
                            'opacity': '0.6'
                        })),
                        state('time', style({
                            'opacity': '1.0'
                        })),
                        transition('date <=> time', animate('200ms ease-in'))
                    ]),
                    trigger('indicatorState', [
                        state('date', style({
                            'transform': 'translateX(0%)'
                        })),
                        state('time', style({
                            'transform': 'translateX(100%)'
                        })),
                        transition('date <=> time', animate('200ms ease-in'))
                    ]),
                    trigger('containerState', [
                        state('date', style({
                            'transform': 'translateX(0%)'
                        })),
                        state('time', style({
                            'transform': 'translateX(-100%)'
                        })),
                        transition('date <=> time', animate('200ms ease-in'))
                    ])
                ],
                template: `
        <div class="date-time-container">
            <div class="date-time-tabs">
                <span class="date-tab" (click)="toggleView('date')" [@dateTextState]="componentTabState">{{selectedLabel}}</span>
                <span class="time-tab" (click)="toggleView('time')" [@timeTextState]="componentTabState">
                    <span class="hours" data-automation-id="novo-time-picker-hours">{{hours}}</span>:<span
                    class="minutes" data-automation-id="novo-time-picker-minutes">{{minutes}}</span>
                    <span *ngIf="!military" class="meridian">{{meridian}}</span>
                </span>
                <i class="date-time-indicator" [@indicatorState]="componentTabState"></i>
            </div>
            <div class="view-container" [@containerState]="componentTabState">
                <div class="calendar">
                    <novo-date-picker (onSelect)="onDateSelected($event)" [(ngModel)]="model" inline="true" [minYear]="minYear" [maxYear]="maxYear" [start]="start" [end]="end"></novo-date-picker>
                </div>
                <div class="time-picker">
                    <novo-time-picker (onSelect)="onTimeSelected($event)" [(ngModel)]="model" [military]="military" inline="true"></novo-time-picker>
                </div>
            </div>
        </div>
    `
            },] },
];
/**
 * @nocollapse
 */
NovoDateTimePickerElement.ctorParameters = () => [
    { type: NovoLabelService, },
    { type: ElementRef, },
];
NovoDateTimePickerElement.propDecorators = {
    'minYear': [{ type: Input },],
    'maxYear': [{ type: Input },],
    'start': [{ type: Input },],
    'end': [{ type: Input },],
    'military': [{ type: Input },],
    'onSelect': [{ type: Output },],
};

// NG
// Value accessor for the component (supports ngModel)
const DATE_VALUE_ACCESSOR$2 = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => NovoDateTimePickerInputElement),
    multi: true
};
class NovoDateTimePickerInputElement {
    /**
     * @param {?} element
     * @param {?} labels
     * @param {?} dateFormatService
     * @param {?} _changeDetectorRef
     */
    constructor(element, labels, dateFormatService, _changeDetectorRef) {
        this.element = element;
        this.labels = labels;
        this.dateFormatService = dateFormatService;
        this._changeDetectorRef = _changeDetectorRef;
        /**
         * View -> model callback called when value changes
         */
        this._onChange = () => { };
        /**
         * View -> model callback called when autocomplete has been touched
         */
        this._onTouched = () => { };
        this.military = false;
        this.maskOptions = {
            mask: this.dateFormatService.getDateMask(),
            keepCharPositions: true,
            guide: false
        };
        this.placeholder = this.labels.dateFormatPlaceholder;
    }
    /**
     * BEGIN: Convienient Panel Methods.
     * @return {?}
     */
    openPanel() {
        this.overlay.openPanel();
    }
    /**
     * @return {?}
     */
    closePanel() {
        this.overlay.closePanel();
    }
    /**
     * @return {?}
     */
    get panelOpen() {
        return this.overlay && this.overlay.panelOpen;
    }
    /**
     * END: Convienient Panel Methods.
     * @param {?} event
     * @return {?}
     */
    _handleKeydown(event) {
        if ((event.keyCode === ESCAPE || event.keyCode === ENTER || event.keyCode === TAB) && this.panelOpen) {
            this.closePanel();
            event.stopPropagation();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    _handleInput(event) {
        if (document.activeElement === event.target) {
            this._onChange(((event.target)).value);
            let [dateTimeValue, formatted] = this.dateFormatService.parseString(((event.target)).value, false, 'date');
            if (dateTimeValue && dateTimeValue.getTime() > 0) {
                this._setTriggerValue(dateTimeValue);
            }
            this.openPanel();
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        Promise.resolve(null).then(() => this._setTriggerValue(value));
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this._onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    _setTriggerValue(value) {
        const /** @type {?} */ toDisplay = value;
        // Simply falling back to an empty string if the display value is falsy does not work properly.
        // The display value can also be the number zero and shouldn't fall back to an empty string.
        const /** @type {?} */ inputValue = toDisplay !== null ? toDisplay : '';
        // If it's used within a `MdFormField`, we should set it through the property so it can go
        // through change detection.
        //this._element.nativeElement.value = inputValue;
        this.value = inputValue;
        this.formattedValue = this.formatDateValue(inputValue);
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    setValue(event) {
        if (event && event.date) {
            this._setTriggerValue(event.date);
            this._onChange(event.date);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    setValueAndClose(event) {
        this.setValue(event);
        this.closePanel();
    }
    /**
     * Clear any previous selected option and emit a selection change event for this option
     * @param {?} skip
     * @return {?}
     */
    clearValue(skip) {
        this.writeValue(null);
        this._onChange(null);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    formatDateValue(value) {
        if (!value) {
            return '';
        }
        return this.labels.formatDateWithFormat(value, {
            month: 'numeric',
            day: 'numeric',
            year: 'numeric',
            hour: 'numeric',
            minute: 'numeric'
        });
    }
    /**
     * @return {?}
     */
    get hasValue() {
        return !Helpers.isEmpty(this.value);
    }
}
NovoDateTimePickerInputElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-date-time-picker-input',
                providers: [DATE_VALUE_ACCESSOR$2],
                template: `
        <input type="text" [name]="name" [value]="formattedValue" [placeholder]="placeholder" (focus)="openPanel()" (keydown)="_handleKeydown($event)" (input)="_handleInput($event)" #input readOnly/>
        <i *ngIf="!hasValue" (click)="openPanel()" class="bhi-calendar"></i>
        <i *ngIf="hasValue" (click)="clearValue()" class="bhi-times"></i>

        <novo-overlay-template [parent]="element">
            <novo-date-time-picker inline="true" (onSelect)="setValue($event)" [ngModel]="value" [military]="military"></novo-date-time-picker>
        </novo-overlay-template>
  `
            },] },
];
/**
 * @nocollapse
 */
NovoDateTimePickerInputElement.ctorParameters = () => [
    { type: ElementRef, },
    { type: NovoLabelService, },
    { type: DateFormatService, },
    { type: ChangeDetectorRef, },
];
NovoDateTimePickerInputElement.propDecorators = {
    'name': [{ type: Input },],
    'placeholder': [{ type: Input },],
    'maskOptions': [{ type: Input },],
    'military': [{ type: Input },],
    'overlay': [{ type: ViewChild, args: [NovoOverlayTemplate,] },],
};

// NG2
// Vendor
// APP
class NovoDateTimePickerModule {
}
NovoDateTimePickerModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, FormsModule, NovoDatePickerModule, NovoTimePickerModule, TextMaskModule, NovoOverlayModule],
                declarations: [NovoDateTimePickerElement, NovoDateTimePickerInputElement],
                exports: [NovoDateTimePickerElement, NovoDateTimePickerInputElement]
            },] },
];
/**
 * @nocollapse
 */
NovoDateTimePickerModule.ctorParameters = () => [];

// NG2
// Value accessor for the component (supports ngModel)
const CKEDITOR_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => NovoCKEditorElement),
    multi: true
};
/**
 * CKEditor component
 * Usage :
 *  <novo-editor [(ngModel)]="data" [config]="{...}" debounce="500"></novo-editor>
 */
class NovoCKEditorElement {
    /**
     * @param {?} zone
     */
    constructor(zone) {
        this.zone = zone;
        this.change = new EventEmitter();
        this.ready = new EventEmitter();
        this.blur = new EventEmitter();
        this.focus = new EventEmitter();
        this.paste = new EventEmitter();
        this.loaded = new EventEmitter();
        this._value = '';
    }
    /**
     * @return {?}
     */
    get value() {
        return this._value;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set value(v) {
        if (v !== this._value) {
            this._value = v;
            this.onChange(v);
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.instance) {
            this.instance.focusManager.blur(true); // Remove focus from editor
            setTimeout(() => {
                this.instance.removeAllListeners();
                CKEDITOR.instances[this.instance.name].destroy();
                this.instance.destroy();
                this.instance = null;
            });
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        let /** @type {?} */ config = this.config || this.getBaseConfig();
        this.ckeditorInit(config);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    updateValue(value) {
        this.zone.run(() => {
            this.value = value;
            this.onChange(value);
            this.onTouched();
            this.change.emit(value);
        });
    }
    /**
     * @param {?} config
     * @return {?}
     */
    ckeditorInit(config) {
        if (!CKEDITOR) {
            console.error('Make sure to include CKEditor sources in your dependencies!');
            return;
        }
        // CKEditor replace textarea
        this.instance = CKEDITOR.replace(this.host.nativeElement, config);
        // Set initial value
        this.instance.setData(this.value);
        // listen for instanceReady event
        this.instance.on('instanceReady', (evt) => {
            // send the evt to the EventEmitter
            this.ready.emit(evt);
        });
        // CKEditor change event
        this.instance.on('change', () => {
            this.onTouched();
            let /** @type {?} */ value = this.instance.getData();
            // Debounce update
            if (this.debounce) {
                if (this.debounceTimeout) {
                    clearTimeout(this.debounceTimeout);
                }
                this.debounceTimeout = setTimeout(() => {
                    this.updateValue(value);
                    this.debounceTimeout = null;
                }, parseInt(this.debounce));
            }
            else {
                this.updateValue(value);
            }
        });
        this.instance.on('blur', (event) => {
            this.blur.emit(event);
        });
        this.instance.on('focus', (event) => {
            this.focus.emit(event);
        });
        this.instance.on('paste', (event) => {
            this.paste.emit(event);
        });
        this.instance.on('loaded', (event) => {
            this.loaded.emit(event);
        });
    }
    /**
     * @return {?}
     */
    getBaseConfig() {
        const /** @type {?} */ baseConfig = {
            enterMode: CKEDITOR.ENTER_BR,
            shiftEnterMode: CKEDITOR.ENTER_P,
            disableNativeSpellChecker: false,
            removePlugins: 'liststyle,tabletools,contextmenu' // allows browser based spell checking
        };
        const /** @type {?} */ minimalConfig = {
            toolbar: [{
                    name: 'basicstyles',
                    items: ['Styles', 'FontSize', 'Bold', 'Italic', 'Underline', 'TextColor', '-', 'NumberedList', 'BulletedList', 'Outdent', 'Indent', 'Link']
                }]
        };
        const /** @type {?} */ extendedConfig = {
            toolbar: [
                { name: 'clipboard', items: ['Paste', 'PasteText', 'PasteFromWord', 'Undo', 'Redo'] },
                { name: 'paragraph', items: ['NumberedList', 'BulletedList', 'Outdent', 'Indent', 'Blockquote', 'CreateDiv', 'JustifyLeft', 'JustifyCenter', 'JustifyRight', 'JustifyBlock', 'BidiLtr', 'BidiRtl'] },
                { name: 'links', items: ['Link'] },
                { name: 'insert', items: ['Image', 'Table', 'HorizontalRule'] },
                { name: 'tools', items: ['Maximize', 'Source'] },
                '/',
                { name: 'basicstyles', items: ['Bold', 'Italic', 'Underline', 'Strike', 'Subscript', 'Superscript'] },
                { name: 'styles', items: ['Styles', 'Format', 'Font', 'FontSize'] },
                { name: 'colors', items: ['TextColor', 'BGColor'] }
            ]
        };
        return Object.assign(baseConfig, this.minimal ? minimalConfig : extendedConfig);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this._value = value;
        if (this.instance) {
            this.instance.setData(value);
        }
    }
    /**
     * @param {?=} value
     * @return {?}
     */
    onChange(value) {
    }
    /**
     * @param {?=} event
     * @return {?}
     */
    onTouched(event) {
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * @param {?} text
     * @return {?}
     */
    insertText(text) {
        let /** @type {?} */ trimmedText = text.trim();
        this.instance.insertText(trimmedText);
    }
}
NovoCKEditorElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-editor',
                providers: [CKEDITOR_CONTROL_VALUE_ACCESSOR],
                template: '<textarea [name]="name" [id]="name" #host></textarea>'
            },] },
];
/**
 * @nocollapse
 */
NovoCKEditorElement.ctorParameters = () => [
    { type: NgZone, },
];
NovoCKEditorElement.propDecorators = {
    'config': [{ type: Input },],
    'debounce': [{ type: Input },],
    'name': [{ type: Input },],
    'minimal': [{ type: Input },],
    'change': [{ type: Output },],
    'ready': [{ type: Output },],
    'blur': [{ type: Output },],
    'focus': [{ type: Output },],
    'paste': [{ type: Output },],
    'loaded': [{ type: Output },],
    'host': [{ type: ViewChild, args: ['host',] },],
    'value': [{ type: Input },],
};

// NG2
// APP
class NovoNovoCKEditorModule {
}
NovoNovoCKEditorModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, FormsModule],
                declarations: [NovoCKEditorElement],
                exports: [NovoCKEditorElement]
            },] },
];
/**
 * @nocollapse
 */
NovoNovoCKEditorModule.ctorParameters = () => [];

// NG2
// APP
class NovoTipWellElement {
    /**
     * @param {?} labels
     */
    constructor(labels) {
        this.labels = labels;
        this.button = true;
        this.confirmed = new EventEmitter();
        this.isActive = true;
        this.isActive = true;
        // Check if localStorage is enabled
        this.isLocalStorageEnabled = (() => {
            let isEnabled = false;
            if (typeof localStorage === 'object') {
                try {
                    localStorage.setItem('lsTest', '1');
                    localStorage.removeItem('lsTest');
                    isEnabled = true;
                }
                catch (e) {
                    console.warn('This web browser does not support storing settings locally. In Safari, the most common cause of this is using "Private Browsing Mode". Some settings may not save or some features may not work properly for you.');
                }
            }
            return isEnabled;
        })();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.tip = this.tip || '';
        this.buttonText = this.buttonText || this.labels.okGotIt;
        this.button = typeof this.button === 'string' ? this.button === 'true' : this.button;
        this.icon = this.icon || null;
        // Set a (semi) unique name for the tip-well
        this.name = this.name || Math.round(Math.random() * 100);
        this.localStorageKey = `novo-tw_${this.name}`;
        // Check localStorage for state
        if (this.isLocalStorageEnabled) {
            let /** @type {?} */ storedValue = JSON.parse(localStorage.getItem(this.localStorageKey));
            this.isActive = storedValue !== false;
        }
    }
    /**
     * \@name hideTip
     * @return {?}
     */
    hideTip() {
        if (this.isLocalStorageEnabled) {
            localStorage.setItem(this.localStorageKey, JSON.stringify(false));
        }
        this.isActive = false;
        this.confirmed.emit();
    }
}
NovoTipWellElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-tip-well',
                template: `
        <div *ngIf="isActive">
            <div>
                <i class="bhi-{{ icon }}" *ngIf="icon" [attr.data-automation-id]="'novo-tip-well-icon-' + name"></i>
                <p [attr.data-automation-id]="'novo-tip-well-tip-' + name">{{ tip }}</p>
            </div>
            <button theme="dialogue" (click)="hideTip()" *ngIf="button" [attr.data-automation-id]="'novo-tip-well-button-' + name">{{ buttonText }}</button>
        </div>
    `,
                host: {
                    '[class.active]': 'isActive'
                }
            },] },
];
/**
 * @nocollapse
 */
NovoTipWellElement.ctorParameters = () => [
    { type: NovoLabelService, },
];
NovoTipWellElement.propDecorators = {
    'name': [{ type: Input },],
    'tip': [{ type: Input },],
    'buttonText': [{ type: Input },],
    'button': [{ type: Input },],
    'icon': [{ type: Input },],
    'confirmed': [{ type: Output },],
};

// NG2
// APP
class NovoTipWellModule {
}
NovoTipWellModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, NovoButtonModule],
                declarations: [NovoTipWellElement],
                exports: [NovoTipWellElement]
            },] },
];
/**
 * @nocollapse
 */
NovoTipWellModule.ctorParameters = () => [];

// NG2
// APP
class NovoFieldsetHeaderElement {
}
NovoFieldsetHeaderElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-fieldset-header',
                template: `
        <h6><i [class]="icon || 'bhi-section'"></i>{{title}}</h6>
    `
            },] },
];
/**
 * @nocollapse
 */
NovoFieldsetHeaderElement.ctorParameters = () => [];
NovoFieldsetHeaderElement.propDecorators = {
    'title': [{ type: Input },],
    'icon': [{ type: Input },],
};
class NovoControlCustom {
    /**
     * @param {?} componentUtils
     */
    constructor(componentUtils) {
        this.componentUtils = componentUtils;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.controlComponent = this.componentUtils.appendNextToLocation(this.control.customControl, this.referencePoint);
        this.controlComponent.instance.control = this.control;
        this.controlComponent.instance.form = this.form;
        if (this.control.customControlConfig) {
            this.controlComponent.instance.config = this.control.customControlConfig;
        }
    }
}
NovoControlCustom.decorators = [
    { type: Component, args: [{
                selector: 'novo-control-custom',
                template: `
        <span #ref></span>
    `
            },] },
];
/**
 * @nocollapse
 */
NovoControlCustom.ctorParameters = () => [
    { type: ComponentUtils, },
];
NovoControlCustom.propDecorators = {
    'control': [{ type: Input },],
    'form': [{ type: Input },],
    'referencePoint': [{ type: ViewChild, args: ['ref', { read: ViewContainerRef },] },],
};
class NovoFieldsetElement {
    constructor() {
        this.controls = [];
    }
}
NovoFieldsetElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-fieldset',
                template: `
        <div class="novo-fieldset-container">
            <novo-fieldset-header [icon]="icon" [title]="title" *ngIf="title"></novo-fieldset-header>
            <ng-container *ngFor="let control of controls">
                <div class="novo-form-row" [class.disabled]="control.disabled" *ngIf="control.__type !== 'GroupedControl'">
                    <novo-control *ngIf="!control.customControl" [control]="control" [form]="form"></novo-control>
                    <novo-control-custom *ngIf="control.customControl" [control]="control" [form]="form"></novo-control-custom>
                </div>
                <div *ngIf="control.__type === 'GroupedControl'">TODO - GroupedControl</div>
            </ng-container>
        </div>
    `
            },] },
];
/**
 * @nocollapse
 */
NovoFieldsetElement.ctorParameters = () => [];
NovoFieldsetElement.propDecorators = {
    'controls': [{ type: Input },],
    'form': [{ type: Input },],
    'title': [{ type: Input },],
    'icon': [{ type: Input },],
};
class NovoDynamicFormElement {
    constructor() {
        this.controls = [];
        this.fieldsets = [];
        this.hideNonRequiredFields = true;
        this.allFieldsRequired = false;
        this.allFieldsNotRequired = false;
        this.showingAllFields = false;
        this.showingRequiredFields = true;
        this.numControls = 0;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.ngOnChanges();
    }
    /**
     * @param {?=} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this.form.layout = this.layout;
        if (!(this.fieldsets && this.fieldsets.length) && this.controls && this.controls.length) {
            this.fieldsets = [{
                    controls: this.controls
                }];
            this.numControls = this.controls.length;
        }
        else if (this.fieldsets) {
            this.fieldsets.forEach(fieldset => {
                this.numControls = this.numControls + fieldset.controls.length;
            });
        }
        let /** @type {?} */ requiredFields = [];
        let /** @type {?} */ nonRequiredFields = [];
        this.fieldsets.forEach(fieldset => {
            fieldset.controls.forEach(control => {
                if (control.required) {
                    requiredFields.push(control);
                }
                else {
                    nonRequiredFields.push(control);
                }
            });
        });
        this.allFieldsRequired = requiredFields.length === this.numControls;
        this.allFieldsNotRequired = nonRequiredFields.length === this.numControls;
        if (this.allFieldsNotRequired && this.hideNonRequiredFields) {
            this.fieldsets.forEach(fieldset => {
                fieldset.controls.forEach(control => {
                    this.form.controls[control.key].hidden = false;
                });
            });
        }
        this.form.fieldsets = [...this.fieldsets];
    }
    /**
     * @return {?}
     */
    showAllFields() {
        this.form.fieldsets.forEach(fieldset => {
            fieldset.controls.forEach(control => {
                this.form.controls[control.key].hidden = false;
            });
        });
        this.showingAllFields = true;
        this.showingRequiredFields = false;
    }
    /**
     * @param {?} hideRequiredWithValue
     * @return {?}
     */
    showOnlyRequired(hideRequiredWithValue) {
        this.form.fieldsets.forEach(fieldset => {
            fieldset.controls.forEach(control => {
                // Hide any non-required fields
                if (!control.required) {
                    this.form.controls[control.key].hidden = true;
                }
                // Hide required fields that have been successfully filled out
                if (hideRequiredWithValue && !Helpers.isBlank(this.form.value[control.key])) {
                    this.form.controls[control.key].hidden = true;
                }
                // Don't hide fields with errors
                if (this.form.controls[control.key].errors) {
                    this.form.controls[control.key].hidden = false;
                }
            });
        });
        this.showingAllFields = false;
        this.showingRequiredFields = true;
        this.forceValidation();
    }
    /**
     * @return {?}
     */
    get values() {
        return this.form ? this.form.value : null;
    }
    /**
     * @return {?}
     */
    get isValid() {
        return this.form ? this.form.valid : false;
    }
    /**
     * @return {?}
     */
    updatedValues() {
        let /** @type {?} */ ret = null;
        this.form.fieldsets.forEach(fieldset => {
            fieldset.controls.forEach(control => {
                if (this.form.controls[control.key].dirty || control.dirty) {
                    if (!ret) {
                        ret = {};
                    }
                    ret[control.key] = this.form.value[control.key];
                }
            });
        });
        return ret;
    }
    /**
     * @return {?}
     */
    forceValidation() {
        Object.keys(this.form.controls).forEach((key) => {
            let /** @type {?} */ control = this.form.controls[key];
            if (control.required && Helpers.isBlank(this.form.value[control.key])) {
                control.markAsDirty();
                control.markAsTouched();
            }
        });
    }
}
NovoDynamicFormElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-dynamic-form',
                template: `
        <div class="novo-form-container">
            <header>
                <ng-content select="form-title"></ng-content>
                <ng-content select="form-subtitle"></ng-content>
            </header>
            <form class="novo-form" [formGroup]="form" autocomplete="off">
                <ng-container *ngFor="let fieldset of form.fieldsets">
                    <novo-fieldset *ngIf="fieldset.controls.length" [icon]="fieldset.icon" [controls]="fieldset.controls" [title]="fieldset.title" [form]="form"></novo-fieldset>
                </ng-container>
            </form>
        </div>
    `
            },] },
];
/**
 * @nocollapse
 */
NovoDynamicFormElement.ctorParameters = () => [];
NovoDynamicFormElement.propDecorators = {
    'controls': [{ type: Input },],
    'fieldsets': [{ type: Input },],
    'form': [{ type: Input },],
    'layout': [{ type: Input },],
    'hideNonRequiredFields': [{ type: Input },],
};

// NG2
class NovoFormElement {
    constructor() {
        this.hideHeader = false;
        this.showingAllFields = false;
        this.showingRequiredFields = true;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.form.layout = this.layout;
    }
    /**
     * @return {?}
     */
    get value() {
        return this.form.getRawValue();
    }
    /**
     * @return {?}
     */
    get isValid() {
        return this.form.valid;
    }
    /**
     * @return {?}
     */
    showAllFields() {
        Object.keys(this.form.controls).forEach((key) => {
            this.form.controls[key].hidden = false;
        });
        this.showingAllFields = true;
        this.showingRequiredFields = false;
    }
    /**
     * @param {?} hideRequiredWithValue
     * @return {?}
     */
    showOnlyRequired(hideRequiredWithValue) {
        Object.keys(this.form.controls).forEach((key) => {
            // Hide any non-required fields
            if (!this.form.controls[key].required) {
                this.form.controls[key].hidden = true;
            }
            // Hide required fields that have been successfully filled out
            if (hideRequiredWithValue && !Helpers.isBlank(this.form.value[key])) {
                this.form.controls[key].hidden = true;
            }
            // Don't hide fields with errors
            if (this.form.controls[key].errors) {
                this.form.controls[key].hidden = false;
            }
        });
        this.showingAllFields = false;
        this.showingRequiredFields = true;
        this.forceValidation();
    }
    /**
     * @return {?}
     */
    forceValidation() {
        Object.keys(this.form.controls).forEach((key) => {
            let /** @type {?} */ control = this.form.controls[key];
            if (control.required && Helpers.isBlank(this.form.value[control.key])) {
                control.markAsDirty();
                control.markAsTouched();
            }
        });
    }
}
NovoFormElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-form',
                template: `
        <div class="novo-form-container">
            <header *ngIf="!hideHeader">
                <ng-content select="form-title"></ng-content>
                <ng-content select="form-subtitle"></ng-content>
            </header>
            <form class="novo-form" [formGroup]="form" autocomplete="off">
                <ng-content></ng-content>
            </form>
        </div>
    `
            },] },
];
/**
 * @nocollapse
 */
NovoFormElement.ctorParameters = () => [];
NovoFormElement.propDecorators = {
    'form': [{ type: Input },],
    'layout': [{ type: Input },],
    'hideHeader': [{ type: Input },],
};

// NG2
class NovoFormControl extends FormControl {
    /**
     * @param {?} value
     * @param {?} control
     */
    constructor(value, control) {
        super(value, control.validators, control.asyncValidators);
        this.displayValueChanges = new EventEmitter();
        this.valueHistory = [];
        this.validators = control.validators;
        this.initialValue = value;
        this.valueHistory.push(value);
        this.key = control.key;
        this.label = control.label;
        this.readOnly = control.readOnly;
        this.hidden = control.hidden;
        this.encrypted = control.encrypted;
        this.config = control.config;
        this.type = control.type;
        this.subType = control.subType;
        this.required = control.required;
        this.hasRequiredValidator = this.required;
        this.tooltip = control.tooltip;
        this.tooltipPosition = control.tooltipPosition;
        this.label = control.label;
        this.name = control.name;
        this.required = control.required;
        this.sortOrder = control.sortOrder;
        this.controlType = control.controlType;
        this.placeholder = control.placeholder;
        this.multiple = control.multiple;
        this.headerConfig = control.headerConfig;
        this.optionsType = control.optionsType;
        this.readOnly = control.readOnly;
        this.layoutOptions = control.layoutOptions;
        this.military = control.military;
        this.maxlength = control.maxlength;
        this.minlength = control.minlength;
        this.closeOnSelect = control.closeOnSelect;
        this.interactions = control.interactions;
        this.appendToBody = control.appendToBody;
        this.parentScrollSelector = control.parentScrollSelector;
        this.description = control.description;
        this.options = control.options;
        this.tipWell = control.tipWell;
        // Reactive Form, need to enable/disable, can't bind to [disabled]
        if (this.readOnly) {
            this.disable();
        }
        else {
            this.enable();
        }
    }
    /**
     * \@name hide
     * @param {?=} clearValue - flag to reset the control's value
     * @return {?}
     */
    hide(clearValue = true) {
        this.hidden = true;
        if (clearValue) {
            this.setValue(null);
        }
    }
    /**
     * \@name show
     * @return {?}
     */
    show() {
        this.hidden = false;
    }
    /**
     * \@name setRequired
     * @param {?} isRequired
     * @return {?}
     */
    setRequired(isRequired) {
        this.required = isRequired;
        // Update validators to have the required
        if (this.required && !this.hasRequiredValidator) {
            let /** @type {?} */ validators = [...this.validators];
            validators.push(Validators.required);
            // TODO: duplicated below
            this.setValidators(validators);
            this.updateValueAndValidity();
            this.hasRequiredValidator = this.required;
        }
        else if (!this.required && this.hasRequiredValidator) {
            let /** @type {?} */ validators = [...this.validators];
            validators = validators.filter(val => val !== Validators.required);
            // TODO: duplicated above
            this.setValidators(validators);
            this.updateValueAndValidity();
            this.hasRequiredValidator = this.required;
        }
    }
    /**
     * \@name setValue
     *
     * @param {?} value
     * @param {?=} __1
     * @return {?}
     */
    setValue(value, { onlySelf, emitEvent, emitModelToViewChange, emitViewToModelChange } = {}) {
        this.markAsDirty();
        this.markAsTouched();
        this.displayValueChanges.emit(value);
        super.setValue(value, { onlySelf, emitEvent, emitModelToViewChange, emitViewToModelChange });
        // History
        clearTimeout(this.historyTimeout);
        this.historyTimeout = setTimeout(() => {
            this.valueHistory.push(value);
        }, 300);
    }
    /**
     * \@name setReadOnly
     * @param {?} isReadOnly
     * @return {?}
     */
    setReadOnly(isReadOnly) {
        this.readOnly = isReadOnly;
        if (this.readOnly) {
            this.disable();
        }
        else {
            this.enable();
        }
    }
    /**
     * \@name markAsInvalid
     * @param {?} message
     * @return {?}
     */
    markAsInvalid(message) {
        this.markAsDirty();
        this.markAsTouched();
        this.setErrors(Object.assign({}, this.errors, { custom: message }));
    }
}
class NovoFormGroup extends FormGroup {
    /**
     * @return {?}
     */
    get value() {
        return this.getRawValue();
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set value(v) {
        this._value = v;
    }
}

// NG2
// APP
class BaseControl {
    /**
     * @param {?=} type
     * @param {?=} config
     */
    constructor(type = 'BaseControl', config = {}) {
        this.__type = 'BaseControl';
        this.__type = type;
        this.__config = config;
        this.validators = config.validators || [];
        this.asyncValidators = config.asyncValidators || [];
        this.value = config.value;
        this.key = config.key || '';
        this.label = config.label || '';
        this.checkboxLabel = config.checkboxLabel;
        this.name = config.name || '';
        this.required = !!config.required;
        this.hidden = !!config.hidden;
        this.encrypted = !!config.encrypted;
        this.sortOrder = config.sortOrder === undefined ? 1 : config.sortOrder;
        this.controlType = config.controlType || '';
        this.placeholder = config.placeholder || '';
        this.config = config.config || null;
        this.dirty = !!config.value;
        this.multiple = !!config.multiple;
        this.headerConfig = config.headerConfig || null;
        this.currencyFormat = config.currencyFormat || null;
        this.associatedEntity = config.associatedEntity || null;
        this.optionsType = config.optionsType || null;
        this.options = config.options || [];
        this.forceClear = new EventEmitter();
        this.readOnly = !!config.readOnly || !!config.disabled;
        this.disabled = !!config.disabled;
        this.layoutOptions = config.layoutOptions || {};
        this.military = !!config.military;
        if (this.required) {
            this.validators.push(Validators.required);
        }
        if (!Helpers.isBlank(config.maxlength)) {
            this.maxlength = config.maxlength;
            this.validators.push(Validators.maxLength(this.maxlength));
        }
        if (!Helpers.isBlank(config.minlength)) {
            this.minlength = config.minlength;
            this.validators.push(Validators.minLength(this.minlength));
        }
        this.closeOnSelect = !!config.closeOnSelect;
        this.interactions = config.interactions;
        this.dataSpecialization = config.dataSpecialization;
        this.appendToBody = !!config.appendToBody;
        this.parentScrollSelector = config.parentScrollSelector;
        this.description = config.description;
        if (config.tooltip) {
            this.tooltip = config.tooltip;
            this.tooltipPosition = config.tooltipPosition;
        }
        this.customControl = config.customControl;
        this.customControlConfig = config.customControlConfig;
        this.tipWell = config.tipWell;
        this.width = config.width;
    }
}

const MAX_INTEGER = 2147483647;
const MIN_YEAR = 1753;
class FormValidators {
    /**
     * @param {?} control
     * @return {?}
     */
    static maxInteger(control) {
        return control.value < MAX_INTEGER ? null : { 'integerTooLarge': true };
    }
    /**
     * @param {?} control
     * @return {?}
     */
    static minYear(control) {
        if (!control.value) {
            return null;
        }
        return control.value >= MIN_YEAR ? null : { 'minYear': true };
    }
    /**
     * @param {?} control
     * @return {?}
     */
    static maxDouble(control) {
        return control.value < Number.MAX_SAFE_INTEGER ? null : { 'doubleTooLarge': true };
    }
    /**
     * @param {?} control
     * @return {?}
     */
    static isEmail(control) {
        let /** @type {?} */ EMAIL_REGEXP = /^[a-z0-9!#$%&'*+\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i;
        return !control.value || EMAIL_REGEXP.test(control.value) ? null : { 'invalidEmail': true };
    }
    /**
     * @param {?} control
     * @return {?}
     */
    static isValidAddress(control) {
        if (control.value && control.dirty) {
            let /** @type {?} */ valid = true;
            // Address
            if ((!control.value.address1 || control.value.address1.length === 0) &&
                (!control.value.city || control.value.city.length === 0) &&
                (!control.value.state || control.value.state.length === 0) &&
                (!control.value.address2 || control.value.address2.length === 0) &&
                (!control.value.zip || control.value.zip.length === 0) &&
                (!control.value.countryName || control.value.countryName.length === 0)) {
                valid = false;
            }
            return valid ? null : { 'invalidAddress': true };
        }
        return null;
    }
}

// APP
class AddressControl extends BaseControl {
    /**
     * @param {?} config
     */
    constructor(config) {
        super('AddressControl', config);
        this.controlType = 'address';
        this.validators.push(FormValidators.isValidAddress);
    }
}

// APP
class CheckListControl extends BaseControl {
    /**
     * @param {?} config
     */
    constructor(config) {
        super('CheckListControl', config);
        this.controlType = 'checklist';
        this.options = config.options || [];
    }
}

// APP
class CheckboxControl extends BaseControl {
    /**
     * @param {?} config
     */
    constructor(config) {
        super('CheckboxControl', config);
        this.controlType = 'checkbox';
    }
}

// APP
class DateControl extends BaseControl {
    /**
     * @param {?} config
     */
    constructor(config) {
        super('DateControl', config);
        this.controlType = 'date';
    }
}

// APP
class DateTimeControl extends BaseControl {
    /**
     * @param {?} config
     */
    constructor(config) {
        super('DateTimeControl', config);
        this.controlType = 'date-time';
    }
}

// APP
class EditorControl extends BaseControl {
    /**
     * @param {?} config
     */
    constructor(config) {
        super('EditorControl', config);
        this.controlType = 'editor';
        this.minimal = false;
    }
}

// APP
class FileControl extends BaseControl {
    /**
     * @param {?} config
     */
    constructor(config) {
        super('FileControl', config);
        this.controlType = 'file';
        // TODO - translate
        this.placeholder = config.placeholder;
        this.multiple = config.multiple;
    }
}

// APP
class NativeSelectControl extends BaseControl {
    /**
     * @param {?} config
     */
    constructor(config) {
        super('NativeSelectControl', config);
        this.controlType = 'native-select';
        this.options = [];
        this.options = config.options || [];
    }
}

// APP
class PickerControl extends BaseControl {
    /**
     * @param {?} config
     */
    constructor(config) {
        super('PickerControl', config);
        this.controlType = 'picker';
        this.options = [];
        this.options = config.options || [];
    }
}
class TablePickerControl extends PickerControl {
    /**
     * @param {?} config
     */
    constructor(config) {
        super(Object.assign(config, { appendToBody: true, parentScrollSelector: '.table-container' }));
        this.__type = 'TablePickerControl';
    }
}
class AppendToBodyPickerControl extends PickerControl {
    /**
     * @param {?} config
     */
    constructor(config) {
        super(Object.assign(config, { appendToBody: true, parentScrollSelector: '.table-container' }));
        this.__type = 'AppendToBodyPickerControl';
    }
}

// APP
class QuickNoteControl extends BaseControl {
    /**
     * @param {?} config
     */
    constructor(config) {
        super('QuickNoteControl', config);
        this.controlType = 'quick-note';
        this.options = [];
        this.options = config.options || [];
    }
}

// APP
class RadioControl extends BaseControl {
    /**
     * @param {?} config
     */
    constructor(config) {
        super('RadioControl', config);
        this.controlType = 'radio';
        this.options = [];
        this.options = config.options || [];
    }
}

// APP
class ReadOnlyControl extends BaseControl {
    /**
     * @param {?} config
     */
    constructor(config) {
        super('ReadOnlyControl', config);
        this.controlType = 'read-only';
        config.readOnly = true;
    }
}

// APP
class SelectControl extends BaseControl {
    /**
     * @param {?} config
     */
    constructor(config) {
        super('SelectControl', config);
        this.controlType = 'select';
        this.options = [];
        this.options = config.options || [];
        this.placeholder = config.placeholder || '';
    }
}

// APP
class TextAreaControl extends BaseControl {
    /**
     * @param {?} config
     */
    constructor(config) {
        super('TextAreaControl', config);
        this.controlType = 'text-area';
    }
}

// APP
class TextBoxControl extends BaseControl {
    /**
     * @param {?} config
     */
    constructor(config) {
        super('TextBoxControl', config);
        this.controlType = 'textbox';
        this.type = this.getTextboxType(config.type) || '';
        this.subType = config.type || '';
        this.setValidators(this.subType);
    }
    /**
     * @param {?} type
     * @return {?}
     */
    setValidators(type) {
        switch (type) {
            case 'email':
                this.validators.push(FormValidators.isEmail);
                break;
            case 'number':
            case 'currency':
                this.validators.push(FormValidators.maxInteger);
                break;
            case 'float':
            case 'percentage':
                this.validators.push(FormValidators.maxDouble);
                break;
            case 'year':
                this.validators.push(FormValidators.minYear);
                break;
            default:
                break;
        }
    }
    /**
     * @param {?} type
     * @return {?}
     */
    getTextboxType(type) {
        switch (type) {
            case 'percentage':
            case 'currency':
            case 'float':
            case 'year':
                return 'number';
            default:
                return type;
        }
    }
}

// APP
class TilesControl extends BaseControl {
    /**
     * @param {?} config
     */
    constructor(config) {
        super('TilesControl', config);
        this.controlType = 'tiles';
        this.options = [];
        this.options = config.options || [];
    }
}

// APP
class TimeControl extends BaseControl {
    /**
     * @param {?} config
     */
    constructor(config) {
        super('TimeControl', config);
        this.controlType = 'time';
    }
}

// APP
class GroupedControl {
    /**
     * @param {?} config
     */
    constructor(config) {
        this.__type = 'GroupedControl';
        Object.keys(config).forEach(key => this[key] = config[key]);
    }
}

class ControlFactory {
    /**
     * @param {?} type
     * @param {?} config
     * @return {?}
     */
    static create(type, config) {
        switch (type) {
            case 'AddressControl':
                return new AddressControl(config);
            case 'CheckboxControl':
                return new CheckboxControl(config);
            case 'CheckListControl':
                return new CheckListControl(config);
            case 'CheckListControl':
                return new CheckListControl(config);
            case 'DateTimeControl':
                return new DateTimeControl(config);
            case 'EditorControl':
                return new EditorControl(config);
            case 'FileControl':
                return new FileControl(config);
            case 'NativeSelectControl':
                return new NativeSelectControl(config);
            case 'PickerControl':
                return new PickerControl(config);
            case 'AppendToBodyPickerControl':
                return new AppendToBodyPickerControl(config);
            case 'TablePickerControl':
                return new TablePickerControl(config);
            case 'QuickNoteControl':
                return new QuickNoteControl(config);
            case 'RadioControl':
                return new RadioControl(config);
            case 'ReadOnlyControl':
                return new ReadOnlyControl(config);
            case 'TextAreaControl':
                return new TextAreaControl(config);
            case 'TextBoxControl':
                return new TextBoxControl(config);
            case 'SelectControl':
                return new SelectControl(config);
            case 'TilesControl':
                return new TilesControl(config);
            case 'TimeControl':
                return new TimeControl(config);
            default:
                console.warn('[ControlFactory] - unable to find control for type. Make sure to set "editorType" and "editorConfig" on your column', type);
                return null;
        }
    }
}

// NG2
// APP
class FormUtils {
    /**
     * @param {?} controls
     * @return {?}
     */
    toFormGroup(controls) {
        let /** @type {?} */ group = {};
        controls.forEach(control => {
            let /** @type {?} */ value = Helpers.isBlank(control.value) ? '' : control.value;
            group[control.key] = new NovoFormControl(value, control);
        });
        return new NovoFormGroup(group);
    }
    /**
     * @return {?}
     */
    emptyFormGroup() {
        return new NovoFormGroup({});
    }
    /**
     * @param {?} formGroup
     * @param {?} controls
     * @return {?}
     */
    addControls(formGroup, controls) {
        controls.forEach(control => {
            let /** @type {?} */ value = Helpers.isBlank(control.value) ? '' : control.value;
            let /** @type {?} */ formControl = new NovoFormControl(value, control);
            formGroup.addControl(control.key, formControl);
        });
    }
    /**
     * \@name toFormGroupFromFieldset
     * @param {?} fieldsets
     * @return {?}
     */
    toFormGroupFromFieldset(fieldsets) {
        let /** @type {?} */ controls = [];
        fieldsets.forEach(fieldset => {
            controls.push(...fieldset.controls);
        });
        return this.toFormGroup(controls);
    }
    /**
     * \@name determineInputType
     * @param {?} field
     * @return {?}
     */
    determineInputType(field) {
        let /** @type {?} */ type;
        if (field.dataSpecialization === 'DATETIME') {
            type = 'datetime';
        }
        else if (field.dataSpecialization === 'TIME') {
            type = 'time';
        }
        else if (field.dataSpecialization === 'MONEY') {
            type = 'currency';
        }
        else if (field.dataSpecialization === 'PERCENTAGE') {
            type = 'percentage';
        }
        else if (field.dataSpecialization === 'HTML') {
            type = 'editor';
        }
        else if (field.dataSpecialization === 'HTML-MINIMAL') {
            type = 'editor-minimal';
        }
        else if (field.dataSpecialization === 'YEAR') {
            type = 'year';
        }
        else if (field.dataType === 'Timestamp') {
            type = 'date';
        }
        else if (field.dataType === 'Boolean') {
            type = 'tiles';
        }
        else if (field.inputType === 'TEXTAREA') {
            type = 'textarea';
        }
        else if (field.options && ~['CHECKBOX', 'RADIO'].indexOf(field.inputType) && field.multiValue) {
            type = 'checklist';
        }
        else if (field.options && ~['CHECKBOX', 'RADIO'].indexOf(field.inputType) && !field.multiValue) {
            type = 'radio';
        }
        else if (field.options && ~['SELECT'].indexOf(field.inputType) && field.multiValue) {
            type = 'chips';
        }
        else if (field.options && ~['SELECT'].indexOf(field.inputType) && !field.multiValue) {
            type = 'select';
        }
        else if (~['Double', 'BigDecimal'].indexOf(field.dataType)) {
            type = 'float';
        }
        else if (field.options && ~['TILES'].indexOf(field.inputType) && !field.multiValue) {
            type = 'tiles';
        }
        else if (field.type === 'COMPOSITE') {
            type = 'address';
        }
        else if (field.dataType === 'Integer') {
            type = 'number';
        }
        else if (field.type === 'file') {
            type = 'file';
        } /* else {
            throw new Error('FormUtils: This field type is unsupported.');
        }*/
        return type;
    }
    /**
     * @param {?} key
     * @return {?}
     */
    isFieldEncrypted(key) {
        return key.indexOf('customEncrypted') > -1;
    }
    /**
     * @param {?} field
     * @param {?} http
     * @param {?} config
     * @param {?=} overrides
     * @param {?=} forTable
     * @return {?}
     */
    getControlForField(field, http$$1, config, overrides, forTable = false) {
        // TODO: if field.type overrides `determineInputType` we should use it in that method or use this method
        // TODO: (cont.) as the setter of the field argument
        let /** @type {?} */ type = this.determineInputType(field) || field.type;
        let /** @type {?} */ control;
        let /** @type {?} */ controlConfig = {
            type: type,
            key: field.name,
            label: field.label,
            placeholder: field.hint || '',
            required: field.required,
            hidden: !field.required,
            encrypted: this.isFieldEncrypted(field.name ? field.name.toString() : ''),
            value: field.value || field.defaultValue,
            sortOrder: field.sortOrder,
            associatedEntity: field.associatedEntity,
            optionsType: field.optionsType,
            multiple: field.multiValue,
            readOnly: !!field.disabled || !!field.readOnly,
            maxlength: field.maxLength,
            interactions: field.interactions,
            dataSpecialization: field.dataSpecialization,
            description: field.description || '',
            tooltip: field.tooltip,
            tooltipPosition: field.tooltipPosition,
            customControl: field.customControl,
            customControlConfig: field.customControlConfig
        };
        // TODO: getControlOptions should always return the correct format
        let /** @type {?} */ optionsConfig = this.getControlOptions(field, http$$1, config);
        if (Array.isArray(optionsConfig) && !(type === 'chips' || type === 'picker')) {
            controlConfig.options = optionsConfig;
        }
        else if (Array.isArray(optionsConfig) && (type === 'chips' || type === 'picker')) {
            controlConfig.config = {
                options: optionsConfig
            };
        }
        else if (optionsConfig) {
            controlConfig.config = optionsConfig;
        }
        if (type === 'year') {
            controlConfig.maxlength = 4;
        }
        // TODO: Overrides should be an iterable of all properties (potentially a private method)
        let /** @type {?} */ overrideResultsTemplate;
        let /** @type {?} */ overridePreviewTemplate;
        if (overrides && overrides[field.name]) {
            if (overrides[field.name].resultsTemplate) {
                overrideResultsTemplate = overrides[field.name].resultsTemplate;
                controlConfig.config.resultsTemplate = overrideResultsTemplate;
                delete overrides[field.name].resultsTemplate;
            }
            if (overrides[field.name].overridePreviewTemplate) {
                overrideResultsTemplate = overrides[field.name].overridePreviewTemplate;
                controlConfig.config.overridePreviewTemplate = overrideResultsTemplate;
                delete overrides[field.name].overridePreviewTemplate;
            }
            if (overrides[field.name].pickerCallback) {
                controlConfig.config.callback = overrides[field.name].pickerCallback;
            }
            Object.assign(controlConfig, overrides[field.name]);
        }
        switch (type) {
            case 'entitychips':
                // TODO: This doesn't belong in this codebase
                controlConfig.multiple = true;
                controlConfig.config.resultsTemplate = overrideResultsTemplate || EntityPickerResults;
                controlConfig.config.previewTemplate = overridePreviewTemplate || EntityPickerResult;
                // TODO: When appendToBody picker works better in table/form
                control = forTable ? new PickerControl(controlConfig) : new PickerControl(controlConfig);
                break;
            case 'chips':
                controlConfig.multiple = true;
                // TODO: When appendToBody picker works better in table/form
                control = forTable ? new PickerControl(controlConfig) : new PickerControl(controlConfig);
                break;
            case 'entitypicker':
                // TODO: This doesn't belong in this codebase
                controlConfig.config.resultsTemplate = overrideResultsTemplate || EntityPickerResults;
                // TODO: When appendToBody picker works better in table/form
                control = forTable ? new PickerControl(controlConfig) : new PickerControl(controlConfig);
                break;
            case 'picker':
                // TODO: When appendToBody picker works better in table/form
                control = forTable ? new PickerControl(controlConfig) : new PickerControl(controlConfig);
                break;
            case 'datetime':
                controlConfig.military = config ? !!config.military : false;
                control = new DateTimeControl(controlConfig);
                break;
            case 'date':
                controlConfig.military = config ? !!config.military : false;
                control = new DateControl(controlConfig);
                break;
            case 'time':
                controlConfig.military = config ? !!config.military : false;
                control = new TimeControl(controlConfig);
                break;
            case 'currency':
            case 'money':
            case 'email':
            case 'percentage':
            case 'float':
            case 'number':
            case 'year':
                // TODO: Only types from `determineInputType` should be used in this class
                if (type === 'money') {
                    type = 'currency';
                }
                controlConfig.type = type;
                control = new TextBoxControl(controlConfig);
                break;
            case 'text':
                control = new TextBoxControl(controlConfig);
                break;
            case 'textarea':
                control = new TextAreaControl(controlConfig);
                break;
            case 'editor':
                control = new EditorControl(controlConfig);
                break;
            case 'editor-minimal':
                control = new EditorControl(controlConfig);
                control.minimal = true;
                break;
            case 'tiles':
                control = new TilesControl(controlConfig);
                break;
            case 'checkbox':
                control = new CheckboxControl(controlConfig);
                break;
            case 'checklist':
                control = new CheckListControl(controlConfig);
                break;
            case 'radio':
                control = new RadioControl(controlConfig);
                break;
            case 'select':
                control = new SelectControl(controlConfig);
                break;
            case 'address':
                if (field.fields && field.fields.length) {
                    for (let /** @type {?} */ subfield of field.fields) {
                        if (subfield.defaultValue) {
                            if (Helpers.isBlank(controlConfig.value)) {
                                controlConfig.value = {};
                            }
                            controlConfig.value[subfield.name] = subfield.defaultValue;
                        }
                        else if (subfield.name === 'countryID') {
                            if (Helpers.isBlank(controlConfig.value)) {
                                controlConfig.value = {};
                            }
                            controlConfig.value[subfield.name] = 1;
                        }
                    }
                }
                control = new AddressControl(controlConfig);
                break;
            case 'file':
                control = new FileControl(controlConfig);
                break;
            default:
                control = new TextBoxControl(controlConfig);
                break;
        }
        return control;
    }
    /**
     * @param {?} meta
     * @param {?} currencyFormat
     * @param {?} http
     * @param {?} config
     * @param {?=} overrides
     * @param {?=} forTable
     * @return {?}
     */
    toControls(meta, currencyFormat, http$$1, config, overrides, forTable = false) {
        let /** @type {?} */ controls = [];
        if (meta && meta.fields) {
            let /** @type {?} */ fields = meta.fields;
            fields.forEach(field => {
                if (field.name !== 'id' && (field.dataSpecialization !== 'SYSTEM' || ['address', 'billingAddress', 'secondaryAddress'].indexOf(field.name) !== -1) && !field.readOnly) {
                    let /** @type {?} */ control = this.getControlForField(field, http$$1, config, overrides, forTable);
                    // Set currency format
                    if (control.subType === 'currency') {
                        control.currencyFormat = currencyFormat;
                    }
                    // Add to controls
                    controls.push(control);
                }
            });
        }
        return controls;
    }
    /**
     * @param {?} meta
     * @param {?} currencyFormat
     * @param {?} http
     * @param {?} config
     * @param {?=} overrides
     * @return {?}
     */
    toTableControls(meta, currencyFormat, http$$1, config, overrides) {
        let /** @type {?} */ controls = this.toControls(meta, currencyFormat, http$$1, config, overrides, true);
        let /** @type {?} */ ret = {};
        controls.forEach((control) => {
            ret[control.key] = {
                editorType: control.__type,
                editorConfig: control.__config
            };
        });
        return ret;
    }
    /**
     * @param {?} meta
     * @param {?} currencyFormat
     * @param {?} http
     * @param {?} config
     * @param {?=} overrides
     * @return {?}
     */
    toFieldSets(meta, currencyFormat, http$$1, config, overrides) {
        let /** @type {?} */ fieldsets = [];
        let /** @type {?} */ ranges = [];
        if (meta && meta.fields) {
            let /** @type {?} */ fields = meta.fields.map(field => {
                if (!field.hasOwnProperty('sortOrder')) {
                    field.sortOrder = Number.MAX_SAFE_INTEGER - 1;
                }
                return field;
            }).sort(Helpers.sortByField(['sortOrder', 'name']));
            if (meta.sectionHeaders && meta.sectionHeaders.length) {
                meta.sectionHeaders.sort(Helpers.sortByField(['sortOrder', 'name']));
                meta.sectionHeaders.forEach((item, i) => {
                    if (item.enabled) {
                        if (item.sortOrder > 0 && fieldsets.length === 0) {
                            fieldsets.push({
                                controls: []
                            });
                            ranges.push({
                                min: 0,
                                max: item.sortOrder - 1,
                                fieldsetIdx: 0
                            });
                        }
                        fieldsets.push({
                            title: item.label,
                            icon: item.icon || 'bhi-section',
                            controls: []
                        });
                        ranges.push({
                            min: item.sortOrder,
                            max: Number.MAX_SAFE_INTEGER,
                            fieldsetIdx: fieldsets.length - 1
                        });
                        if (i > 0 && fieldsets.length > 1) {
                            ranges[fieldsets.length - 2].max = item.sortOrder - 1;
                        }
                    }
                });
            }
            else {
                fieldsets.push({
                    controls: []
                });
                ranges.push({
                    min: 0,
                    max: Number.MAX_SAFE_INTEGER,
                    fieldsetIdx: 0
                });
            }
            fields.forEach(field => {
                if (field.name !== 'id' && (field.dataSpecialization !== 'SYSTEM' || ['address', 'billingAddress', 'secondaryAddress'].indexOf(field.name) !== -1) && !field.readOnly) {
                    let /** @type {?} */ control = this.getControlForField(field, http$$1, config, overrides);
                    // Set currency format
                    if (control.subType === 'currency') {
                        control.currencyFormat = currencyFormat;
                    }
                    let /** @type {?} */ location = ranges.find(item => {
                        return (item.min <= field.sortOrder && field.sortOrder <= item.max) || (item.min <= field.sortOrder && item.min === item.max);
                    });
                    if (location) {
                        // Add to controls
                        fieldsets[location.fieldsetIdx].controls.push(control);
                    }
                }
            });
        }
        if (fieldsets.length > 0) {
            return fieldsets;
        }
        else {
            return [{
                    controls: this.toControls(meta, currencyFormat, http$$1, config)
                }];
        }
    }
    /**
     * @param {?} field
     * @param {?} http
     * @param {?} config
     * @return {?}
     */
    getControlOptions(field, http$$1, config) {
        // TODO: The token property of config is the only property used; just pass in `token: string`
        if (field.dataType === 'Boolean' && !field.options) {
            // TODO: dataType should only be determined by `determineInputType` which doesn't ever return 'Boolean' it
            // TODO: (cont.) returns `tiles`
            return [
                { value: false, label: 'No' },
                { value: true, label: 'Yes' }
            ];
        }
        else if (field.optionsUrl) {
            return {
                field: 'value',
                format: '$label',
                options: (query) => {
                    // TODO: should return Observable
                    return new Promise((resolve, reject) => {
                        if (query && query.length) {
                            http$$1.get(`${field.optionsUrl}?filter=${query || ''}&BhRestToken=${config.token}`)
                                .map(response => response.json().data)
                                .subscribe(resolve, reject);
                        }
                        else {
                            resolve([]);
                        }
                    });
                }
            };
        }
        else if (Array.isArray(field.options) && field.type === 'chips') {
            let /** @type {?} */ options = field.options;
            return {
                field: 'value',
                format: '$label',
                options
            };
        }
        else if (field.options) {
            return field.options;
        }
        return null;
    }
    /**
     * @param {?} controls
     * @param {?} values
     * @param {?=} keepClean
     * @param {?=} keyOverride
     * @return {?}
     */
    setInitialValues(controls, values, keepClean, keyOverride) {
        for (let /** @type {?} */ i = 0; i < controls.length; i++) {
            let /** @type {?} */ control = controls[i];
            let /** @type {?} */ key = keyOverride ? control.key.replace(keyOverride, '') : control.key;
            let /** @type {?} */ value = values[key];
            if (Helpers.isBlank(value)) {
                continue;
            }
            if (Array.isArray(value) && value.length === 0) {
                continue;
            }
            if (Array.isArray(value) && value.length > 0) {
                value = value.filter(val => !(Object.keys(val).length === 0 && val.constructor === Object));
                if (value.length === 0) {
                    continue;
                }
            }
            if (value.data && value.data.length === 0) {
                continue;
            }
            if (Object.keys(value).length === 0 && value.constructor === Object) {
                continue;
            }
            control.value = value;
            // TODO: keepClean is not required, but is always used. It should default (to true?)
            control.dirty = !keepClean;
        }
    }
    /**
     * @param {?} fieldsets
     * @param {?} values
     * @param {?=} keepClean
     * @return {?}
     */
    setInitialValuesFieldsets(fieldsets, values, keepClean) {
        fieldsets.forEach(fieldset => {
            this.setInitialValues(fieldset.controls, values, keepClean);
        });
    }
    /**
     * @param {?} controls
     * @return {?}
     */
    forceShowAllControls(controls) {
        controls.forEach(control => {
            control.hidden = false;
        });
    }
    /**
     * @param {?} fieldsets
     * @return {?}
     */
    forceShowAllControlsInFieldsets(fieldsets) {
        fieldsets.forEach(fieldset => {
            fieldset.controls.forEach(control => {
                control.hidden = false;
            });
        });
    }
    /**
     * @param {?} form
     * @return {?}
     */
    forceValidation(form) {
        Object.keys(form.controls).forEach((key) => {
            let /** @type {?} */ control = form.controls[key];
            if (control.required && Helpers.isBlank(form.value[control.key])) {
                control.markAsDirty();
                control.markAsTouched();
            }
        });
    }
}
FormUtils.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
FormUtils.ctorParameters = () => [];

// NG2
// APP
class NovoToastService {
    /**
     * @param {?} componentUtils
     */
    constructor(componentUtils) {
        this.componentUtils = componentUtils;
        this.references = [];
        this.themes = [
            'default',
            'success',
            'info',
            'warning',
            'danger'
        ];
        this.icons = {
            default: 'bell',
            success: 'check',
            info: 'info',
            warning: 'warning',
            danger: 'remove'
        };
        this.defaults = {
            hideDelay: 3500,
            position: 'growlTopRight',
            theme: 'default'
        };
    }
    /**
     * @param {?} view
     * @return {?}
     */
    set parentViewContainer(view) {
        this._parentViewContainer = view;
    }
    /**
     * @param {?} options
     * @return {?}
     */
    alert(options) {
        return new Promise((resolve) => {
            if (!this._parentViewContainer) {
                console.error('No parent view container specified for the ToastService. Set it inside your main application. \nthis.toastService.parentViewContainer = view (ViewContainerRef)');
                return;
            }
            let /** @type {?} */ toast = this.componentUtils.appendNextToLocation(NovoToastElement, this._parentViewContainer);
            this.references.push(toast);
            this.handleAlert(toast.instance, options);
            resolve(toast);
        });
    }
    /**
     * @param {?} toast
     * @return {?}
     */
    isVisible(toast) {
        return toast.show;
    }
    /**
     * @param {?} toast
     * @return {?}
     */
    hide(toast) {
        toast.animate = false;
        setTimeout(() => {
            toast.show = false;
            const /** @type {?} */ REF = this.references.filter(x => x.instance === toast)[0];
            if (REF) {
                this.references.splice(this.references.indexOf(REF), 1);
                REF.destroy();
            }
        }, 300);
    }
    /**
     * @param {?} toast
     * @param {?} options
     * @return {?}
     */
    handleAlert(toast, options) {
        this.setToastOnSession(toast, options);
        setTimeout(() => {
            this.show(toast);
        }, 20);
        if (!toast.isCloseable) {
            this.toastTimer(toast);
        }
    }
    /**
     * @param {?} toast
     * @param {?} opts
     * @return {?}
     */
    setToastOnSession(toast, opts) {
        const /** @type {?} */ OPTIONS = (typeof opts === 'object') ? opts : {};
        toast.parent = this;
        toast.title = OPTIONS.title || '';
        toast.message = OPTIONS.message || '';
        toast.hideDelay = OPTIONS.hideDelay || this.defaults.hideDelay;
        toast.link = OPTIONS.link || '';
        toast.isCloseable = OPTIONS.isCloseable || false;
        const /** @type {?} */ CUSTOM_CLASS = OPTIONS.customClass || '';
        const /** @type {?} */ ALERT_STYLE = OPTIONS.theme || this.defaults.theme;
        const /** @type {?} */ ALERT_POSITION = OPTIONS.position || this.defaults.position;
        const /** @type {?} */ ALERT_ICON = OPTIONS.icon || this.icons.default;
        toast.iconClass = `bhi-${ALERT_ICON}`;
        toast.launched = true;
        toast.alertTheme = `${ALERT_STYLE} ${ALERT_POSITION} ${CUSTOM_CLASS} toast-container launched`;
    }
    /**
     * @param {?} toast
     * @return {?}
     */
    show(toast) {
        toast.show = true;
        setTimeout(addClass, 25);
        /**
         * Adds animate class to be called after a timeout
         *
         * @return {?}
         */
        function addClass() {
            toast.animate = true;
        }
    }
    /**
     * @param {?} toast
     * @return {?}
     */
    toastTimer(toast) {
        if (toast.hideDelay < 0) {
            return;
        }
        setTimeout(() => {
            this.hide(toast);
        }, toast.hideDelay);
    }
}
NovoToastService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
NovoToastService.ctorParameters = () => [
    { type: ComponentUtils, },
];

// NG2
// APP
class NovoModalService {
    /**
     * @param {?} componentUtils
     */
    constructor(componentUtils) {
        this.componentUtils = componentUtils;
        this._parentViewContainer = null;
    }
    /**
     * @param {?} view
     * @return {?}
     */
    set parentViewContainer(view) {
        this._parentViewContainer = view;
    }
    /**
     * @param {?} component
     * @param {?=} scope
     * @return {?}
     */
    open(component, scope = {}) {
        if (!this._parentViewContainer) {
            console.error('No parent view container specified for the ModalService. Set it inside your main application. \nthis.modalService.parentViewContainer = view (ViewContainerRef)');
            return null;
        }
        const /** @type {?} */ modal = new NovoModalRef();
        modal.component = component;
        modal.open();
        let /** @type {?} */ bindings = ReflectiveInjector.resolve([
            { provide: NovoModalRef, useValue: modal },
            { provide: NovoModalParams, useValue: scope }
        ]);
        modal.containerRef = this.componentUtils.appendNextToLocation(NovoModalContainerElement, this._parentViewContainer, bindings);
        return modal;
    }
}
NovoModalService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
NovoModalService.ctorParameters = () => [
    { type: ComponentUtils, },
];

// NG2
// APP
class ControlConfirmModal {
    /**
     * @param {?} modalRef
     * @param {?} params
     * @param {?} labels
     */
    constructor(modalRef, params, labels) {
        this.modalRef = modalRef;
        this.params = params;
        this.labels = labels;
    }
    /**
     * @param {?} result
     * @return {?}
     */
    close(result) {
        this.modalRef.close(result);
    }
}
ControlConfirmModal.decorators = [
    { type: Component, args: [{
                selector: 'control-confirm-modal',
                template: `
        <novo-notification type="warning" [attr.data-automation-id]="'field-interaction-modal-' + params['key']">
            <h1>{{ labels.confirmChangesModalMessage }}</h1>
            <h2 *ngIf="!params['message']"><label>{{ params['label'] }}:</label> {{ params['oldValue'] }} <i class="bhi-arrow-right"></i> {{ params['newValue'] }}</h2>
            <h2 *ngIf="params['message']">{{ params['message'] }}</h2>
            <button theme="standard" (click)="close(false)" [attr.data-automation-id]="'field-interaction-modal-cancel' + params['key']">{{ labels.cancel }}</button>
            <button theme="primary" icon="check" (click)="close(true)" autofocus [attr.data-automation-id]="'field-interaction-modal-save-' + params['key']">{{ labels.save }}</button>
        </novo-notification>
    `
            },] },
];
/**
 * @nocollapse
 */
ControlConfirmModal.ctorParameters = () => [
    { type: NovoModalRef, },
    { type: NovoModalParams, },
    { type: NovoLabelService, },
];
class ControlPromptModal {
    /**
     * @param {?} modalRef
     * @param {?} params
     * @param {?} labels
     */
    constructor(modalRef, params, labels) {
        this.modalRef = modalRef;
        this.params = params;
        this.labels = labels;
    }
    /**
     * @param {?} result
     * @return {?}
     */
    close(result) {
        this.modalRef.close(result);
    }
}
ControlPromptModal.decorators = [
    { type: Component, args: [{
                selector: 'control-prompt-modal',
                template: `
        <novo-notification type="warning" [attr.data-automation-id]="'field-interaction-modal-' + params['key']">
            <h1>{{ labels.promptModalMessage }}</h1>
            <p *ngFor="let change of params['changes']">{{ change }}</p>
            <button theme="standard" (click)="close(false)" [attr.data-automation-id]="'field-interaction-modal-cancel' + params['key']">{{ labels.cancel }}</button>
            <button theme="primary" icon="check" (click)="close(true)" autofocus [attr.data-automation-id]="'field-interaction-modal-yes-' + params['key']">{{ labels.yes }}</button>
        </novo-notification>
    `
            },] },
];
/**
 * @nocollapse
 */
ControlPromptModal.ctorParameters = () => [
    { type: NovoModalRef, },
    { type: NovoModalParams, },
    { type: NovoLabelService, },
];

// NG2
// Vendor
// APP
class FieldInteractionApi {
    /**
     * @param {?} toaster
     * @param {?} modalService
     * @param {?} formUtils
     * @param {?} http
     * @param {?} labels
     */
    constructor(toaster, modalService, formUtils, http$$1, labels) {
        this.toaster = toaster;
        this.modalService = modalService;
        this.formUtils = formUtils;
        this.http = http$$1;
        this.labels = labels;
    }
    /**
     * @param {?} form
     * @return {?}
     */
    set form(form) {
        this._form = form;
    }
    /**
     * @return {?}
     */
    get form() {
        return this._form;
    }
    /**
     * @return {?}
     */
    get associations() {
        return this.form.hasOwnProperty('associations') ? this.form.associations : {};
    }
    /**
     * @return {?}
     */
    get currentEntity() {
        return this.form.hasOwnProperty('currentEntity') ? this.form.currentEntity : undefined;
    }
    /**
     * @return {?}
     */
    get currentEntityId() {
        return this.form.hasOwnProperty('currentEntityId') ? this.form.currentEntityId : undefined;
    }
    /**
     * @return {?}
     */
    get isEdit() {
        return this.form.hasOwnProperty('edit') ? this.form.edit : false;
    }
    /**
     * @return {?}
     */
    get isAdd() {
        return this.form.hasOwnProperty('edit') ? !this.form.edit : false;
    }
    /**
     * @param {?} globals
     * @return {?}
     */
    set globals(globals) {
        this._globals = globals;
    }
    /**
     * @return {?}
     */
    get globals() {
        return this._globals;
    }
    /**
     * @param {?} key
     * @return {?}
     */
    set currentKey(key) {
        this._currentKey = key;
    }
    /**
     * @return {?}
     */
    get currentKey() {
        return this._currentKey;
    }
    /**
     * @param {?} appBridge
     * @return {?}
     */
    set appBridge(appBridge) {
        this._appBridge = appBridge;
    }
    /**
     * @return {?}
     */
    get appBridge() {
        return this._appBridge;
    }
    /**
     * @return {?}
     */
    isActiveControlValid() {
        return !!this.getValue(this.currentKey);
    }
    /**
     * @return {?}
     */
    getActiveControl() {
        return this.getControl(this.currentKey);
    }
    /**
     * @return {?}
     */
    getActiveKey() {
        return this.currentKey;
    }
    /**
     * @return {?}
     */
    getActiveValue() {
        return this.getValue(this.currentKey);
    }
    /**
     * @return {?}
     */
    getActiveInitialValue() {
        return this.getInitialValue(this.currentKey);
    }
    /**
     * @param {?} key
     * @return {?}
     */
    getControl(key) {
        if (!key) {
            console.error('[FieldInteractionAPI] - invalid or missing "key"'); // tslint:disable-line
            return null;
        }
        let /** @type {?} */ control = this.form.controls[key];
        if (!control) {
            console.error('[FieldInteractionAPI] - could not find a control in the form by the key --', key); // tslint:disable-line
            return null;
        }
        return ((control));
    }
    /**
     * @param {?} key
     * @return {?}
     */
    getValue(key) {
        let /** @type {?} */ control = this.getControl(key);
        if (control) {
            return control.value;
        }
        return null;
    }
    /**
     * @param {?} key
     * @return {?}
     */
    getRawValue(key) {
        let /** @type {?} */ control = this.getControl(key);
        if (control) {
            return control.rawValue;
        }
        return null;
    }
    /**
     * @param {?} key
     * @return {?}
     */
    getInitialValue(key) {
        let /** @type {?} */ control = this.getControl(key);
        if (control) {
            return control.initialValue;
        }
        return null;
    }
    /**
     * @param {?} key
     * @param {?} value
     * @param {?=} options
     * @return {?}
     */
    setValue(key, value, options) {
        let /** @type {?} */ control = this.getControl(key);
        if (control) {
            control.setValue(value, options);
        }
    }
    /**
     * @param {?} key
     * @param {?} value
     * @param {?=} options
     * @return {?}
     */
    patchValue(key, value, options) {
        let /** @type {?} */ control = this.getControl(key);
        if (control) {
            control.setValue(value, options);
        }
    }
    /**
     * @param {?} key
     * @param {?} isReadOnly
     * @return {?}
     */
    setReadOnly(key, isReadOnly) {
        let /** @type {?} */ control = this.getControl(key);
        if (control) {
            control.setReadOnly(isReadOnly);
        }
    }
    /**
     * @param {?} key
     * @param {?} required
     * @return {?}
     */
    setRequired(key, required) {
        let /** @type {?} */ control = this.getControl(key);
        if (control) {
            control.setRequired(required);
        }
    }
    /**
     * @param {?} key
     * @param {?=} clearValue
     * @return {?}
     */
    hide(key, clearValue = true) {
        let /** @type {?} */ control = this.getControl(key);
        if (control) {
            control.hide(clearValue);
            this.disable(key, { emitEvent: false });
        }
    }
    /**
     * @param {?} key
     * @return {?}
     */
    show(key) {
        let /** @type {?} */ control = this.getControl(key);
        if (control) {
            control.show();
            this.enable(key, { emitEvent: false });
        }
    }
    /**
     * @param {?} key
     * @param {?=} options
     * @return {?}
     */
    disable(key, options) {
        let /** @type {?} */ control = this.getControl(key);
        if (control) {
            control.disable(options);
        }
    }
    /**
     * @param {?} key
     * @param {?=} options
     * @return {?}
     */
    enable(key, options) {
        let /** @type {?} */ control = this.getControl(key);
        if (control) {
            control.enable(options);
        }
    }
    /**
     * @param {?} key
     * @param {?=} validationMessage
     * @return {?}
     */
    markAsInvalid(key, validationMessage) {
        let /** @type {?} */ control = this.getControl(key);
        if (control) {
            if (control) {
                control.markAsInvalid(validationMessage);
            }
        }
    }
    /**
     * @param {?} key
     * @param {?=} options
     * @return {?}
     */
    markAsDirty(key, options) {
        let /** @type {?} */ control = this.getControl(key);
        if (control) {
            control.markAsDirty(options);
        }
    }
    /**
     * @param {?} key
     * @param {?=} options
     * @return {?}
     */
    markAsPending(key, options) {
        let /** @type {?} */ control = this.getControl(key);
        if (control) {
            control.markAsPending(options);
        }
    }
    /**
     * @param {?} key
     * @param {?=} options
     * @return {?}
     */
    markAsPristine(key, options) {
        let /** @type {?} */ control = this.getControl(key);
        if (control) {
            control.markAsPristine(options);
        }
    }
    /**
     * @param {?} key
     * @param {?=} options
     * @return {?}
     */
    markAsTouched(key, options) {
        let /** @type {?} */ control = this.getControl(key);
        if (control) {
            control.markAsTouched(options);
        }
    }
    /**
     * @param {?} key
     * @param {?=} options
     * @return {?}
     */
    markAsUntouched(key, options) {
        let /** @type {?} */ control = this.getControl(key);
        if (control) {
            control.markAsUntouched(options);
        }
    }
    /**
     * @param {?} key
     * @param {?=} options
     * @return {?}
     */
    updateValueAndValidity(key, options) {
        let /** @type {?} */ control = this.getControl(key);
        if (control) {
            control.updateValueAndValidity(options);
        }
    }
    /**
     * @param {?} toastConfig
     * @return {?}
     */
    displayToast(toastConfig) {
        if (this.toaster) {
            this.toaster.alert(toastConfig);
        }
    }
    /**
     * @param {?} key
     * @param {?} tip
     * @param {?=} icon
     * @param {?=} allowDismiss
     * @return {?}
     */
    displayTip(key, tip, icon, allowDismiss) {
        let /** @type {?} */ control = this.getControl(key);
        if (control) {
            control.tipWell = {
                tip: tip,
                icon: icon,
                button: allowDismiss
            };
        }
    }
    /**
     * @param {?} key
     * @param {?=} message
     * @return {?}
     */
    confirmChanges(key, message) {
        let /** @type {?} */ history = this.getProperty(key, 'valueHistory');
        let /** @type {?} */ oldValue = history[history.length - 2];
        let /** @type {?} */ newValue = this.getValue(key);
        let /** @type {?} */ label = this.getProperty(key, 'label');
        ((document.activeElement)).blur();
        return this.modalService.open(ControlConfirmModal, { oldValue, newValue, label, message, key }).onClosed.then(result => {
            if (!result) {
                this.setValue(key, oldValue, { emitEvent: false });
            }
        });
    }
    /**
     * @param {?} key
     * @param {?} changes
     * @return {?}
     */
    promptUser(key, changes) {
        ((document.activeElement)).blur();
        return this.modalService.open(ControlPromptModal, { changes }).onClosed;
    }
    /**
     * @param {?} key
     * @param {?} prop
     * @param {?} value
     * @return {?}
     */
    setProperty(key, prop, value) {
        let /** @type {?} */ control = this.getControl(key);
        if (control) {
            control[prop] = value;
        }
    }
    /**
     * @param {?} key
     * @param {?} prop
     * @return {?}
     */
    getProperty(key, prop) {
        let /** @type {?} */ control = this.getControl(key);
        if (control) {
            return control[prop];
        }
        return null;
    }
    /**
     * @param {?} key
     * @return {?}
     */
    isValueEmpty(key) {
        let /** @type {?} */ value = this.getValue(key);
        return Helpers.isEmpty(value);
    }
    /**
     * @param {?} key
     * @return {?}
     */
    isValueBlank(key) {
        let /** @type {?} */ value = this.getValue(key);
        return Helpers.isBlank(value);
    }
    /**
     * @param {?} key
     * @return {?}
     */
    hasField(key) {
        return !!this.form.controls[key];
    }
    /**
     * @param {?} key
     * @param {?} newOption
     * @return {?}
     */
    addStaticOption(key, newOption) {
        let /** @type {?} */ control = this.getControl(key);
        let /** @type {?} */ optionToAdd = newOption;
        if (control) {
            let /** @type {?} */ currentOptions = this.getProperty(key, 'options');
            if (!currentOptions || !currentOptions.length) {
                let /** @type {?} */ config = this.getProperty(key, 'config');
                if (config) {
                    currentOptions = config.options;
                    if (currentOptions && Array.isArray(currentOptions)) {
                        if (currentOptions[0].value && !optionToAdd.value) {
                            optionToAdd = { value: newOption, label: newOption };
                        }
                        config.options = [...currentOptions, optionToAdd];
                        this.setProperty(key, 'config', config);
                    }
                }
            }
            else {
                if (currentOptions[0].value && !optionToAdd.value) {
                    optionToAdd = { value: newOption, label: newOption };
                }
                this.setProperty(key, 'options', [...currentOptions, optionToAdd]);
            }
        }
    }
    /**
     * @param {?} key
     * @param {?} optionToRemove
     * @return {?}
     */
    removeStaticOption(key, optionToRemove) {
        let /** @type {?} */ control = this.getControl(key);
        if (control) {
            let /** @type {?} */ currentOptions = this.getProperty(key, 'options');
            if (!currentOptions || !currentOptions.length) {
                let /** @type {?} */ config = this.getProperty(key, 'config');
                if (config) {
                    currentOptions = config.options;
                    if (currentOptions && Array.isArray(currentOptions)) {
                        let /** @type {?} */ index = -1;
                        currentOptions.forEach((opt, i) => {
                            if (opt.value || opt.label) {
                                if (opt.value === optionToRemove || opt.label === optionToRemove) {
                                    index = i;
                                }
                            }
                            else {
                                if (opt === optionToRemove) {
                                    index = i;
                                }
                            }
                        });
                        if (index !== -1) {
                            currentOptions.splice(index, 1);
                        }
                        config.options = [...currentOptions];
                        this.setProperty(key, 'config', config);
                    }
                }
            }
            else {
                let /** @type {?} */ index = -1;
                currentOptions.forEach((opt, i) => {
                    if (opt.value || opt.label) {
                        if (opt.value === optionToRemove || opt.label === optionToRemove) {
                            index = i;
                        }
                    }
                    else {
                        if (opt === optionToRemove) {
                            index = i;
                        }
                    }
                });
                if (index !== -1) {
                    currentOptions.splice(index, 1);
                }
                this.setProperty(key, 'options', [...currentOptions]);
            }
        }
    }
    /**
     * @param {?} key
     * @param {?} config
     * @param {?=} mapper
     * @return {?}
     */
    modifyPickerConfig(key, config, mapper) {
        let /** @type {?} */ control = this.getControl(key);
        if (control) {
            let /** @type {?} */ newConfig = Object.assign({}, control.config);
            if (config.optionsUrl || config.optionsUrlBuilder || config.optionsPromise) {
                newConfig = {
                    format: config.format,
                    options: (query) => {
                        if (config.optionsPromise) {
                            return config.optionsPromise(query, this.http);
                        }
                        return new Promise((resolve, reject) => {
                            let /** @type {?} */ url = config.optionsUrlBuilder ? config.optionsUrlBuilder(query) : `${config.optionsUrl}?filter=${query || ''}`;
                            if (query && query.length) {
                                this.http
                                    .get(url)
                                    .map(res => {
                                    if (res.json) {
                                        return res.json();
                                    }
                                    return res;
                                })
                                    .map(results => {
                                    if (mapper) {
                                        return results.map(mapper);
                                    }
                                    return results;
                                })
                                    .subscribe(resolve, reject);
                            }
                            else {
                                resolve([]);
                            }
                        });
                    }
                };
            }
            else if (config.options) {
                newConfig.options = [...config.options];
            }
            this.setProperty(key, 'config', newConfig);
        }
    }
    /**
     * @param {?} key
     * @param {?} loading
     * @return {?}
     */
    setLoading(key, loading) {
        let /** @type {?} */ control = this.getControl(key);
        if (control) {
            if (loading) {
                this.form.controls[key].fieldInteractionloading = true;
                control.setErrors({ 'loading': true });
                // History
                clearTimeout(this.asyncBlockTimeout);
                this.asyncBlockTimeout = setTimeout(() => {
                    this.setLoading(key, false);
                    this.displayTip(key, this.labels.asyncFailure, 'info', false);
                    this.setProperty(key, '_displayedAsyncFailure', true);
                }, 10000);
            }
            else {
                this.form.controls[key].fieldInteractionloading = false;
                clearTimeout(this.asyncBlockTimeout);
                control.setErrors({ 'loading': null });
                control.updateValueAndValidity({ emitEvent: false });
                if (this.getProperty(key, '_displayedAsyncFailure')) {
                    this.setProperty(key, 'tipWell', null);
                }
            }
        }
    }
    /**
     * @param {?} key
     * @param {?} metaForNewField
     * @param {?=} position
     * @param {?=} initialValue
     * @return {?}
     */
    addControl(key, metaForNewField, position = FieldInteractionApi.FIELD_POSITIONS.ABOVE_FIELD, initialValue) {
        if (!metaForNewField.key && !metaForNewField.name) {
            console.error('[FieldInteractionAPI] - missing "key" in meta for new field'); // tslint:disable-line
            return null;
        }
        if (!metaForNewField.key) {
            // If key is not explicitly declared, use name as key
            metaForNewField.key = metaForNewField.name;
        }
        if (this.form.controls[metaForNewField.key]) {
            // Field is already on the form
            return null;
        }
        let /** @type {?} */ control = this.form.controls[key];
        let /** @type {?} */ fieldsetIndex, /** @type {?} */ controlIndex;
        if (control) {
            fieldsetIndex = -1;
            controlIndex = -1;
            this.form.fieldsets.forEach((fieldset, fi) => {
                fieldset.controls.forEach((fieldsetControl, ci) => {
                    if (fieldsetControl.key === key) {
                        fieldsetIndex = fi;
                        controlIndex = ci;
                    }
                });
            });
            // Change the position of the newly added field
            switch (position) {
                case FieldInteractionApi.FIELD_POSITIONS.ABOVE_FIELD:
                    // Adding field above active field
                    // index can stay the same
                    break;
                case FieldInteractionApi.FIELD_POSITIONS.BELOW_FIELD:
                    // Adding field below active field
                    controlIndex += 1;
                    break;
                case FieldInteractionApi.FIELD_POSITIONS.TOP_OF_FORM:
                    // Adding field to the top of the form
                    controlIndex = 0;
                    fieldsetIndex = 0;
                    break;
                case FieldInteractionApi.FIELD_POSITIONS.BOTTOM_OF_FORM:
                    // Adding field to the bottom of the form
                    fieldsetIndex = this.form.fieldsets.length - 1;
                    controlIndex = this.form.fieldsets[fieldsetIndex].controls.length;
                    break;
                default:
                    break;
            }
            if (fieldsetIndex !== -1 && controlIndex !== -1) {
                let /** @type {?} */ novoControl = this.formUtils.getControlForField(metaForNewField, this.http, {});
                novoControl.hidden = false;
                let /** @type {?} */ formControl = new NovoFormControl(initialValue, novoControl);
                this.form.addControl(novoControl.key, formControl);
                this.form.fieldsets[fieldsetIndex].controls.splice(controlIndex, 0, novoControl);
            }
        }
    }
    /**
     * @param {?} key
     * @return {?}
     */
    removeControl(key) {
        if (!this.form.controls[key]) {
            // Field is not on the form
            return null;
        }
        let /** @type {?} */ control = this.getControl(key);
        if (control) {
            let /** @type {?} */ fieldsetIndex = -1;
            let /** @type {?} */ controlIndex = -1;
            this.form.fieldsets.forEach((fieldset, fi) => {
                fieldset.controls.forEach((fieldsetControl, ci) => {
                    if (fieldsetControl.key === key) {
                        fieldsetIndex = fi;
                        controlIndex = ci;
                    }
                });
            });
            if (fieldsetIndex !== -1 && controlIndex !== -1) {
                this.form.removeControl(key);
                this.form.fieldsets[fieldsetIndex].controls.splice(controlIndex, 1);
            }
        }
    }
    /**
     * @param {?} func
     * @param {?=} wait
     * @return {?}
     */
    debounce(func, wait = 50) {
        let /** @type {?} */ h;
        clearTimeout(h);
        h = setTimeout(() => func(), wait);
    }
}
FieldInteractionApi.FIELD_POSITIONS = {
    ABOVE_FIELD: 'ABOVE_FIELD',
    BELOW_FIELD: 'BELOW_FIELD',
    TOP_OF_FORM: 'TOP_OF_FORM',
    BOTTOM_OF_FORM: 'BOTTOM_OF_FORM'
};
FieldInteractionApi.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
FieldInteractionApi.ctorParameters = () => [
    { type: NovoToastService, },
    { type: NovoModalService, },
    { type: FormUtils, },
    { type: Http, },
    { type: NovoLabelService, },
];

// NG2

class NovoAutoSize {
    /**
     * @param {?} element
     */
    constructor(element) {
        this.element = element;
    }
    /**
     * @param {?} textArea
     * @return {?}
     */
    onInput(textArea) {
        this.adjust();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        setTimeout(() => {
            this.adjust();
        });
    }
    /**
     * @return {?}
     */
    adjust() {
        let /** @type {?} */ hasValue = this.element.nativeElement.value.length !== 0;
        this.element.nativeElement.style.overflow = 'hidden';
        if (hasValue) {
            this.element.nativeElement.style.height = Math.min((this.element.nativeElement.scrollHeight - 11), 300) + 'px';
        }
        else {
            this.element.nativeElement.style.height = '14px';
        }
    }
}
NovoAutoSize.decorators = [
    { type: Directive, args: [{
                selector: 'textarea[autosize]'
            },] },
];
/**
 * @nocollapse
 */
NovoAutoSize.ctorParameters = () => [
    { type: ElementRef, },
];
NovoAutoSize.propDecorators = {
    'onInput': [{ type: HostListener, args: ['input', ['$event.target'],] },],
};
class NovoCustomControlContainerElement {
}
NovoCustomControlContainerElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-custom-control-container',
                template: `
        <div class="novo-control-container" [hidden]="form.controls[control.key].hidden || form.controls[control.key].type === 'hidden' || form.controls[control.key].controlType === 'hidden'">
            <!--Label (for horizontal)-->
            <label [attr.for]="control.key" *ngIf="form.layout !== 'vertical' && form.controls[control.key].label">{{ form.controls[control.key].label }}</label>
            <div class="novo-control-outer-container">
                <!--Label (for vertical)-->
                <label
                    *ngIf="form.layout === 'vertical' && form.controls[control.key].label"
                    class="novo-control-label"
                    [attr.for]="control.key"
                    [class.novo-control-always-active]="true">
                    {{ form.controls[control.key].label }}
                </label>
                <div class="novo-control-inner-container">
                    <div class="novo-control-inner-input-container">
                        <!--Required Indicator-->
                        <i [hidden]="!form.controls[control.key].required || form.controls[control.key].readOnly"
                            class="required-indicator"
                            [ngClass]="{'bhi-circle': !isValid, 'bhi-check': isValid}" *ngIf="form.controls[control.key].required">
                        </i>
                        <!--Form Controls-->
                        <div class="novo-control-input {{ form.controls[control.key].controlType }}" [attr.data-automation-id]="control.key">
                            <ng-content></ng-content>
                        </div>
                    </div>
                    <!--Error Message-->
                    <div class="field-message">
                        <div class="messages">
                            <span class="error-text" *ngIf="(form.controls[control.key].dirty || control.dirty) && form.controls[control.key].errors?.required">{{ form.controls[control.key].label | uppercase }} is required</span>
                            <span class="error-text" *ngIf="(form.controls[control.key].dirty || control.dirty) && (form.controls[control.key].errors?.custom)">{{ form.controls[control.key].errors.custom }}</span>
                            <!--Field Hint-->
                            <span class="description" *ngIf="form.controls[control.key].description">
                                {{ form.controls[control.key].description }}
                            </span>
                        </div>
                    </div>
                    <!--Tip Wel-->
                    <novo-tip-well *ngIf="form.controls[control.key].tipWell" [name]="control.key" [tip]="form.controls[control.key]?.tipWell?.tip" [icon]="form.controls[control.key]?.tipWell?.icon" [button]="form.controls[control.key]?.tipWell?.button"></novo-tip-well>
                </div>
            </div>
        </div>
    `
            },] },
];
/**
 * @nocollapse
 */
NovoCustomControlContainerElement.ctorParameters = () => [];
NovoCustomControlContainerElement.propDecorators = {
    'control': [{ type: Input },],
    'form': [{ type: Input },],
};
class NovoControlElement extends OutsideClick {
    /**
     * @param {?} element
     * @param {?} labels
     * @param {?} dateFormatService
     * @param {?} fieldInteractionApi
     */
    constructor(element, labels, dateFormatService, fieldInteractionApi) {
        super(element);
        this.labels = labels;
        this.dateFormatService = dateFormatService;
        this.fieldInteractionApi = fieldInteractionApi;
        this.condensed = false;
        this.change = new EventEmitter();
        this._blurEmitter = new EventEmitter();
        this._focusEmitter = new EventEmitter();
        this._focused = false;
        this._enteredText = '';
        this.formattedValue = '';
        this.maxLengthMet = false;
        this.characterCount = 0;
    }
    /**
     * @return {?}
     */
    get onBlur() {
        return this._blurEmitter.asObservable();
    }
    /**
     * @return {?}
     */
    get onFocus() {
        return this._focusEmitter.asObservable();
    }
    /**
     * @return {?}
     */
    get showFieldMessage() {
        return !this.errors && !this.maxLengthMet && Helpers.isBlank(this.control.description);
    }
    /**
     * @return {?}
     */
    get showCount() {
        return this.form.controls[this.control.key].maxlength && this.focused && (this.form.controls[this.control.key].controlType === 'text-area' || this.form.controls[this.control.key].controlType === 'textbox');
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // Make sure to initially format the time controls
        if (this.control && this.form.controls[this.control.key].value) {
            if (this.form.controls[this.control.key].controlType === 'textbox' || this.form.controls[this.control.key].controlType === 'text-area') {
                this.characterCount = this.form.controls[this.control.key].value.length;
            }
        }
        if (this.control) {
            // Listen to clear events
            this.forceClearSubscription = this.control.forceClear.subscribe(() => {
                this.clearValue();
            });
            // Subscribe to control interactions
            if (this.control.interactions) {
                for (let /** @type {?} */ interaction of this.control.interactions) {
                    switch (interaction.event) {
                        case 'blur':
                            this.valueChangeSubscription = this.onBlur.debounceTime(300).subscribe(() => {
                                this.executeInteraction(interaction);
                            });
                            break;
                        case 'focus':
                            this.valueChangeSubscription = this.onFocus.debounceTime(300).subscribe(() => {
                                this.executeInteraction(interaction);
                            });
                            break;
                        case 'change':
                            this.valueChangeSubscription = this.form.controls[this.control.key].valueChanges.debounceTime(300).subscribe(() => {
                                this.executeInteraction(interaction);
                            });
                            break;
                        case 'init':
                            interaction.invokeOnInit = true;
                            break;
                        default:
                            break;
                    }
                    if (interaction.invokeOnInit) {
                        this.executeInteraction(interaction);
                    }
                }
            }
        }
        if (this.form.controls[this.control.key] && this.form.controls[this.control.key].subType === 'percentage') {
            if (!Helpers.isEmpty(this.form.controls[this.control.key].value)) {
                this.percentValue = Number((this.form.controls[this.control.key].value * 100).toFixed(6).replace(/\.?0*$/, ''));
            }
            this.percentChangeSubscription = this.form.controls[this.control.key].displayValueChanges.subscribe(value => {
                if (!Helpers.isEmpty(value)) {
                    this.percentValue = Number((value * 100).toFixed(6).replace(/\.?0*$/, ''));
                }
            });
        }
    }
    /**
     * @param {?} interaction
     * @return {?}
     */
    executeInteraction(interaction) {
        if (interaction.script && Helpers.isFunction(interaction.script)) {
            setTimeout(() => {
                this.fieldInteractionApi.form = this.form;
                this.fieldInteractionApi.currentKey = this.control.key;
                try {
                    interaction.script(this.fieldInteractionApi, this.control.key);
                }
                catch (err) {
                    console.info('Field Interaction Error!', this.control.key); // tslint:disable-line
                    console.error(err); // tslint:disable-line
                }
            });
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        // Unsubscribe from control interactions
        if (this.valueChangeSubscription) {
            this.valueChangeSubscription.unsubscribe();
        }
        // if (this.dateChangeSubscription) {
        //     this.dateChangeSubscription.unsubscribe();
        // }
        if (this.forceClearSubscription) {
            // Un-listen for clear events
            this.forceClearSubscription.unsubscribe();
        }
        if (this.percentChangeSubscription) {
            // Un-listen for clear events
            this.percentChangeSubscription.unsubscribe();
        }
        if (this.dateChangeSubscription) {
            this.dateChangeSubscription.unsubscribe();
        }
        super.ngOnDestroy();
    }
    /**
     * @return {?}
     */
    get errors() {
        return this.form.controls[this.control.key].errors;
    }
    /**
     * @return {?}
     */
    get isValid() {
        return this.form.controls[this.control.key].valid;
    }
    /**
     * @return {?}
     */
    get isDirty() {
        return this.form.controls[this.control.key].dirty || this.control.dirty;
    }
    /**
     * @return {?}
     */
    get hasValue() {
        return !Helpers.isEmpty(this.form.value[this.control.key]);
    }
    /**
     * @return {?}
     */
    get focused() {
        return this._focused;
    }
    /**
     * @return {?}
     */
    get tooltip() {
        return this.form.controls[this.control.key].tooltip;
    }
    /**
     * @return {?}
     */
    get tooltipPosition() {
        if (Helpers.isBlank(this.form.controls[this.control.key].tooltipPosition)) {
            return 'right';
        }
        return this.form.controls[this.control.key].tooltipPosition;
    }
    /**
     * @return {?}
     */
    get alwaysActive() {
        // Controls that have the label active if there is any user entered text in the field
        if (this.form.controls[this.control.key].controlType === 'picker' && this._enteredText.length) {
            return true;
        }
        // Controls that always have the label active
        return ['tiles', 'checklist', 'checkbox', 'address', 'file', 'editor', 'radio', 'text-area', 'quick-note'].indexOf(this.form.controls[this.control.key].controlType) !== -1;
    }
    /**
     * @return {?}
     */
    get requiresExtraSpacing() {
        // Chips
        if (this.form.controls[this.control.key].controlType === 'picker' && this.form.controls[this.control.key].multiple && this.hasValue) {
            return true;
        }
        return false;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    handleTyping(event) {
        this._focused = event && event.length;
        this._enteredText = event;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    handleFocus(event) {
        this._focused = true;
        this._focusEmitter.emit(event);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    handleBlur(event) {
        this._focused = false;
        this._blurEmitter.emit(event);
    }
    /**
     * @return {?}
     */
    clearValue() {
        this.form.controls[this.control.key].setValue(null);
        this.formattedValue = null;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    handleTextAreaInput(event) {
        this.emitChange(event);
        this.restrictKeys(event);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    checkMaxLength(event) {
        if (this.control && this.form.controls[this.control.key].maxlength) {
            this.characterCount = event.target.value.length;
            this.maxLengthMet = event.target.value.length >= this.form.controls[this.control.key].maxlength;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    modelChangeWithRaw(event) {
        if (Helpers.isEmpty(event.value)) {
            this._focused = false;
            this._enteredText = '';
        }
        this.form.controls[this.control.key].rawValue = event.rawValue;
        this.change.emit(event.value);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    modelChange(value) {
        if (Helpers.isEmpty(value)) {
            this._focused = false;
            this._enteredText = '';
        }
        this.change.emit(value);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    restrictKeys(event) {
        const /** @type {?} */ NUMBERS_ONLY = /[0-9\-]/;
        const /** @type {?} */ NUMBERS_WITH_DECIMAL = /[0-9\.\-]/;
        const /** @type {?} */ UTILITY_KEYS = ['Backspace', 'Delete', 'ArrowLeft', 'ArrowRight', 'Tab'];
        let /** @type {?} */ key = event.key;
        // Types
        if (this.form.controls[this.control.key].subType === 'number' && !(NUMBERS_ONLY.test(key) || UTILITY_KEYS.includes(key))) {
            event.preventDefault();
        }
        else if (~['currency', 'float', 'percentage'].indexOf(this.form.controls[this.control.key].subType) && !(NUMBERS_WITH_DECIMAL.test(key) || UTILITY_KEYS.includes(key))) {
            event.preventDefault();
        }
        // Max Length
        if (this.form.controls[this.control.key].maxlength && event.target.value.length >= this.form.controls[this.control.key].maxlength) {
            event.preventDefault();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    handlePercentChange(event) {
        let /** @type {?} */ value = event.target['value'];
        let /** @type {?} */ percent = Helpers.isEmpty(value) ? null : Number((value / 100).toFixed(6).replace(/\.?0*$/, ''));
        if (!Helpers.isEmpty(percent)) {
            this.change.emit(percent);
            this.form.controls[this.control.key].setValue(percent);
        }
        else {
            this.change.emit(null);
            this.form.controls[this.control.key].setValue(null);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    handleTabForPickers(event) {
        if (this.active && event && event.keyCode) {
            if (event.keyCode === KeyCodes.ESC || event.keyCode === KeyCodes.TAB) {
                this.toggleActive(event, false);
            }
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    emitChange(value) {
        this.change.emit(value);
        this.checkMaxLength(value);
    }
}
NovoControlElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-control',
                template: `
        <div class="novo-control-container" [formGroup]="form" [hidden]="form.controls[control.key].hidden || form.controls[control.key].type === 'hidden' || form.controls[control.key].controlType === 'hidden'">
            <!--Encrypted Field-->
            <span [tooltip]="labels.encryptedFieldTooltip" [tooltipPosition]="'right'"><i [hidden]="!form.controls[control.key].encrypted"
            class="bhi-lock"></i></span>
            <!--Label (for horizontal)-->
            <label [attr.for]="control.key" *ngIf="form.layout !== 'vertical' && form.controls[control.key].label && !condensed" [ngClass]="{'encrypted': form.controls[control.key].encrypted }">
                {{ form.controls[control.key].label }}
            </label>
            <div class="novo-control-outer-container">
                <!--Label (for vertical)-->
                <label
                    *ngIf="form.layout === 'vertical' && form.controls[control.key].label && !condensed"
                    class="novo-control-label"
                    [attr.for]="control.key"
                    [class.novo-control-empty]="!hasValue"
                    [class.novo-control-focused]="focused"
                    [class.novo-control-filled]="hasValue"
                    [class.novo-control-always-active]="alwaysActive || form.controls[control.key].placeholder"
                    [class.novo-control-extra-spacing]="requiresExtraSpacing">
                    {{ form.controls[control.key].label }}
                </label>
                <div class="novo-control-inner-container">
                    <div class="novo-control-inner-input-container">
                        <!--Required Indicator-->
                        <i [hidden]="!form.controls[control.key].required || form.controls[control.key].readOnly"
                            class="required-indicator"
                            [ngClass]="{'bhi-circle': !isValid, 'bhi-check': isValid}" *ngIf="!condensed || form.controls[control.key].required">
                        </i>
                        <!--Form Controls-->
                        <div class="novo-control-input {{ form.controls[control.key].controlType }}" [ngSwitch]="form.controls[control.key].controlType" [attr.data-automation-id]="control.key" [class.control-disabled]="form.controls[control.key].disabled">
                            <!--Text-based Inputs-->
                            <!--TODO prefix/suffix on the control-->
                            <div class="novo-control-input-container novo-control-input-with-label" *ngSwitchCase="'textbox'" [tooltip]="tooltip" [tooltipPosition]="tooltipPosition">
                                <input *ngIf="form.controls[control.key].type !== 'number'" [formControlName]="control.key" [id]="control.key" [type]="form.controls[control.key].type" [placeholder]="form.controls[control.key].placeholder" (input)="emitChange($event)" [maxlength]="form.controls[control.key].maxlength" (focus)="handleFocus($event)" (blur)="handleBlur($event)">
                                <input *ngIf="form.controls[control.key].type === 'number' && form.controls[control.key].subType !== 'percentage'" [formControlName]="control.key" [id]="control.key" [type]="form.controls[control.key].type" [placeholder]="form.controls[control.key].placeholder" (keydown)="restrictKeys($event)" (input)="emitChange($event)" [maxlength]="form.controls[control.key].maxlength" (focus)="handleFocus($event)" (blur)="handleBlur($event)" step="any" (mousewheel)="numberInput.blur()" #numberInput>
                                <input *ngIf="form.controls[control.key].type === 'number' && form.controls[control.key].subType === 'percentage'" [type]="form.controls[control.key].type" [placeholder]="form.controls[control.key].placeholder" (keydown)="restrictKeys($event)" [value]="percentValue" (input)="handlePercentChange($event)" (focus)="handleFocus($event)" (blur)="handleBlur($event)" step="any" (mousewheel)="percentInput.blur()" #percentInput>
                                <label class="input-label" *ngIf="form.controls[control.key].subType === 'currency'">{{ control.currencyFormat }}</label>
                                <label class="input-label" *ngIf="form.controls[control.key].subType === 'percentage'">%</label>
                            </div>
                            <!--TextArea-->
                            <textarea *ngSwitchCase="'text-area'" [name]="control.key" [attr.id]="control.key" [placeholder]="form.controls[control.key].placeholder" [formControlName]="control.key" autosize (input)="handleTextAreaInput($event)" (focus)="handleFocus($event)" (blur)="handleBlur($event)" [maxlength]="control.maxlength" [tooltip]="tooltip" [tooltipPosition]="tooltipPosition"></textarea>
                            <!--Editor-->
                            <novo-editor *ngSwitchCase="'editor'" [name]="control.key" [formControlName]="control.key" [minimal]="control.minimal" (focus)="handleFocus($event)" (blur)="handleBlur($event)"></novo-editor>
                            <!--HTML5 Select-->
                            <select [id]="control.key" *ngSwitchCase="'native-select'" [formControlName]="control.key" [tooltip]="tooltip" [tooltipPosition]="tooltipPosition">
                                <option *ngIf="form.controls[control.key].placeholder" value="" disabled selected hidden>{{ form.controls[control.key].placeholder }}</option>
                                <option *ngFor="let opt of form.controls[control.key].options" [value]="opt.key">{{opt.value}}</option>
                            </select>
                            <!--File-->
                            <novo-file-input *ngSwitchCase="'file'" [formControlName]="control.key" [id]="control.key" [name]="control.key" [placeholder]="form.controls[control.key].placeholder" [value]="form.controls[control.key].value" [multiple]="form.controls[control.key].multiple" [layoutOptions]="form.controls[control.key].layoutOptions" [tooltip]="tooltip" [tooltipPosition]="tooltipPosition"></novo-file-input>
                            <!--Tiles-->
                            <novo-tiles *ngSwitchCase="'tiles'" [options]="control.options" [formControlName]="control.key" (onChange)="modelChange($event)" [tooltip]="tooltip" [tooltipPosition]="tooltipPosition"></novo-tiles>
                            <!--Picker-->
                            <div class="novo-control-input-container" *ngSwitchCase="'picker'">
                                <novo-picker [config]="form.controls[control.key].config" [formControlName]="control.key" [placeholder]="form.controls[control.key].placeholder" [parentScrollSelector]="form.controls[control.key].parentScrollSelector" *ngIf="!form.controls[control.key].multiple" (select)="modelChange($event);" (changed)="modelChangeWithRaw($event)" (typing)="handleTyping($event)" (focus)="handleFocus($event)" (blur)="handleBlur($event)" [tooltip]="tooltip" [tooltipPosition]="tooltipPosition"></novo-picker>
                                <chips [source]="form.controls[control.key].config" [type]="form.controls[control.key].config.type" [formControlName]="control.key" [placeholder]="form.controls[control.key].placeholder" *ngIf="control.multiple" [closeOnSelect]="form.controls[control.key].closeOnSelect" (changed)="modelChangeWithRaw($event)" (typing)="handleTyping($event)" (focus)="handleFocus($event)" (blur)="handleBlur($event)" [tooltip]="tooltip" [tooltipPosition]="tooltipPosition"></chips>
                            </div>
                            <!--Novo Select-->
                            <novo-select *ngSwitchCase="'select'" [options]="form.controls[control.key].options" [headerConfig]="form.controls[control.key].headerConfig" [placeholder]="form.controls[control.key].placeholder" [formControlName]="control.key" [tooltip]="tooltip" [tooltipPosition]="tooltipPosition" (onSelect)="modelChange($event)"></novo-select>
                            <!--Radio-->
                            <div class="novo-control-input-container" *ngSwitchCase="'radio'">
                                <novo-radio [vertical]="vertical" [name]="control.key" [formControlName]="control.key" *ngFor="let option of form.controls[control.key].options" [value]="option.value" [label]="option.label" [checked]="option.value === form.value[control.key]" [tooltip]="tooltip" [tooltipPosition]="tooltipPosition" [button]="!!option.icon" [icon]="option.icon" [attr.data-automation-id]="control.key + '-' + (option?.label || option?.value)"></novo-radio>
                            </div>
                            <!--Time-->
                            <div class="novo-control-input-container" *ngSwitchCase="'time'" [tooltip]="tooltip" [tooltipPosition]="tooltipPosition">
                                <novo-time-picker-input [attr.id]="control.key" [name]="control.key" [formControlName]="control.key" [placeholder]="form.controls[control.key].placeholder" [military]="form.controls[control.key].military"></novo-time-picker-input>
                            </div>
                            <!--Date-->
                            <div class="novo-control-input-container" *ngSwitchCase="'date'" [tooltip]="tooltip" [tooltipPosition]="tooltipPosition">
                                <novo-date-picker-input [attr.id]="control.key" [name]="control.key" [formControlName]="control.key" [placeholder]="form.controls[control.key].placeholder"></novo-date-picker-input>
                            </div>
                            <!--Date and Time-->
                            <div class="novo-control-input-container" *ngSwitchCase="'date-time'" [tooltip]="tooltip" [tooltipPosition]="tooltipPosition">
                                <novo-date-time-picker-input [attr.id]="control.key" [name]="control.key" [formControlName]="control.key" [placeholder]="form.controls[control.key].placeholder" [military]="form.controls[control.key].military"></novo-date-time-picker-input>
                            </div>
                            <!--Address-->
                            <novo-address *ngSwitchCase="'address'" [formControlName]="control.key"></novo-address>
                            <!--Checkbox-->
                            <novo-checkbox *ngSwitchCase="'checkbox'" [formControlName]="control.key" [name]="control.key" [label]="control.checkboxLabel" [tooltip]="tooltip" [tooltipPosition]="tooltipPosition" [layoutOptions]="layoutOptions"></novo-checkbox>
                            <!--Checklist-->
                            <novo-check-list *ngSwitchCase="'checklist'" [formControlName]="control.key" [name]="control.key" [options]="form.controls[control.key].options" [tooltip]="tooltip" [tooltipPosition]="tooltipPosition" (onSelect)="modelChange($event)"></novo-check-list>
                            <!--QuickNote-->
                            <novo-quick-note *ngSwitchCase="'quick-note'" [formControlName]="control.key" [placeholder]="form.controls[control.key].placeholder" [config]="form.controls[control.key].config" (change)="modelChange($event)" [tooltip]="tooltip" [tooltipPosition]="tooltipPosition"></novo-quick-note>
                            <!--ReadOnly-->
                            <!--TODO - Handle rendering of different READONLY values-->
                            <div *ngSwitchCase="'read-only'">{{ form.value[control.key] }}</div>
                        </div>
                    </div>
                    <!--Error Message-->
                    <div class="field-message" *ngIf="!condensed" [class.has-tip]="form.controls[control.key].tipWell">
                        <div class="messages">
                            <span class="error-text" *ngIf="showFieldMessage"></span>
                            <span class="error-text" *ngIf="isDirty && errors?.required">{{ form.controls[control.key].label | uppercase }} {{ labels.isRequired }}</span>
                            <span class="error-text" *ngIf="isDirty && errors?.minlength">{{ form.controls[control.key].label | uppercase }} {{ labels.minLength }} {{ form.controls[control.key].minlength }}</span>
                            <span class="error-text" *ngIf="isDirty && maxLengthMet && focused && !errors?.maxlength">{{ labels.maxLengthMet }}({{ form.controls[control.key].maxlength }})</span>
                            <span class="error-text" *ngIf="errors?.maxlength">{{ labels.invalidMaxLength }}({{ form.controls[control.key].maxlength }})</span>
                            <span class="error-text" *ngIf="isDirty && errors?.invalidEmail">{{ form.controls[control.key].label | uppercase }} {{ labels.invalidEmail }}</span>
                            <span class="error-text" *ngIf="isDirty && errors?.invalidAddress">{{ form.controls[control.key].label | uppercase }} {{ labels.invalidAddress }}</span>
                            <span class="error-text" *ngIf="isDirty && (errors?.integerTooLarge || errors?.doubleTooLarge)">{{ form.controls[control.key].label | uppercase }} {{ labels.isTooLarge }}</span>
                            <span *ngIf="isDirty && errors?.minYear">{{ form.controls[control.key].label | uppercase }} {{ labels.notValidYear }}</span>
                            <span class="error-text" *ngIf="isDirty && (errors?.custom)">{{ errors.custom }}</span>
                            <!--Field Hint-->
                            <span class="description" *ngIf="form.controls[control.key].description">
                                {{ form.controls[control.key].description }}
                            </span>
                        </div>
                        <span class="character-count" [class.error]="errors?.maxlength" *ngIf="showCount">{{ characterCount }}/{{ form.controls[control.key].maxlength }}</span>
                    </div>
                    <!--Tip Wel-->
                    <novo-tip-well *ngIf="form.controls[control.key].tipWell" [name]="control.key" [tip]="form.controls[control.key]?.tipWell?.tip" [icon]="form.controls[control.key]?.tipWell?.icon" [button]="form.controls[control.key]?.tipWell?.button"></novo-tip-well>
                </div>
                <i *ngIf="form.controls[control.key].fieldInteractionloading" class="loading">
                    <svg version="1.1"
                     xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:a="http://ns.adobe.com/AdobeSVGViewerExtensions/3.0/"
                     x="0px" y="0px" width="18.2px" height="18.5px" viewBox="0 0 18.2 18.5" style="enable-background:new 0 0 18.2 18.5;"
                     xml:space="preserve">
                    <style type="text/css">
                        .spinner { fill:#FFFFFF; }
                    </style>
                        <path class="spinner" d="M9.2,18.5C4.1,18.5,0,14.4,0,9.2S4.1,0,9.2,0c0.9,0,1.9,0.1,2.7,0.4c0.8,0.2,1.2,1.1,1,1.9
                            c-0.2,0.8-1.1,1.2-1.9,1C10.5,3.1,9.9,3,9.2,3C5.8,3,3,5.8,3,9.2s2.8,6.2,6.2,6.2c2.8,0,5.3-1.9,6-4.7c0.2-0.8,1-1.3,1.8-1.1
                            c0.8,0.2,1.3,1,1.1,1.8C17.1,15.7,13.4,18.5,9.2,18.5z"/>
                    </svg>
                </i>
            </div>
        </div>
    `,
                host: {
                    '[class]': 'form.controls[control.key].controlType',
                    '[attr.data-control-type]': 'form.controls[control.key].controlType',
                    '[class.disabled]': 'form.controls[control.key].readOnly',
                    '[class.hidden]': 'form.controls[control.key].hidden',
                    '[attr.data-control-key]': 'control.key',
                }
            },] },
];
/**
 * @nocollapse
 */
NovoControlElement.ctorParameters = () => [
    { type: ElementRef, },
    { type: NovoLabelService, },
    { type: DateFormatService, },
    { type: FieldInteractionApi, },
];
NovoControlElement.propDecorators = {
    'control': [{ type: Input },],
    'form': [{ type: Input },],
    'condensed': [{ type: Input },],
    'change': [{ type: Output },],
    'onBlur': [{ type: Output, args: ['blur',] },],
    'onFocus': [{ type: Output, args: ['focus',] },],
};

const COUNTRIES = [{
        code: 'US',
        id: 1,
        name: 'United States',
        states: [{
                code: 'AL',
                name: 'Alabama'
            }, {
                code: 'AK',
                name: 'Alaska'
            }, {
                code: 'AZ',
                name: 'Arizona'
            }, {
                code: 'AR',
                name: 'Arkansas'
            }, {
                code: 'CA',
                name: 'California'
            }, {
                code: 'CO',
                name: 'Colorado'
            }, {
                code: 'CT',
                name: 'Connecticut'
            }, {
                code: 'DE',
                name: 'Delaware'
            }, {
                code: 'DC',
                name: 'District Of Columbia'
            }, {
                code: 'FL',
                name: 'Florida'
            }, {
                code: 'GA',
                name: 'Georgia'
            }, {
                code: 'GU',
                name: 'Guam'
            }, {
                code: 'HI',
                name: 'Hawaii'
            }, {
                code: 'ID',
                name: 'Idaho'
            }, {
                code: 'IL',
                name: 'Illinois'
            }, {
                code: 'IN',
                name: 'Indiana'
            }, {
                code: 'IA',
                name: 'Iowa'
            }, {
                code: 'KS',
                name: 'Kansas'
            }, {
                code: 'KY',
                name: 'Kentucky'
            }, {
                code: 'LA',
                name: 'Louisiana'
            }, {
                code: 'ME',
                name: 'Maine'
            }, {
                code: 'MH',
                name: 'Marshall Islands'
            }, {
                code: 'MD',
                name: 'Maryland'
            }, {
                code: 'MA',
                name: 'Massachusetts'
            }, {
                code: 'MI',
                name: 'Michigan'
            }, {
                code: 'MN',
                name: 'Minnesota'
            }, {
                code: 'MS',
                name: 'Mississippi'
            }, {
                code: 'MO',
                name: 'Missouri'
            }, {
                code: 'MT',
                name: 'Montana'
            }, {
                code: 'NE',
                name: 'Nebraska'
            }, {
                code: 'NV',
                name: 'Nevada'
            }, {
                code: 'NH',
                name: 'New Hampshire'
            }, {
                code: 'NJ',
                name: 'New Jersey'
            }, {
                code: 'NM',
                name: 'New Mexico'
            }, {
                code: 'NY',
                name: 'New York'
            }, {
                code: 'NC',
                name: 'North Carolina'
            }, {
                code: 'ND',
                name: 'North Dakota'
            }, {
                code: 'MP',
                name: 'Northern Mariana Islands'
            }, {
                code: 'OH',
                name: 'Ohio'
            }, {
                code: 'OK',
                name: 'Oklahoma'
            }, {
                code: 'OR',
                name: 'Oregon'
            }, {
                code: 'PW',
                name: 'Palau'
            }, {
                code: 'PA',
                name: 'Pennsylvania'
            }, {
                code: 'PR',
                name: 'Puerto Rico'
            }, {
                code: 'RI',
                name: 'Rhode Island'
            }, {
                code: 'SC',
                name: 'South Carolina'
            }, {
                code: 'SD',
                name: 'South Dakota'
            }, {
                code: 'TN',
                name: 'Tennessee'
            }, {
                code: 'TX',
                name: 'Texas'
            }, {
                code: 'UT',
                name: 'Utah'
            }, {
                code: 'VT',
                name: 'Vermont'
            }, {
                code: 'VI',
                name: 'Virgin Islands'
            }, {
                code: 'VA',
                name: 'Virginia'
            }, {
                code: 'WA',
                name: 'Washington'
            }, {
                code: 'WV',
                name: 'West Virginia'
            }, {
                code: 'WI',
                name: 'Wisconsin'
            }, {
                code: 'WY',
                name: 'Wyoming'
            }]
    }, {
        code: 'AF',
        id: 2185,
        name: 'Afghanistan',
        states: [{
                code: 'AF01',
                name: 'Badakhshan'
            }, {
                code: 'AF02',
                name: 'Badghis'
            }, {
                code: 'AF03',
                name: 'Baghlan'
            }, {
                code: 'AF30',
                name: 'Balkh'
            }, {
                code: 'AF05',
                name: 'Bamian'
            }, {
                code: 'AF41',
                name: 'Daikondi'
            }, {
                code: 'AF06',
                name: 'Farah'
            }, {
                code: 'AF07',
                name: 'Faryab'
            }, {
                code: 'AF08',
                name: 'Ghazni'
            }, {
                code: 'AF09',
                name: 'Ghowr'
            }, {
                code: 'AF10',
                name: 'Helmand'
            }, {
                code: 'AF11',
                name: 'Herat'
            }, {
                code: 'AF31',
                name: 'Jowzjan'
            }, {
                code: 'AF13',
                name: 'Kabul'
            }, {
                code: 'AF23',
                name: 'Kandahar'
            }, {
                code: 'AF14',
                name: 'Kapisa'
            }, {
                code: 'AF37',
                name: 'Khowst'
            }, {
                code: 'AF34',
                name: 'Konar'
            }, {
                code: 'AF24',
                name: 'Kondoz'
            }, {
                code: 'AF35',
                name: 'Laghman'
            }, {
                code: 'AF17',
                name: 'Lowgar'
            }, {
                code: 'AF18',
                name: 'Nangarhar'
            }, {
                code: 'AF19',
                name: 'Nimruz'
            }, {
                code: 'AF38',
                name: 'Nurestan'
            }, {
                code: 'AF39',
                name: 'Oruzgan'
            }, {
                code: 'AF36',
                name: 'Paktia'
            }, {
                code: 'AF29',
                name: 'Paktika'
            }, {
                code: 'AF42',
                name: 'Panjshir'
            }, {
                code: 'AF40',
                name: 'Parvan'
            }, {
                code: 'AF32',
                name: 'Samangan'
            }, {
                code: 'AF33',
                name: 'Sar-e Pol'
            }, {
                code: 'AF26',
                name: 'Takhar'
            }, {
                code: 'AF27',
                name: 'Vardak'
            }, {
                code: 'AF28',
                name: 'Zabol'
            }]
    }, {
        code: 'AL',
        id: 2186,
        name: 'Albania',
        states: []
    }, {
        code: 'DZ',
        id: 2187,
        name: 'Algeria',
        states: []
    }, {
        code: 'AD',
        id: 2188,
        name: 'Andorra',
        states: []
    }, {
        code: 'AO',
        id: 2189,
        name: 'Angola',
        states: [{
                code: 'AO19',
                name: 'Bengo'
            }, {
                code: 'AO01',
                name: 'Benguela'
            }, {
                code: 'AO02',
                name: 'Bi'
            }, {
                code: 'AO03',
                name: 'Cabinda'
            }, {
                code: 'AO04',
                name: 'Cuando Cubango'
            }, {
                code: 'AO05',
                name: 'Cuanza Norte'
            }, {
                code: 'AO06',
                name: 'Cuanza Sul'
            }, {
                code: 'AO07',
                name: 'Cunene'
            }, {
                code: 'AO08',
                name: 'Huambo'
            }, {
                code: 'AO09',
                name: 'Hula'
            }, {
                code: 'AO20',
                name: 'Luanda'
            }, {
                code: 'AO17',
                name: 'Lunda Norte'
            }, {
                code: 'AO18',
                name: 'Lunda Sul'
            }, {
                code: 'AO12',
                name: 'Malanje'
            }, {
                code: 'AO14',
                name: 'Moxico'
            }, {
                code: 'AO13',
                name: 'Namibe'
            }, {
                code: 'AO15',
                name: 'Uge'
            }, {
                code: 'AO16',
                name: 'Zaire'
            }]
    }, {
        code: 'AQ',
        id: 2190,
        name: 'Antarctica',
        states: []
    }, {
        code: 'AG',
        id: 2191,
        name: 'Antigua and Barbuda',
        states: []
    }, {
        code: 'AR',
        id: 2192,
        name: 'Argentina',
        states: [{
                code: 'AR01',
                name: 'Buenos Aires'
            }, {
                code: 'AR02',
                name: 'Catamarca'
            }, {
                code: 'AR03',
                name: 'Chaco'
            }, {
                code: 'AR04',
                name: 'Chubut'
            }, {
                code: 'AR07',
                name: 'Ciudad de Buenos Aires'
            }, {
                code: 'AR06',
                name: 'Corrientes'
            }, {
                code: 'AR05',
                name: 'Crdoba'
            }, {
                code: 'AR08',
                name: 'Entre Ros'
            }, {
                code: 'AR09',
                name: 'Formosa'
            }, {
                code: 'AR10',
                name: 'Jujuy'
            }, {
                code: 'AR11',
                name: 'La Pampa'
            }, {
                code: 'AR12',
                name: 'La Rioja'
            }, {
                code: 'AR13',
                name: 'Mendoza'
            }, {
                code: 'AR14',
                name: 'Misiones'
            }, {
                code: 'AR15',
                name: 'Neuqun'
            }, {
                code: 'AR16',
                name: 'Ro Negro'
            }, {
                code: 'AR17',
                name: 'Salta'
            }, {
                code: 'AR18',
                name: 'San Juan'
            }, {
                code: 'AR19',
                name: 'San Luis'
            }, {
                code: 'AR20',
                name: 'Santa Cruz'
            }, {
                code: 'AR21',
                name: 'Santa Fe'
            }, {
                code: 'AR22',
                name: 'Santiago del Estero'
            }, {
                code: 'AR23',
                name: 'Tierra del Fuego'
            }, {
                code: 'AR24',
                name: 'Tucumn'
            }]
    }, {
        code: 'AM',
        id: 2193,
        name: 'Armenia',
        states: []
    }, {
        code: 'AU',
        id: 2194,
        name: 'Australia',
        states: [{
                code: 'ACT',
                name: 'Australian Capital Territory'
            }, {
                code: 'NSW',
                name: 'New South Wales'
            }, {
                code: 'NT',
                name: 'Northern Territory'
            }, {
                code: 'QLD',
                name: 'Queensland'
            }, {
                code: 'SA',
                name: 'South Australia'
            }, {
                code: 'TAS',
                name: 'Tasmania'
            }, {
                code: 'VIC',
                name: 'Victoria'
            }, {
                code: 'WA',
                name: 'Western Australia'
            }]
    }, {
        code: 'AT',
        id: 2195,
        name: 'Austria',
        states: [{
                code: 'AU01',
                name: 'Burgenland'
            }, {
                code: 'AU02',
                name: 'Carinthia'
            }, {
                code: 'AU03',
                name: 'Lower Austria'
            }, {
                code: 'AU05',
                name: 'Salzburg'
            }, {
                code: 'AU06',
                name: 'Styria'
            }, {
                code: 'AU07',
                name: 'Tyrol'
            }, {
                code: 'AU04',
                name: 'Upper Austria'
            }, {
                code: 'AU09',
                name: 'Vienna'
            }, {
                code: 'AU08',
                name: 'Vorarlberg'
            }]
    }, {
        code: 'AZ',
        id: 2196,
        name: 'Azerbaijan',
        states: [{
                code: 'AZ-ABS',
                name: 'Absheron'
            }, {
                code: 'AZ-AGM',
                name: 'Aghdam'
            }, {
                code: 'AZ-AGS',
                name: 'Aghdash'
            }, {
                code: 'AZ-AGC',
                name: 'Aghjabedi'
            }, {
                code: 'AZ-AGA',
                name: 'Aghstafa'
            }, {
                code: 'AZ-AGU',
                name: 'Aghsu'
            }, {
                code: 'AZ-AB',
                name: 'Ali-Bairamly'
            }, {
                code: 'AZ-AST',
                name: 'Astara'
            }, {
                code: 'AZ-BAB',
                name: 'Babek'
            }, {
                code: 'AZ-BA',
                name: 'Baku'
            }, {
                code: 'AZ-BAL',
                name: 'Balaken'
            }, {
                code: 'AZ-BAR',
                name: 'Barda'
            }, {
                code: 'AZ-BEY',
                name: 'Beilagan'
            }, {
                code: 'AZ-BIL',
                name: 'Bilasuvar'
            }, {
                code: 'AZ-DAS',
                name: 'Dashkesan'
            }, {
                code: 'AZ-DAV',
                name: 'Devechi'
            }, {
                code: 'AZ-FUZ',
                name: 'Fizuli'
            }, {
                code: 'AZ-QAB',
                name: 'Gabala'
            }, {
                code: 'AZ-GAD',
                name: 'Gadabey'
            }, {
                code: 'AZ-QAX',
                name: 'Gakh'
            }, {
                code: 'AZ-GA',
                name: 'Ganja'
            }, {
                code: 'AZ-QAZ',
                name: 'Gazakh'
            }, {
                code: 'AZ-GOR',
                name: 'Geranboy'
            }, {
                code: 'AZ-QOB',
                name: 'Gobustan'
            }, {
                code: 'AZ-GOY',
                name: 'Goychay'
            }, {
                code: 'AZ-QBA',
                name: 'Guba'
            }, {
                code: 'AZ-QBI',
                name: 'Gubadly'
            }, {
                code: 'AZ-QUS',
                name: 'Gusar'
            }, {
                code: 'AZ-HAC',
                name: 'Hacuqabul'
            }, {
                code: 'AZ-IMI',
                name: 'Imishli'
            }, {
                code: 'AZ-ISM',
                name: 'Ismailly'
            }, {
                code: 'AZ-CAL',
                name: 'Jalilabad'
            }, {
                code: 'AZ-CAB',
                name: 'Jebrail'
            }, {
                code: 'AZ-CUL',
                name: 'Julfa'
            }, {
                code: 'AZ-KAL',
                name: 'Kelbajar'
            }, {
                code: 'AZ-XAC',
                name: 'Khachmaz'
            }, {
                code: 'AZ-XA',
                name: 'Khankendy'
            }, {
                code: 'AZ-XAN',
                name: 'Khanlar'
            }, {
                code: 'AZ-XCI',
                name: 'Khojaly'
            }, {
                code: 'AZ-XVD',
                name: 'Khojavend'
            }, {
                code: 'AZ-XIZ',
                name: 'Khyzy'
            }, {
                code: 'AZ-KUR',
                name: 'Kyurdamir'
            }, {
                code: 'AZ-LAC',
                name: 'Lachin'
            }, {
                code: 'AZ-LA',
                name: 'Lenkaran'
            }, {
                code: 'AZ-LAN',
                name: 'Lenkaran'
            }, {
                code: 'AZ-LER',
                name: 'Lerik'
            }, {
                code: 'AZ-MAS',
                name: 'Masally'
            }, {
                code: 'AZ-MI',
                name: 'Mingechevir'
            }, {
                code: 'AZ-NA',
                name: 'Naftalan'
            }, {
                code: 'AZ-NX',
                name: 'Nakhchivan'
            }, {
                code: 'AZ-NEF',
                name: 'Neftchala'
            }, {
                code: 'AZ-OGU',
                name: 'Oghuz'
            }, {
                code: 'AZ-ORD',
                name: 'Ordubad'
            }, {
                code: 'AZ-SAT',
                name: 'Saatly'
            }, {
                code: 'AZ-SAB',
                name: 'Sabirabad'
            }, {
                code: 'AZ-SAL',
                name: 'Salyan'
            }, {
                code: 'AZ-SMX',
                name: 'Samuh'
            }, {
                code: 'AZ-SAD',
                name: 'Sedarak'
            }, {
                code: 'AZ-SAH',
                name: 'Shahbuz'
            }, {
                code: 'AZ-SMI',
                name: 'Shamakhy'
            }, {
                code: 'AZ-SKR',
                name: 'Shamkir'
            }, {
                code: 'AZ-SA',
                name: 'Sheki'
            }, {
                code: 'AZ-SAK',
                name: 'Sheki'
            }, {
                code: 'AZ-SAR',
                name: 'Sherur'
            }, {
                code: 'AZ-SS',
                name: 'Shusha'
            }, {
                code: 'AZ-SUS',
                name: 'Shusha'
            }, {
                code: 'AZ-SIY',
                name: 'Siazan'
            }, {
                code: 'AZ-SM',
                name: 'Sumgayit'
            }, {
                code: 'AZ-TAR',
                name: 'Terter'
            }, {
                code: 'AZ-TOV',
                name: 'Tovuz'
            }, {
                code: 'AZ-UCA',
                name: 'Ujar'
            }, {
                code: 'AZ-YAR',
                name: 'Yardymly'
            }, {
                code: 'AZ-YE',
                name: 'Yevlakh'
            }, {
                code: 'AZ-YEV',
                name: 'Yevlakh'
            }, {
                code: 'AZ-ZAQ',
                name: 'Zagatala'
            }, {
                code: 'AZ-ZAN',
                name: 'Zangilan'
            }, {
                code: 'AZ-ZAR',
                name: 'Zerdab'
            }]
    }, {
        code: 'BS',
        id: 2197,
        name: 'Bahamas',
        states: []
    }, {
        code: 'BH',
        id: 2198,
        name: 'Bahrain',
        states: [{
                code: 'BA16',
                name: 'Capital'
            }, {
                code: 'BA19',
                name: 'Central'
            }, {
                code: 'BA15',
                name: 'Muharraq'
            }, {
                code: 'BA18',
                name: 'Northern'
            }, {
                code: 'BA17',
                name: 'Southern'
            }]
    }, {
        code: 'BD',
        id: 2199,
        name: 'Bangladesh',
        states: [{
                code: 'BG85',
                name: 'Barisal'
            }, {
                code: 'BG84',
                name: 'Chittagong'
            }, {
                code: 'BG81',
                name: 'Dhaka'
            }, {
                code: 'BG82',
                name: 'Khulna'
            }, {
                code: 'BG81',
                name: 'Mymensingh'
            }, {
                code: 'BG83',
                name: 'Rajshahi'
            }, {
                code: 'BG87',
                name: 'Rangpur'
            }, {
                code: 'BG86',
                name: 'Sylhet'
            }]
    }, {
        code: 'BB',
        id: 2200,
        name: 'Barbados',
        states: []
    }, {
        code: 'BY',
        id: 2201,
        name: 'Belarus',
        states: [{
                code: 'BO01',
                name: 'Brest'
            }, {
                code: 'BO02',
                name: 'Gomel'
            }, {
                code: 'BO03',
                name: 'Grodno'
            }, {
                code: 'BO05',
                name: 'Minsk'
            }, {
                code: 'BO04',
                name: 'Minsk City'
            }, {
                code: 'BO06',
                name: 'Mogilev'
            }, {
                code: 'BO07',
                name: 'Vitebsk'
            }]
    }, {
        code: 'BE',
        id: 2202,
        name: 'Belgium',
        states: [{
                code: 'BE01',
                name: 'Antwerpen Province'
            }, {
                code: 'BE11',
                name: 'Brussels-Capital Region'
            }, {
                code: 'BE12',
                name: 'Flemish Brabant Province'
            }, {
                code: 'BE03',
                name: 'Hainaut Province'
            }, {
                code: 'BE04',
                name: 'Liege Province'
            }, {
                code: 'BE05',
                name: 'Limburg Province'
            }, {
                code: 'BE06',
                name: 'Luxembourg Province'
            }, {
                code: 'BE07',
                name: 'Namur Province'
            }, {
                code: 'BE08',
                name: 'Oost-Vlaanderen Province'
            }, {
                code: 'BE10',
                name: 'Walloon Brabant Province'
            }, {
                code: 'BE09',
                name: 'West-Vlaanderen Province'
            }]
    }, {
        code: 'BZ',
        id: 2203,
        name: 'Belize',
        states: []
    }, {
        code: 'BJ',
        id: 2204,
        name: 'Benin',
        states: []
    }, {
        code: 'BT',
        id: 2205,
        name: 'Bhutan',
        states: []
    }, {
        code: 'BO',
        id: 2206,
        name: 'Bolivia; Plurinational State',
        states: []
    }, {
        code: 'BA',
        id: 2207,
        name: 'Bosnia and Herzegovina',
        states: [{
                code: 'BA-05',
                name: 'Bosansko-podrinjski kanton'
            }, {
                code: 'BA-BRC',
                name: 'Brcko distrikt'
            }, {
                code: 'BA-BIH',
                name: 'Federacija Bosna i Hercegovina'
            }, {
                code: 'BA-07',
                name: 'Hercegovacko-neretvanski kanton'
            }, {
                code: 'BA-09',
                name: 'Kanton Sarajevo'
            }, {
                code: 'BA-10',
                name: 'Livanjski kanton'
            }, {
                code: 'BA-02',
                name: 'Posavski kanton'
            }, {
                code: 'BA-SRP',
                name: 'Republika Srpska'
            }, {
                code: 'BA-06',
                name: 'Srednjobosanski kanton'
            }, {
                code: 'BA-03',
                name: 'Tuzlanski kanton'
            }, {
                code: 'BA-01',
                name: 'Unsko-sanski kanton'
            }, {
                code: 'BA-08',
                name: 'Zapadnohercegovacki kanton'
            }, {
                code: 'BA-04',
                name: 'Zenicko-dobojski kanton'
            }]
    }, {
        code: 'BW',
        id: 2208,
        name: 'Botswana',
        states: []
    }, {
        code: 'BR',
        id: 2209,
        name: 'Brazil',
        states: [{
                code: 'AC',
                name: 'Acre'
            }, {
                code: 'AL',
                name: 'Alagoas'
            }, {
                code: 'AP',
                name: 'Amap'
            }, {
                code: 'AM',
                name: 'Amazonas'
            }, {
                code: 'BA',
                name: 'Bahia'
            }, {
                code: 'CE',
                name: 'Cear'
            }, {
                code: 'DF',
                name: 'Distrito Federal'
            }, {
                code: 'ES',
                name: 'Esprito Santo'
            }, {
                code: 'GO',
                name: 'Gois'
            }, {
                code: 'MA',
                name: 'Maranho'
            }, {
                code: 'MT',
                name: 'Mato Grosso'
            }, {
                code: 'MS',
                name: 'Mato Grosso do Sul'
            }, {
                code: 'MG',
                name: 'Minas Gerais'
            }, {
                code: 'PR',
                name: 'Paran'
            }, {
                code: 'PB',
                name: 'Paraba'
            }, {
                code: 'PA',
                name: 'Par'
            }, {
                code: 'PE',
                name: 'Pernambuco'
            }, {
                code: 'PI',
                name: 'Piau'
            }, {
                code: 'RN',
                name: 'Rio Grande do Norte'
            }, {
                code: 'RS',
                name: 'Rio Grande do Sul'
            }, {
                code: 'RJ',
                name: 'Rio de Janeiro'
            }, {
                code: 'RO',
                name: 'Rondnia'
            }, {
                code: 'RR',
                name: 'Roraima'
            }, {
                code: 'SC',
                name: 'Santa Catarina'
            }, {
                code: 'SE',
                name: 'Sergipe'
            }, {
                code: 'SP',
                name: 'So Paulo'
            }, {
                code: 'TO',
                name: 'Tocantins'
            }]
    }, {
        code: 'BN',
        id: 2210,
        name: 'Brunei Darussalam',
        states: [{
                code: 'BX01',
                name: 'Amo'
            }, {
                code: 'BX02',
                name: 'Bandar Seri Begawan'
            }, {
                code: 'BX03',
                name: 'Bangar'
            }, {
                code: 'BX04',
                name: 'Batu Apoi'
            }, {
                code: 'BX05',
                name: 'Berakas'
            }, {
                code: 'BX06',
                name: 'Bokok'
            }, {
                code: 'BX07',
                name: 'Bukit Sawat'
            }, {
                code: 'BX08',
                name: 'Burong Pinggai Ayer'
            }, {
                code: 'BX09',
                name: 'Gadong'
            }, {
                code: 'BX10',
                name: 'Keriam'
            }, {
                code: 'BX11',
                name: 'Kianggeh'
            }, {
                code: 'BX12',
                name: 'Kilanas'
            }, {
                code: 'BX13',
                name: 'Kiudang'
            }, {
                code: 'BX14',
                name: 'Kota Batu'
            }, {
                code: 'BX15',
                name: 'Kuala Balai'
            }, {
                code: 'BX16',
                name: 'Kuala Belait'
            }, {
                code: 'BX17',
                name: 'Labi'
            }, {
                code: 'BX18',
                name: 'Labu'
            }, {
                code: 'BX19',
                name: 'Lamunin'
            }, {
                code: 'BX20',
                name: 'Liang'
            }, {
                code: 'BX21',
                name: 'Lumapas'
            }, {
                code: 'BX22',
                name: 'Melilas'
            }, {
                code: 'BX23',
                name: 'Mentiri'
            }, {
                code: 'BX24',
                name: 'Pekan Tutong'
            }, {
                code: 'BX25',
                name: 'Pengkalan Batu'
            }, {
                code: 'BX26',
                name: 'Peramu'
            }, {
                code: 'BX27',
                name: 'Rambai'
            }, {
                code: 'BX28',
                name: 'Saba'
            }, {
                code: 'BX29',
                name: 'Sengkurong'
            }, {
                code: 'BX30',
                name: 'Serasa'
            }, {
                code: 'BX31',
                name: 'Seria'
            }, {
                code: 'BX32',
                name: 'Sukang'
            }, {
                code: 'BX33',
                name: 'Sungai Kebun'
            }, {
                code: 'BX34',
                name: 'Sungai Kedayan'
            }, {
                code: 'BX35',
                name: 'Tamoi'
            }, {
                code: 'BX36',
                name: 'Tanjong Maya'
            }, {
                code: 'BX37',
                name: 'Telisai'
            }, {
                code: 'BX38',
                name: 'Ukong'
            }]
    }, {
        code: 'BG',
        id: 2211,
        name: 'Bulgaria',
        states: [{
                code: 'BU38',
                name: 'Blagoevgrad'
            }, {
                code: 'BU39',
                name: 'Burgas'
            }, {
                code: 'BU40',
                name: 'Dobrich'
            }, {
                code: 'BU41',
                name: 'Gabrovo'
            }, {
                code: 'BU42',
                name: 'Grad Sofiya'
            }, {
                code: 'BU43',
                name: 'Khaskovo'
            }, {
                code: 'BU44',
                name: 'Kurdzhali'
            }, {
                code: 'BU45',
                name: 'Kyustendil'
            }, {
                code: 'BU46',
                name: 'Lovech'
            }, {
                code: 'BU47',
                name: 'Montana'
            }, {
                code: 'BU48',
                name: 'Pazardzhik'
            }, {
                code: 'BU49',
                name: 'Pernik'
            }, {
                code: 'BU50',
                name: 'Pleven'
            }, {
                code: 'BU51',
                name: 'Plovdiv'
            }, {
                code: 'BU52',
                name: 'Razgrad'
            }, {
                code: 'BU53',
                name: 'Ruse'
            }, {
                code: 'BU54',
                name: 'Shumen'
            }, {
                code: 'BU55',
                name: 'Silistra'
            }, {
                code: 'BU56',
                name: 'Sliven'
            }, {
                code: 'BU57',
                name: 'Smolyan'
            }, {
                code: 'BU58',
                name: 'Sofiya'
            }, {
                code: 'BU59',
                name: 'Stara Zagora'
            }, {
                code: 'BU60',
                name: 'Turgovishte'
            }, {
                code: 'BU61',
                name: 'Varna'
            }, {
                code: 'BU62',
                name: 'Veliko Turnovo'
            }, {
                code: 'BU63',
                name: 'Vidin'
            }, {
                code: 'BU64',
                name: 'Vratsa'
            }, {
                code: 'BU65',
                name: 'Yambol'
            }]
    }, {
        code: 'BF',
        id: 2212,
        name: 'Burkina Faso',
        states: []
    }, {
        code: 'BI',
        id: 2213,
        name: 'Burundi',
        states: []
    }, {
        code: 'KH',
        id: 2214,
        name: 'Cambodia',
        states: [{
                code: 'CB29',
                name: 'Batdmbng'
            }, {
                code: 'CB25',
                name: 'Bntay Manchey'
            }, {
                code: 'CB08',
                name: 'Kah Kong'
            }, {
                code: 'CB26',
                name: 'Krong Keb'
            }, {
                code: 'CB30',
                name: 'Krong Pailin'
            }, {
                code: 'CB28',
                name: 'Krong Preah Sihanouk'
            }, {
                code: 'CB09',
                name: 'Krchh'
            }, {
                code: 'CB02',
                name: 'Kmpng Cham'
            }, {
                code: 'CB03',
                name: 'Kmpng Chhnang'
            }, {
                code: 'CB04',
                name: 'Kmpng Sp'
            }, {
                code: 'CB05',
                name: 'Kmpng Thum'
            }, {
                code: 'CB21',
                name: 'Kmpt'
            }, {
                code: 'CB07',
                name: 'Kndal'
            }, {
                code: 'CB10',
                name: 'Mndl Kiri'
            }, {
                code: 'CB27',
                name: 'Otdr Manchey'
            }, {
                code: 'CB22',
                name: 'Phnom Penh'
            }, {
                code: 'CB12',
                name: 'Pouthisat'
            }, {
                code: 'CB13',
                name: 'Preah Vihar'
            }, {
                code: 'CB14',
                name: 'Prey Vng'
            }, {
                code: 'CB23',
                name: 'Rtnkiri'
            }, {
                code: 'CB24',
                name: 'Siemrab'
            }, {
                code: 'CB17',
                name: 'St?ng Trng'
            }, {
                code: 'CB18',
                name: 'Svay Rieng'
            }, {
                code: 'CB19',
                name: 'Takv'
            }, {
                code: 'CB31',
                name: 'Tbong Khmum'
            }]
    }, {
        code: 'CM',
        id: 2215,
        name: 'Cameroon',
        states: []
    }, {
        code: 'CA',
        id: 2216,
        name: 'Canada',
        states: [{
                code: 'AB',
                name: 'Alberta'
            }, {
                code: 'BC',
                name: 'British Columbia'
            }, {
                code: 'MB',
                name: 'Manitoba'
            }, {
                code: 'NB',
                name: 'New Brunswick'
            }, {
                code: 'NL',
                name: 'Newfoundland and Labrador'
            }, {
                code: 'NT',
                name: 'Northwest Territories'
            }, {
                code: 'NS',
                name: 'Nova Scotia'
            }, {
                code: 'NU',
                name: 'Nunavut'
            }, {
                code: 'ON',
                name: 'Ontario'
            }, {
                code: 'PE',
                name: 'Prince Edward Island'
            }, {
                code: 'QC',
                name: 'Quebec'
            }, {
                code: 'SK',
                name: 'Saskatchewan'
            }, {
                code: 'YT',
                name: 'Yukon'
            }]
    }, {
        code: 'CV',
        id: 2217,
        name: 'Cape Verde',
        states: []
    }, {
        code: 'CF',
        id: 2218,
        name: 'Central African Republic',
        states: []
    }, {
        code: 'TD',
        id: 2219,
        name: 'Chad',
        states: []
    }, {
        code: 'CL',
        id: 2220,
        name: 'Chile',
        states: [{
                code: 'CL.AI',
                name: 'Aisn del General Carlos Ibez del Campo'
            }, {
                code: 'CL.AN',
                name: 'Antofagasta'
            }, {
                code: 'CL.AR',
                name: 'Araucana'
            }, {
                code: 'CL.AP',
                name: 'Arica and Parinacota'
            }, {
                code: 'CL.AT',
                name: 'Atacama'
            }, {
                code: 'CL.BI',
                name: 'Bo-Bo'
            }, {
                code: 'CL.CO',
                name: 'Coquimbo'
            }, {
                code: 'CL.LI',
                name: 'Libertador General Bernardo O\'Higgins'
            }, {
                code: 'CL.LG',
                name: 'Los Lagos'
            }, {
                code: 'CL.LR',
                name: 'Los Ros'
            }, {
                code: 'CL.MA',
                name: 'Magallanes y Antrtica Chilena'
            }, {
                code: 'CL.ML',
                name: 'Maule'
            }, {
                code: 'CL.RM',
                name: 'Regin Metropolitana de Santiago'
            }, {
                code: 'CL.TP',
                name: 'Tarapac'
            }, {
                code: 'CL.VS',
                name: 'Valparaso'
            }]
    }, {
        code: 'CN',
        id: 2221,
        name: 'China',
        states: [{
                code: 'CH01',
                name: 'Anhui'
            }, {
                code: 'CH22',
                name: 'Beijing'
            }, {
                code: 'CH33',
                name: 'Chongqing'
            }, {
                code: 'CH07',
                name: 'Fujian'
            }, {
                code: 'CH15',
                name: 'Gansu'
            }, {
                code: 'CH17',
                name: 'Guangdon'
            }, {
                code: 'CH30',
                name: 'Guangdong'
            }, {
                code: 'CH16',
                name: 'Guangxi'
            }, {
                code: 'CH18',
                name: 'Guizhou'
            }, {
                code: 'CH31',
                name: 'Hainan'
            }, {
                code: 'CH10',
                name: 'Hebei'
            }, {
                code: 'CH08',
                name: 'Heilongjiang'
            }, {
                code: 'CH09',
                name: 'Henan'
            }, {
                code: 'CH34',
                name: 'Hong Kong'
            }, {
                code: 'CH12',
                name: 'Hubei'
            }, {
                code: 'CH11',
                name: 'Hunan'
            }, {
                code: 'CH04',
                name: 'Jiangsu'
            }, {
                code: 'CH03',
                name: 'Jiangxi'
            }, {
                code: 'CH05',
                name: 'Jilin'
            }, {
                code: 'CH19',
                name: 'Liaoning'
            }, {
                code: 'CH20',
                name: 'Nei Mongol'
            }, {
                code: 'CH21',
                name: 'Ningxia'
            }, {
                code: 'CH06',
                name: 'Qinghai'
            }, {
                code: 'CH26',
                name: 'Shaanxi'
            }, {
                code: 'CH25',
                name: 'Shandong'
            }, {
                code: 'CH23',
                name: 'Shanghai'
            }, {
                code: 'CH24',
                name: 'Shanxi'
            }, {
                code: 'CH27',
                name: 'Sichuan'
            }, {
                code: 'CH32',
                name: 'Sichuan'
            }, {
                code: 'CH28',
                name: 'Tianjin'
            }, {
                code: 'CH13',
                name: 'Xinjiang'
            }, {
                code: 'CH14',
                name: 'Xizang'
            }, {
                code: 'CH29',
                name: 'Yunnan'
            }, {
                code: 'CH02',
                name: 'Zhejiang'
            }]
    }, {
        code: 'CO',
        id: 2222,
        name: 'Colombia',
        states: [{
                code: 'CO01',
                name: 'Amazonas'
            }, {
                code: 'CO02',
                name: 'Antioquia'
            }, {
                code: 'CO03',
                name: 'Arauca'
            }, {
                code: 'CO04',
                name: 'Atlntico'
            }, {
                code: 'CO35',
                name: 'Bolvar'
            }, {
                code: 'CO36',
                name: 'Boyac'
            }, {
                code: 'CO37',
                name: 'Caldas'
            }, {
                code: 'CO08',
                name: 'Caquet'
            }, {
                code: 'CO32',
                name: 'Casanare'
            }, {
                code: 'CO09',
                name: 'Cauca'
            }, {
                code: 'CO10',
                name: 'Cesar'
            }, {
                code: 'CO11',
                name: 'Choc'
            }, {
                code: 'CO33',
                name: 'Cundinamarca'
            }, {
                code: 'CO12',
                name: 'Crdoba'
            }, {
                code: 'CO34',
                name: 'Distrito Capital'
            }, {
                code: 'CO15',
                name: 'Guaina'
            }, {
                code: 'CO14',
                name: 'Guaviare'
            }, {
                code: 'CO16',
                name: 'Huila'
            }, {
                code: 'CO17',
                name: 'La Guajira'
            }, {
                code: 'CO38',
                name: 'Magdalena'
            }, {
                code: 'CO19',
                name: 'Meta'
            }, {
                code: 'CO20',
                name: 'Nario'
            }, {
                code: 'CO21',
                name: 'Norte de Santander'
            }, {
                code: 'CO22',
                name: 'Putumayo'
            }, {
                code: 'CO23',
                name: 'Quindo'
            }, {
                code: 'CO24',
                name: 'Risaralda'
            }, {
                code: 'CO25',
                name: 'San Andrs y Providencia'
            }, {
                code: 'CO26',
                name: 'Santander'
            }, {
                code: 'CO27',
                name: 'Sucre'
            }, {
                code: 'CO28',
                name: 'Tolima'
            }, {
                code: 'CO29',
                name: 'Valle del Cauca'
            }, {
                code: 'CO30',
                name: 'Vaups'
            }, {
                code: 'CO31',
                name: 'Vichada'
            }]
    }, {
        code: 'KM',
        id: 2223,
        name: 'Comoros',
        states: []
    }, {
        code: 'CR',
        id: 2226,
        name: 'Costa Rica',
        states: [{
                code: 'CS01',
                name: 'Alajuela'
            }, {
                code: 'CS02',
                name: 'Cartago'
            }, {
                code: 'CS03',
                name: 'Guanacaste'
            }, {
                code: 'CS04',
                name: 'Heredia'
            }, {
                code: 'CS06',
                name: 'Limn'
            }, {
                code: 'CS07',
                name: 'Puntarenas'
            }, {
                code: 'CS08',
                name: 'San Jos'
            }]
    }, {
        code: 'CI',
        id: 2227,
        name: 'Cote D\'Ivoire',
        states: []
    }, {
        code: 'HR',
        id: 2228,
        name: 'Croatia',
        states: [{
                code: 'HR07',
                name: 'Bjelovarsko-bilogorska'
            }, {
                code: 'HR12',
                name: 'Brodsko-posavska'
            }, {
                code: 'HR19',
                name: 'Dubrovacko-neretvanska'
            }, {
                code: 'HR21',
                name: 'Grad Zagreb'
            }, {
                code: 'HR-18',
                name: 'Istarska'
            }, {
                code: 'HR04',
                name: 'Karlovacka'
            }, {
                code: 'HR06',
                name: 'Koprivnicko-krievacka'
            }, {
                code: 'HR02',
                name: 'Krapinsko-zagorska'
            }, {
                code: 'HR09',
                name: 'Licko-senjska'
            }, {
                code: 'HR20',
                name: 'Medimurska'
            }, {
                code: 'HR14',
                name: 'Osjecko-baranjska'
            }, {
                code: 'HR11',
                name: 'Poeko-slavonska'
            }, {
                code: 'HR08',
                name: 'Primorsko-goranska'
            }, {
                code: 'HR03',
                name: 'Sisacko-moslavacka'
            }, {
                code: 'HR17',
                name: 'Splitsko-dalmatinska'
            }, {
                code: 'HR05',
                name: 'Varadinska'
            }, {
                code: 'HR10',
                name: 'Viroviticko-podravska'
            }, {
                code: 'HR16',
                name: 'Vukovarsko-srijemska'
            }, {
                code: 'HR13',
                name: 'Zadarska'
            }, {
                code: 'HR01',
                name: 'Zagrebacka'
            }, {
                code: 'HR15',
                name: 'ibensko-kninska'
            }]
    }, {
        code: 'CU',
        id: 2229,
        name: 'Cuba',
        states: [{
                code: 'CU17',
                name: 'Artemisa'
            }, {
                code: 'CU05',
                name: 'Camagey'
            }, {
                code: 'CU07',
                name: 'Ciego de vila'
            }, {
                code: 'CU08',
                name: 'Cienfuegos'
            }, {
                code: 'CU09',
                name: 'Granma'
            }, {
                code: 'CU10',
                name: 'Guantnamo'
            }, {
                code: 'CU12',
                name: 'Holgun'
            }, {
                code: 'CU04',
                name: 'Isla de la Juventud'
            }, {
                code: 'CU02',
                name: 'La Habana'
            }, {
                code: 'CU13',
                name: 'Las Tunas'
            }, {
                code: 'CU03',
                name: 'Matanzas'
            }, {
                code: 'CU18',
                name: 'Mayabeque'
            }, {
                code: 'CU01',
                name: 'Pinar del Ro'
            }, {
                code: 'CU14',
                name: 'Sancti Spritus'
            }, {
                code: 'CU15',
                name: 'Santiago de Cuba'
            }, {
                code: 'CU16',
                name: 'Villa Clara'
            }]
    }, {
        code: 'CY',
        id: 2230,
        name: 'Cyprus',
        states: [{
                code: 'CY01',
                name: 'Famagusta'
            }, {
                code: 'CY02',
                name: 'Kyrenia'
            }, {
                code: 'CY03',
                name: 'Larnaca'
            }, {
                code: 'CY05',
                name: 'Limassol'
            }, {
                code: 'CY04',
                name: 'Nicosia'
            }, {
                code: 'CY06',
                name: 'Paphos'
            }]
    }, {
        code: 'CZ',
        id: 2231,
        name: 'Czech Republic',
        states: [{
                code: 'JC',
                name: 'Jihocesk kraj'
            }, {
                code: 'JM',
                name: 'Jihomoravsk kraj'
            }, {
                code: 'KA',
                name: 'Karlovarsk kraj'
            }, {
                code: 'KR',
                name: 'Krlovhradeck kraj'
            }, {
                code: 'LI',
                name: 'Libereck kraj'
            }, {
                code: 'MO',
                name: 'Moravskoslezsk kraj'
            }, {
                code: 'OL',
                name: 'Olomouck kraj'
            }, {
                code: 'PA',
                name: 'Pardubick kraj'
            }, {
                code: 'PL',
                name: 'Plzensk kraj'
            }, {
                code: 'PR',
                name: 'Praha, hlavn mesto'
            }, {
                code: 'ST',
                name: 'Stredocesk kraj'
            }, {
                code: 'VY',
                name: 'Vysocina'
            }, {
                code: 'ZL',
                name: 'Zlnsk kraj'
            }, {
                code: 'US',
                name: 'steck kraj'
            }]
    }, {
        code: 'DK',
        id: 2232,
        name: 'Denmark',
        states: [{
                code: 'DA01',
                name: 'Arhus County'
            }, {
                code: 'DA02',
                name: 'Bornholm Regional Municipality'
            }, {
                code: 'DA17',
                name: 'Capital Region'
            }, {
                code: 'DA18',
                name: 'Central Jutland Region'
            }, {
                code: 'DA16',
                name: 'Frederiksberg municipal'
            }, {
                code: 'DA03',
                name: 'Frederiksborg County'
            }, {
                code: 'DA04',
                name: 'Fyn County'
            }, {
                code: 'DA06',
                name: 'Kobenhavn County'
            }, {
                code: 'DA05',
                name: 'Kobenhavn municipal'
            }, {
                code: 'DA07',
                name: 'Nordjylland County'
            }, {
                code: 'DA19',
                name: 'North Jutland Region'
            }, {
                code: 'DA08',
                name: 'Ribe County'
            }, {
                code: 'DA09',
                name: 'Ringkobing County'
            }, {
                code: 'DA10',
                name: 'Roskilde County'
            }, {
                code: 'DA11',
                name: 'Sonderjylland County'
            }, {
                code: 'DA21',
                name: 'South Denmark Region'
            }, {
                code: 'DA12',
                name: 'Storstrom County'
            }, {
                code: 'DA13',
                name: 'Vejle County'
            }, {
                code: 'DA14',
                name: 'Vestsjaelland County'
            }, {
                code: 'DA15',
                name: 'Viborg County'
            }, {
                code: 'DA20',
                name: 'Zealand Region'
            }]
    }, {
        code: 'DJ',
        id: 2233,
        name: 'Djibouti',
        states: []
    }, {
        code: 'DM',
        id: 2234,
        name: 'Dominica',
        states: []
    }, {
        code: 'DO',
        id: 2235,
        name: 'Dominican Republic',
        states: []
    }, {
        code: 'EC',
        id: 2236,
        name: 'Ecuador',
        states: [{
                code: 'EC02',
                name: 'Azuay'
            }, {
                code: 'EC02',
                name: 'Azuay'
            }, {
                code: 'EC03',
                name: 'Bolvar'
            }, {
                code: 'EC05',
                name: 'Carchi'
            }, {
                code: 'EC04',
                name: 'Caar'
            }, {
                code: 'EC06',
                name: 'Chimborazo'
            }, {
                code: 'EC07',
                name: 'Cotopaxi'
            }, {
                code: 'EC08',
                name: 'El Oro'
            }, {
                code: 'EC09',
                name: 'Esmeraldas'
            }, {
                code: 'EC01',
                name: 'Galpagos'
            }, {
                code: 'EC10',
                name: 'Guayas'
            }, {
                code: 'EC11',
                name: 'Imbabura'
            }, {
                code: 'EC12',
                name: 'Loja'
            }, {
                code: 'EC13',
                name: 'Los Ros'
            }, {
                code: 'EC14',
                name: 'Manab'
            }, {
                code: 'EC15',
                name: 'Morona-Santiago'
            }, {
                code: 'EC23',
                name: 'Napo'
            }, {
                code: 'EC24',
                name: 'Orellana'
            }, {
                code: 'EC17',
                name: 'Pastaza'
            }, {
                code: 'EC18',
                name: 'Pichincha'
            }, {
                code: 'EC25',
                name: 'Santa Elena'
            }, {
                code: 'EC26',
                name: 'Santo Domingo de los Tschilas'
            }, {
                code: 'EC22',
                name: 'Sucumbos'
            }, {
                code: 'EC19',
                name: 'Tungurahua'
            }, {
                code: 'EC20',
                name: 'Zamora-Chinchipe'
            }]
    }, {
        code: 'EG',
        id: 2237,
        name: 'Egypt',
        states: [{
                code: 'EG01',
                name: 'Ad Daqahliyah'
            }, {
                code: 'EG02',
                name: 'Al Bahr al Ahmar'
            }, {
                code: 'EG03',
                name: 'Al Buhayrah'
            }, {
                code: 'EG04',
                name: 'Al Fayyum'
            }, {
                code: 'EG05',
                name: 'Al Gharbiyah'
            }, {
                code: 'EG06',
                name: 'Al Iskandariyah'
            }, {
                code: 'EG07',
                name: 'Al Isma`iliyah'
            }, {
                code: 'EG08',
                name: 'Al Jizah'
            }, {
                code: 'EG09',
                name: 'Al Minufiyah'
            }, {
                code: 'EG10',
                name: 'Al Minya'
            }, {
                code: 'EG11',
                name: 'Al Qahirah'
            }, {
                code: 'EG12',
                name: 'Al Qalyubiyah'
            }, {
                code: 'EG28',
                name: 'Al Uqsur'
            }, {
                code: 'EG13',
                name: 'Al Wadi al Jadid'
            }, {
                code: 'EG15',
                name: 'As Suways'
            }, {
                code: 'EG14',
                name: 'Ash Sharqiyah'
            }, {
                code: 'EG16',
                name: 'Aswan'
            }, {
                code: 'EG17',
                name: 'Asyut'
            }, {
                code: 'EG18',
                name: 'Bani Suwayf'
            }, {
                code: 'EG19',
                name: 'Bur Sa`id'
            }, {
                code: 'EG20',
                name: 'Dumyat'
            }, {
                code: 'EG26',
                name: 'Janub Sina'
            }, {
                code: 'EG21',
                name: 'Kafr ash Shaykh'
            }, {
                code: 'EG22',
                name: 'Matruh'
            }, {
                code: 'EG23',
                name: 'Qina'
            }, {
                code: 'EG27',
                name: 'Shamal Sina'
            }, {
                code: 'EG24',
                name: 'Suhaj'
            }]
    }, {
        code: 'SV',
        id: 2238,
        name: 'El Salvador',
        states: [{
                code: 'ES01',
                name: 'Ahuachapn'
            }, {
                code: 'ES02',
                name: 'Cabaas'
            }, {
                code: 'ES03',
                name: 'Chalatenango'
            }, {
                code: 'ES04',
                name: 'Cuscatln'
            }, {
                code: 'ES05',
                name: 'La Libertad'
            }, {
                code: 'ES06',
                name: 'La Paz'
            }, {
                code: 'ES07',
                name: 'La Unin'
            }, {
                code: 'ES08',
                name: 'Morazn'
            }, {
                code: 'ES09',
                name: 'San Miguel'
            }, {
                code: 'ES10',
                name: 'San Salvador'
            }, {
                code: 'ES12',
                name: 'San Vicente'
            }, {
                code: 'ES11',
                name: 'Santa Ana'
            }, {
                code: 'ES13',
                name: 'Sonsonate'
            }, {
                code: 'ES14',
                name: 'Usulutn'
            }]
    }, {
        code: 'GQ',
        id: 2239,
        name: 'Equatorial Guinea',
        states: []
    }, {
        code: 'ER',
        id: 2240,
        name: 'Eritrea',
        states: []
    }, {
        code: 'EE',
        id: 2241,
        name: 'Estonia',
        states: [{
                code: 'EN01',
                name: 'Harju'
            }, {
                code: 'EN02',
                name: 'Hiiu'
            }, {
                code: 'EN03',
                name: 'Ida-Viru'
            }, {
                code: 'EN04',
                name: 'Jrva'
            }, {
                code: 'EN05',
                name: 'Jgeva'
            }, {
                code: 'EN07',
                name: 'Lne'
            }, {
                code: 'EN08',
                name: 'Lne-Viru'
            }, {
                code: 'EN11',
                name: 'Prnu'
            }, {
                code: 'EN12',
                name: 'Plva'
            }, {
                code: 'EN13',
                name: 'Rapla'
            }, {
                code: 'EN14',
                name: 'Saare'
            }, {
                code: 'EN18',
                name: 'Tartu'
            }, {
                code: 'EN19',
                name: 'Valga'
            }, {
                code: 'EN20',
                name: 'Viljandi'
            }, {
                code: 'EN21',
                name: 'Vru'
            }]
    }, {
        code: 'ET',
        id: 2242,
        name: 'Ethiopia',
        states: [{
                code: 'ET44',
                name: 'Addis Ababa'
            }, {
                code: 'ET45',
                name: 'Afar'
            }, {
                code: 'ET46',
                name: 'Amhara'
            }, {
                code: 'ET47',
                name: 'Benshangul-Gumaz'
            }, {
                code: 'ET48',
                name: 'Dire Dawa'
            }, {
                code: 'ET49',
                name: 'Gambela Peoples'
            }, {
                code: 'ET50',
                name: 'Harari People'
            }, {
                code: 'ET51',
                name: 'Oromia'
            }, {
                code: 'ET52',
                name: 'Somali'
            }, {
                code: 'ET54',
                name: 'Southern Nations, Nationalities and Peoples'
            }, {
                code: 'ET53',
                name: 'Tigray'
            }]
    }, {
        code: 'FJ',
        id: 2243,
        name: 'Fiji',
        states: []
    }, {
        code: 'FI',
        id: 2244,
        name: 'Finland',
        states: [{
                code: 'FI-AL',
                name: 'Ahvenanmaan lni'
            }, {
                code: 'FI-ES',
                name: 'Etel-Suomen lni'
            }, {
                code: 'FI-IS',
                name: 'It-Suomen lni'
            }, {
                code: 'FI-LL',
                name: 'Lapin lni'
            }, {
                code: 'FI-LS',
                name: 'Lnsi-Suomen lni'
            }, {
                code: 'FI-OL',
                name: 'Oulun lni'
            }]
    }, {
        code: 'FR',
        id: 2245,
        name: 'France',
        states: [{
                code: 'FRC2',
                name: 'Ain'
            }, {
                code: 'FRC3',
                name: 'Aisne'
            }, {
                code: 'FRC4',
                name: 'Allier'
            }, {
                code: 'FRC6',
                name: 'Alpes-Maritimes'
            }, {
                code: 'FRC5',
                name: 'Alpes-de-Haute-Provence'
            }, {
                code: 'FRC1',
                name: 'Alsace'
            }, {
                code: 'FR97',
                name: 'Aquitaine'
            }, {
                code: 'FRC8',
                name: 'Ardennes'
            }, {
                code: 'FRC7',
                name: 'Ardche'
            }, {
                code: 'FRC9',
                name: 'Arige'
            }, {
                code: 'FRD1',
                name: 'Aube'
            }, {
                code: 'FRD2',
                name: 'Aude'
            }, {
                code: 'FR98',
                name: 'Auvergne'
            }, {
                code: 'FRD3',
                name: 'Aveyron'
            }, {
                code: 'FRD4',
                name: 'Bas-Rhin'
            }, {
                code: 'FR99',
                name: 'Basse-Normandie'
            }, {
                code: 'FRD5',
                name: 'Bouches-du-Rhne'
            }, {
                code: 'FRA1',
                name: 'Bourgogne'
            }, {
                code: 'FRA2',
                name: 'Bretagne'
            }, {
                code: 'FRD8',
                name: 'Calvados'
            }, {
                code: 'FRD9',
                name: 'Cantal'
            }, {
                code: 'FRA3',
                name: 'Centre'
            }, {
                code: 'FRA4',
                name: 'Champagne-Ardenne'
            }, {
                code: 'FRE2',
                name: 'Charente'
            }, {
                code: 'FRE1',
                name: 'Charente-Maritime'
            }, {
                code: 'FRE3',
                name: 'Cher'
            }, {
                code: 'FRE4',
                name: 'Corrze'
            }, {
                code: 'FRE5',
                name: 'Corse-du-Sud'
            }, {
                code: 'FRE6',
                name: 'Creuse'
            }, {
                code: 'FRD6',
                name: 'Cte-d\'Or'
            }, {
                code: 'FRD7',
                name: 'Ctes-d\'Armor'
            }, {
                code: 'FRE7',
                name: 'Deux-Svres'
            }, {
                code: 'FRE8',
                name: 'Dordogne'
            }, {
                code: 'FRE9',
                name: 'Doubs'
            }, {
                code: 'FRF1',
                name: 'Drme'
            }, {
                code: 'FRF2',
                name: 'Essonne'
            }, {
                code: 'FRF4',
                name: 'Eure'
            }, {
                code: 'FRF3',
                name: 'Eure-et-Loir'
            }, {
                code: 'FRF5',
                name: 'Finistre'
            }, {
                code: 'FRA6',
                name: 'Franche-Comte'
            }, {
                code: 'FRF6',
                name: 'Gard'
            }, {
                code: 'FRF7',
                name: 'Gers'
            }, {
                code: 'FRF8',
                name: 'Gironde'
            }, {
                code: 'FRG1',
                name: 'Haut-Rhin'
            }, {
                code: 'FRG2',
                name: 'Haute-Corse'
            }, {
                code: 'FRG3',
                name: 'Haute-Garonne'
            }, {
                code: 'FRG4',
                name: 'Haute-Loire'
            }, {
                code: 'FRG5',
                name: 'Haute-Marne'
            }, {
                code: 'FRA7',
                name: 'Haute-Normandie'
            }, {
                code: 'FRG7',
                name: 'Haute-Savoie'
            }, {
                code: 'FRG6',
                name: 'Haute-Sane'
            }, {
                code: 'FRG8',
                name: 'Haute-Vienne'
            }, {
                code: 'FRG9',
                name: 'Hautes-Alpes'
            }, {
                code: 'FRH1',
                name: 'Hautes-Pyrnes'
            }, {
                code: 'FRH2',
                name: 'Hauts-de-Seine'
            }, {
                code: 'FRF9',
                name: 'Hrault'
            }, {
                code: 'FRA8',
                name: 'Ile-de-France'
            }, {
                code: 'FRH3',
                name: 'Ille-et-Vilaine'
            }, {
                code: 'FRH5',
                name: 'Indre'
            }, {
                code: 'FRH4',
                name: 'Indre-et-Loire'
            }, {
                code: 'FRH6',
                name: 'Isre'
            }, {
                code: 'FRH7',
                name: 'Jura'
            }, {
                code: 'FRH8',
                name: 'Landes'
            }, {
                code: 'FRA9',
                name: 'Languedoc-Roussillon'
            }, {
                code: 'FRB1',
                name: 'Limousin'
            }, {
                code: 'FRI3',
                name: 'Loir-et-Cher'
            }, {
                code: 'FRI1',
                name: 'Loire'
            }, {
                code: 'FRH9',
                name: 'Loire-Atlantique'
            }, {
                code: 'FRI2',
                name: 'Loiret'
            }, {
                code: 'FRB2',
                name: 'Lorraine'
            }, {
                code: 'FRI5',
                name: 'Lot'
            }, {
                code: 'FRI4',
                name: 'Lot-et-Garonne'
            }, {
                code: 'FRI6',
                name: 'Lozre'
            }, {
                code: 'FRI7',
                name: 'Maine-et-Loire'
            }, {
                code: 'FRI8',
                name: 'Manche'
            }, {
                code: 'FRI9',
                name: 'Marne'
            }, {
                code: 'FRJ1',
                name: 'Mayenne'
            }, {
                code: 'FRJ2',
                name: 'Meurthe-et-Moselle'
            }, {
                code: 'FRJ3',
                name: 'Meuse'
            }, {
                code: 'FRB3',
                name: 'Midi-Pyrenees'
            }, {
                code: 'FRJ4',
                name: 'Morbihan'
            }, {
                code: 'FRJ5',
                name: 'Moselle'
            }, {
                code: 'FRJ6',
                name: 'Nivre'
            }, {
                code: 'FRJ7',
                name: 'Nord France'
            }, {
                code: 'FRJ8',
                name: 'Oise'
            }, {
                code: 'FRJ9',
                name: 'Orne'
            }, {
                code: 'FRK1',
                name: 'Paris'
            }, {
                code: 'FRB4',
                name: 'Pas-de-Calais'
            }, {
                code: 'FRB5',
                name: 'Pays de la Loire'
            }, {
                code: 'FRB6',
                name: 'Picardie'
            }, {
                code: 'FRB7',
                name: 'Poitou-Charentes'
            }, {
                code: 'FRB8',
                name: 'Provence-Alpes-Cote d\'Azur'
            }, {
                code: 'FRK2',
                name: 'Puy-de-Dme'
            }, {
                code: 'FRK3',
                name: 'Pyrnes-Atlantiques'
            }, {
                code: 'FRK4',
                name: 'Pyrnes-Orientales'
            }, {
                code: 'FRB9',
                name: 'Rhne'
            }, {
                code: 'FRK6',
                name: 'Sarthe'
            }, {
                code: 'FRK7',
                name: 'Savoie'
            }, {
                code: 'FRK5',
                name: 'Sane-et-Loire'
            }, {
                code: 'FRK9',
                name: 'Seine-Maritime'
            }, {
                code: 'FRL1',
                name: 'Seine-Saint-Denis'
            }, {
                code: 'FRK8',
                name: 'Seine-et-Marne'
            }, {
                code: 'FRL2',
                name: 'Somme'
            }, {
                code: 'FRL4',
                name: 'Tarn'
            }, {
                code: 'FRL3',
                name: 'Tarn-et-Garonne'
            }, {
                code: 'FRL5',
                name: 'Territoire de Belfor'
            }, {
                code: 'FRL6',
                name: 'Val-d\'Oise'
            }, {
                code: 'FRL7',
                name: 'Val-de-Marne'
            }, {
                code: 'FRL8',
                name: 'Var'
            }, {
                code: 'FRL9',
                name: 'Vaucluse'
            }, {
                code: 'FRM1',
                name: 'Vende'
            }, {
                code: 'FRM2',
                name: 'Vienne'
            }, {
                code: 'FRM3',
                name: 'Vosges'
            }, {
                code: 'FRM4',
                name: 'Yonne'
            }, {
                code: 'FRM5',
                name: 'Yvelines'
            }]
    }, {
        code: 'GA',
        id: 2246,
        name: 'Gabon',
        states: [{
                code: 'GB01',
                name: 'Estuaire'
            }, {
                code: 'GB02',
                name: 'Haut-Ogoou'
            }, {
                code: 'GB03',
                name: 'Moyen-Ogoou'
            }, {
                code: 'GB04',
                name: 'Ngouni'
            }, {
                code: 'GB05',
                name: 'Nyanga'
            }, {
                code: 'GB06',
                name: 'Ogoou-Ivindo'
            }, {
                code: 'GB07',
                name: 'Ogoou-Lolo'
            }, {
                code: 'GB08',
                name: 'Ogoou-Maritime'
            }, {
                code: 'GB09',
                name: 'Woleu-Ntem'
            }]
    }, {
        code: 'GE',
        id: 2248,
        name: 'Georgia',
        states: []
    }, {
        code: 'DE',
        id: 2249,
        name: 'Germany',
        states: [{
                code: 'BW',
                name: 'Baden-Wrttemberg'
            }, {
                code: 'BY',
                name: 'Bayern'
            }, {
                code: 'BE',
                name: 'Berlin'
            }, {
                code: 'BB',
                name: 'Brandenburg'
            }, {
                code: 'HB',
                name: 'Bremen'
            }, {
                code: 'HH',
                name: 'Hamburg'
            }, {
                code: 'HE',
                name: 'Hessen'
            }, {
                code: 'MV',
                name: 'Mecklenburg-Vorpommern'
            }, {
                code: 'NI',
                name: 'Niedersachsen'
            }, {
                code: 'NW',
                name: 'Nordrhein-Westfalen'
            }, {
                code: 'RP',
                name: 'Rheinland-Pfalz'
            }, {
                code: 'SL',
                name: 'Saarland'
            }, {
                code: 'SN',
                name: 'Sachsen'
            }, {
                code: 'ST',
                name: 'Sachsen-Anhalt'
            }, {
                code: 'SH',
                name: 'Schleswig-Holstein'
            }, {
                code: 'TH',
                name: 'Thringen'
            }]
    }, {
        code: 'GH',
        id: 2250,
        name: 'Ghana',
        states: [{
                code: 'GH02',
                name: 'Ashanti'
            }, {
                code: 'GH03',
                name: 'Brong-Ahafo'
            }, {
                code: 'GH04',
                name: 'Central'
            }, {
                code: 'GH05',
                name: 'Eastern'
            }, {
                code: 'GH01',
                name: 'Greater Accra'
            }, {
                code: 'GH06',
                name: 'Northern'
            }, {
                code: 'GH10',
                name: 'Upper East'
            }, {
                code: 'GH11',
                name: 'Upper West'
            }, {
                code: 'GH08',
                name: 'Volta'
            }, {
                code: 'GH09',
                name: 'Western'
            }]
    }, {
        code: 'GR',
        id: 2251,
        name: 'Greece',
        states: [{
                code: '13',
                name: 'Achaa'
            }, {
                code: '69',
                name: 'Agio Oros'
            }, {
                code: '01',
                name: 'Aitolia kai Akarnania'
            }, {
                code: '11',
                name: 'Argolida'
            }, {
                code: '12',
                name: 'Arkadia'
            }, {
                code: '31',
                name: 'Arta'
            }, {
                code: 'A1',
                name: 'Attiki'
            }, {
                code: '64',
                name: 'Chalkidiki'
            }, {
                code: '94',
                name: 'Chania'
            }, {
                code: '85',
                name: 'Chios'
            }, {
                code: '81',
                name: 'Dodekanisos'
            }, {
                code: '52',
                name: 'Drama'
            }, {
                code: '71',
                name: 'Evros'
            }, {
                code: '05',
                name: 'Evrytania'
            }, {
                code: '04',
                name: 'Evvoia'
            }, {
                code: '63',
                name: 'Florina'
            }, {
                code: '07',
                name: 'Fokida'
            }, {
                code: '06',
                name: 'Fthiotida'
            }, {
                code: '51',
                name: 'Grevena'
            }, {
                code: '14',
                name: 'Ileia'
            }, {
                code: '53',
                name: 'Imathia'
            }, {
                code: '33',
                name: 'Ioannina'
            }, {
                code: '91',
                name: 'Irakleio'
            }, {
                code: '41',
                name: 'Karditsa'
            }, {
                code: '56',
                name: 'Kastoria'
            }, {
                code: '55',
                name: 'Kavala'
            }, {
                code: '23',
                name: 'Kefallonia'
            }, {
                code: '22',
                name: 'Kerkyra'
            }, {
                code: '57',
                name: 'Kilkis'
            }, {
                code: '15',
                name: 'Korinthia'
            }, {
                code: '58',
                name: 'Kozani'
            }, {
                code: '82',
                name: 'Kyklades'
            }, {
                code: '16',
                name: 'Lakonia'
            }, {
                code: '42',
                name: 'Larisa'
            }, {
                code: '92',
                name: 'Lasithi'
            }, {
                code: '24',
                name: 'Lefkada'
            }, {
                code: '83',
                name: 'Lesvos'
            }, {
                code: '43',
                name: 'Magnisia'
            }, {
                code: '17',
                name: 'Messinia'
            }, {
                code: '59',
                name: 'Pella'
            }, {
                code: '61',
                name: 'Pieria'
            }, {
                code: '34',
                name: 'Preveza'
            }, {
                code: '93',
                name: 'Rethymno'
            }, {
                code: '73',
                name: 'Rodopi'
            }, {
                code: '84',
                name: 'Samos'
            }, {
                code: '62',
                name: 'Serres'
            }, {
                code: '32',
                name: 'Thesprotia'
            }, {
                code: '54',
                name: 'Thessaloniki'
            }, {
                code: '44',
                name: 'Trikala'
            }, {
                code: '03',
                name: 'Voiotia'
            }, {
                code: '72',
                name: 'Xanthi'
            }, {
                code: '21',
                name: 'Zakynthos'
            }]
    }, {
        code: 'GL',
        id: 2252,
        name: 'Greenland',
        states: []
    }, {
        code: 'GD',
        id: 2253,
        name: 'Grenada',
        states: []
    }, {
        code: 'GN',
        id: 2255,
        name: 'Guinea',
        states: []
    }, {
        code: 'GW',
        id: 2256,
        name: 'Guinea-Bissau',
        states: []
    }, {
        code: 'GY',
        id: 2257,
        name: 'Guyana',
        states: []
    }, {
        code: 'HT',
        id: 2258,
        name: 'Haiti',
        states: [{
                code: 'HA07',
                name: 'Centre'
            }, {
                code: 'HA14',
                name: 'Grand\' Anse'
            }, {
                code: 'HA06',
                name: 'L\'Artibonite'
            }, {
                code: 'HA15',
                name: 'Nippes'
            }, {
                code: 'HA09',
                name: 'Nord'
            }, {
                code: 'HA10',
                name: 'Nord-Est'
            }, {
                code: 'HA03',
                name: 'Nord-Ouest'
            }, {
                code: 'HA11',
                name: 'Ouest'
            }, {
                code: 'HA12',
                name: 'Sud'
            }, {
                code: 'HA13',
                name: 'Sud-Est'
            }]
    }, {
        code: 'HN',
        id: 2259,
        name: 'Honduras',
        states: [{
                code: 'HO01',
                name: 'Atlntida'
            }, {
                code: 'HO02',
                name: 'Choluteca'
            }, {
                code: 'HO03',
                name: 'Coln'
            }, {
                code: 'HO04',
                name: 'Comayagua'
            }, {
                code: 'HO05',
                name: 'Copn'
            }, {
                code: 'HO06',
                name: 'Corts'
            }, {
                code: 'HO07',
                name: 'El Paraso'
            }, {
                code: 'HO08',
                name: 'Francisco Morazn'
            }, {
                code: 'HO09',
                name: 'Gracias a Dios'
            }, {
                code: 'HO10',
                name: 'Intibuc'
            }, {
                code: 'HO11',
                name: 'Islas de la Baha'
            }, {
                code: 'HO12',
                name: 'La Paz'
            }, {
                code: 'HO13',
                name: 'Lempira'
            }, {
                code: 'HO14',
                name: 'Ocotepeque'
            }, {
                code: 'HO15',
                name: 'Olancho'
            }, {
                code: 'HO16',
                name: 'Santa Brbara'
            }, {
                code: 'HO17',
                name: 'Valle'
            }, {
                code: 'HO18',
                name: 'Yoro'
            }]
    }, {
        code: 'HU',
        id: 2260,
        name: 'Hungary',
        states: [{
                code: 'BA',
                name: 'Baranya'
            }, {
                code: 'BZ',
                name: 'Borsod-Abaj-Zempln'
            }, {
                code: 'BU',
                name: 'Budapest'
            }, {
                code: 'BK',
                name: 'Bcs-Kiskun'
            }, {
                code: 'BE',
                name: 'Bks'
            }, {
                code: 'BC',
                name: 'Bkscsaba'
            }, {
                code: 'CS',
                name: 'Csongrd'
            }, {
                code: 'DE',
                name: 'Debrecen'
            }, {
                code: 'DU',
                name: 'Dunajvros'
            }, {
                code: 'EG',
                name: 'Eger'
            }, {
                code: 'ER',
                name: 'Erd'
            }, {
                code: 'FE',
                name: 'Fejr'
            }, {
                code: 'GY',
                name: 'Gyor'
            }, {
                code: 'GS',
                name: 'Gyor-Moson-Sopron'
            }, {
                code: 'HB',
                name: 'Hajd-Bihar'
            }, {
                code: 'HE',
                name: 'Heves'
            }, {
                code: 'HV',
                name: 'Hdmezovsrhely'
            }, {
                code: 'JN',
                name: 'Jsz-Nagykun-Szolnok'
            }, {
                code: 'KV',
                name: 'Kaposvr'
            }, {
                code: 'KM',
                name: 'Kecskemt'
            }, {
                code: 'KE',
                name: 'Komrom-Esztergom'
            }, {
                code: 'MI',
                name: 'Miskolc'
            }, {
                code: 'NK',
                name: 'Nagykanizsa'
            }, {
                code: 'NY',
                name: 'Nyregyhza'
            }, {
                code: 'NO',
                name: 'Ngrd'
            }, {
                code: 'PE',
                name: 'Pest'
            }, {
                code: 'PS',
                name: 'Pcs'
            }, {
                code: 'ST',
                name: 'Salgtarjn'
            }, {
                code: 'SO',
                name: 'Somogy'
            }, {
                code: 'SN',
                name: 'Sopron'
            }, {
                code: 'SZ',
                name: 'Szabolcs-Szatmr-Bereg'
            }, {
                code: 'SD',
                name: 'Szeged'
            }, {
                code: 'SS',
                name: 'Szekszrd'
            }, {
                code: 'SK',
                name: 'Szolnok'
            }, {
                code: 'SH',
                name: 'Szombathely'
            }, {
                code: 'SF',
                name: 'Szkesfehrvr'
            }, {
                code: 'TB',
                name: 'Tatabnya'
            }, {
                code: 'TO',
                name: 'Tolna'
            }, {
                code: 'VA',
                name: 'Vas'
            }, {
                code: 'VE',
                name: 'Veszprm'
            }, {
                code: 'VM',
                name: 'Veszprm City'
            }, {
                code: 'ZA',
                name: 'Zala'
            }, {
                code: 'ZE',
                name: 'Zalaegerszeg'
            }]
    }, {
        code: 'IS',
        id: 2261,
        name: 'Iceland',
        states: [{
                code: '7',
                name: 'Austurland'
            }, {
                code: '1',
                name: 'Hfuborgarsvi utan Reykjavkur'
            }, {
                code: '6',
                name: 'Norurland eystra'
            }, {
                code: '5',
                name: 'Norurland vestra'
            }, {
                code: '0',
                name: 'Reykjavk'
            }, {
                code: '8',
                name: 'Suurland'
            }, {
                code: '2',
                name: 'Suurnes'
            }, {
                code: '4',
                name: 'Vestfirir'
            }, {
                code: '3',
                name: 'Vesturland'
            }]
    }, {
        code: 'IN',
        id: 2262,
        name: 'India',
        states: [{
                code: 'AN',
                name: 'Andaman and Nicobar Islands'
            }, {
                code: 'AP',
                name: 'Andhra Pradesh'
            }, {
                code: 'AR',
                name: 'Arunachal Pradesh'
            }, {
                code: 'AS',
                name: 'Assam'
            }, {
                code: 'BR',
                name: 'Bihar'
            }, {
                code: 'CH',
                name: 'Chandigarh'
            }, {
                code: 'CT',
                name: 'Chhattisgarh'
            }, {
                code: 'DN',
                name: 'Dadra and Nagar Haveli'
            }, {
                code: 'DD',
                name: 'Daman and Diu'
            }, {
                code: 'DL',
                name: 'Delhi'
            }, {
                code: 'GA',
                name: 'Goa'
            }, {
                code: 'GJ',
                name: 'Gujarat'
            }, {
                code: 'HR',
                name: 'Haryana'
            }, {
                code: 'HP',
                name: 'Himachal Pradesh'
            }, {
                code: 'JK',
                name: 'Jammu and Kashmir'
            }, {
                code: 'JH',
                name: 'Jharkhand'
            }, {
                code: 'KA',
                name: 'Karnataka'
            }, {
                code: 'KL',
                name: 'Kerala'
            }, {
                code: 'LD',
                name: 'Lakshadweep'
            }, {
                code: 'MP',
                name: 'Madhya Pradesh'
            }, {
                code: 'MH',
                name: 'Maharashtra'
            }, {
                code: 'MN',
                name: 'Manipur'
            }, {
                code: 'ML',
                name: 'Meghalaya'
            }, {
                code: 'MZ',
                name: 'Mizoram'
            }, {
                code: 'NL',
                name: 'Nagaland'
            }, {
                code: 'OR',
                name: 'Orissa'
            }, {
                code: 'PY',
                name: 'Pondicherry'
            }, {
                code: 'PB',
                name: 'Punjab'
            }, {
                code: 'RJ',
                name: 'Rajasthan'
            }, {
                code: 'SK',
                name: 'Sikkim'
            }, {
                code: 'TN',
                name: 'Tamil Nadu'
            }, {
                code: 'TR',
                name: 'Tripura'
            }, {
                code: 'UP',
                name: 'Uttar Pradesh'
            }, {
                code: 'UL',
                name: 'Uttaranchal'
            }, {
                code: 'WB',
                name: 'West Bengal'
            }]
    }, {
        code: 'ID',
        id: 2263,
        name: 'Indonesia',
        states: [{
                code: 'AC',
                name: 'Aceh'
            }, {
                code: 'BA',
                name: 'Bali'
            }, {
                code: 'BB',
                name: 'Bangka Belitung'
            }, {
                code: 'BT',
                name: 'Banten'
            }, {
                code: 'BE',
                name: 'Bengkulu'
            }, {
                code: 'GO',
                name: 'Gorontalo'
            }, {
                code: 'JK',
                name: 'Jakarta Raya'
            }, {
                code: 'JA',
                name: 'Jambi'
            }, {
                code: 'JB',
                name: 'Jawa Barat'
            }, {
                code: 'JT',
                name: 'Jawa Tengah'
            }, {
                code: 'JI',
                name: 'Jawa Timur'
            }, {
                code: 'KB',
                name: 'Kalimantan Barat'
            }, {
                code: 'KS',
                name: 'Kalimantan Selatan'
            }, {
                code: 'KT',
                name: 'Kalimantan Tengah'
            }, {
                code: 'KI',
                name: 'Kalimantan Timur'
            }, {
                code: 'KR',
                name: 'Kepulauan Riau'
            }, {
                code: 'LA',
                name: 'Lampung'
            }, {
                code: 'MA',
                name: 'Maluku'
            }, {
                code: 'MU',
                name: 'Maluku Utara'
            }, {
                code: 'NB',
                name: 'Nusa Tenggara Barat'
            }, {
                code: 'NT',
                name: 'Nusa Tenggara Timur'
            }, {
                code: 'PA',
                name: 'Papua'
            }, {
                code: 'PB',
                name: 'Papua Barat'
            }, {
                code: 'RI',
                name: 'Riau'
            }, {
                code: 'SR',
                name: 'Sulawesi Barat'
            }, {
                code: 'SN',
                name: 'Sulawesi Selatan'
            }, {
                code: 'ST',
                name: 'Sulawesi Tengah'
            }, {
                code: 'SG',
                name: 'Sulawesi Tenggara'
            }, {
                code: 'SA',
                name: 'Sulawesi Utara'
            }, {
                code: 'SB',
                name: 'Sumatera Barat'
            }, {
                code: 'SS',
                name: 'Sumatera Selatan'
            }, {
                code: 'SU',
                name: 'Sumatera Utara'
            }, {
                code: 'YO',
                name: 'Yogyakarta'
            }]
    }, {
        code: 'IR',
        id: 2264,
        name: 'Iran; Islamic Republic of',
        states: [{
                code: 'IR44',
                name: 'Alborz'
            }, {
                code: 'IR32',
                name: 'Ardebil'
            }, {
                code: 'IR22',
                name: 'Bushehr'
            }, {
                code: 'IR03',
                name: 'Chahar Mahall and Bakhtiari'
            }, {
                code: 'IR33',
                name: 'East Azarbaijan'
            }, {
                code: 'IR28',
                name: 'Esfahan'
            }, {
                code: 'IR07',
                name: 'Fars'
            }, {
                code: 'IR08',
                name: 'Gilan'
            }, {
                code: 'IR37',
                name: 'Golestan'
            }, {
                code: 'IR09',
                name: 'Hamadan'
            }, {
                code: 'IR11',
                name: 'Hormozgan'
            }, {
                code: 'IR42',
                name: 'IRazavi Khorasan'
            }, {
                code: 'IR10',
                name: 'Ilam'
            }, {
                code: 'IR29',
                name: 'Kerman'
            }, {
                code: 'IR13',
                name: 'Kermanshah'
            }, {
                code: 'IR15',
                name: 'Khuzestan'
            }, {
                code: 'IR05',
                name: 'Kohgiluyeh and Buyer Ahmad'
            }, {
                code: 'IR16',
                name: 'Kordestan'
            }, {
                code: 'IR23',
                name: 'Lorestan'
            }, {
                code: 'IR34',
                name: 'Markazi'
            }, {
                code: 'IR35',
                name: 'Mazandaran'
            }, {
                code: 'IR43',
                name: 'North Khorasan'
            }, {
                code: 'IR38',
                name: 'Qazvin'
            }, {
                code: 'IR39',
                name: 'Qom'
            }, {
                code: 'IR25',
                name: 'Semnan'
            }, {
                code: 'IR04',
                name: 'Sistan and Baluchestan'
            }, {
                code: 'IR41',
                name: 'South Khorasan'
            }, {
                code: 'IR26',
                name: 'Tehran'
            }, {
                code: 'IR01',
                name: 'West Azarbaijan'
            }, {
                code: 'IR40',
                name: 'Yazd'
            }, {
                code: 'IR36',
                name: 'Zanjan'
            }]
    }, {
        code: 'IQ',
        id: 2265,
        name: 'Iraq',
        states: [{
                code: 'IZ01',
                name: 'Al-Anbar'
            }, {
                code: 'IZ02',
                name: 'Al-Basrah'
            }, {
                code: 'IZ03',
                name: 'Al-Muthanna'
            }, {
                code: 'IZ04',
                name: 'Al-Qadisiyah'
            }, {
                code: 'IZ17',
                name: 'An-Najaf'
            }, {
                code: 'IZ11',
                name: 'Arbil'
            }, {
                code: 'IZ05',
                name: 'As-Sulaymaniyah'
            }, {
                code: 'IZ13',
                name: 'At-Ta\'mim'
            }, {
                code: 'IZ06',
                name: 'Babil'
            }, {
                code: 'IZ07',
                name: 'Baghdad'
            }, {
                code: 'IZ08',
                name: 'Dahuk'
            }, {
                code: 'IZ09',
                name: 'Dhi Qar'
            }, {
                code: 'IZ10',
                name: 'Diyala'
            }, {
                code: 'IZ12',
                name: 'Karbala'
            }, {
                code: 'IZ14',
                name: 'Maysan'
            }, {
                code: 'IZ15',
                name: 'Ninawa'
            }, {
                code: 'IZ18',
                name: 'Salah ad-Din'
            }, {
                code: 'IZ16',
                name: 'Wasit'
            }]
    }, {
        code: 'IE',
        id: 2266,
        name: 'Ireland',
        states: [{
                code: 'CW',
                name: 'Carlow'
            }, {
                code: 'CN',
                name: 'Cavan'
            }, {
                code: 'CE',
                name: 'Clare'
            }, {
                code: 'C',
                name: 'Cork'
            }, {
                code: 'DL',
                name: 'Donegal'
            }, {
                code: 'D',
                name: 'Dublin'
            }, {
                code: 'G',
                name: 'Galway'
            }, {
                code: 'KY',
                name: 'Kerry'
            }, {
                code: 'KE',
                name: 'Kildare'
            }, {
                code: 'KK',
                name: 'Kilkenny'
            }, {
                code: 'LS',
                name: 'Laois'
            }, {
                code: 'LM',
                name: 'Leitrim'
            }, {
                code: 'LK',
                name: 'Limerick'
            }, {
                code: 'LD',
                name: 'Longford'
            }, {
                code: 'LH',
                name: 'Louth'
            }, {
                code: 'MO',
                name: 'Mayo'
            }, {
                code: 'MH',
                name: 'Meath'
            }, {
                code: 'MN',
                name: 'Monaghan'
            }, {
                code: 'OY',
                name: 'Offaly'
            }, {
                code: 'RN',
                name: 'Roscommon'
            }, {
                code: 'SO',
                name: 'Sligo'
            }, {
                code: 'TA',
                name: 'Tipperary'
            }, {
                code: 'WD',
                name: 'Waterford'
            }, {
                code: 'WH',
                name: 'Westmeath'
            }, {
                code: 'WX',
                name: 'Wexford'
            }, {
                code: 'WW',
                name: 'Wicklow'
            }]
    }, {
        code: 'IL',
        id: 2267,
        name: 'Israel',
        states: [{
                code: 'IS01',
                name: 'HaDarom'
            }, {
                code: 'IS02',
                name: 'HaMerkaz'
            }, {
                code: 'IS03',
                name: 'HaZafon'
            }, {
                code: 'IS04',
                name: 'Haifa'
            }, {
                code: 'IS06',
                name: 'Jerusalem'
            }, {
                code: 'IS05',
                name: 'Tel Aviv'
            }]
    }, {
        code: 'IT',
        id: 2268,
        name: 'Italy',
        states: [{
                code: '65',
                name: 'Abruzzo'
            }, {
                code: 'AG',
                name: 'Agrigento'
            }, {
                code: 'AL',
                name: 'Alessandria'
            }, {
                code: 'AN',
                name: 'Ancona'
            }, {
                code: 'AO',
                name: 'Aosta'
            }, {
                code: 'AR',
                name: 'Arezzo'
            }, {
                code: 'AP',
                name: 'Ascoli Piceno'
            }, {
                code: 'AT',
                name: 'Asti'
            }, {
                code: 'AV',
                name: 'Avellino'
            }, {
                code: 'BA',
                name: 'Bari'
            }, {
                code: 'BT',
                name: 'Barletta-Andria-Trani'
            }, {
                code: '77',
                name: 'Basilicata'
            }, {
                code: 'BL',
                name: 'Belluno'
            }, {
                code: 'BN',
                name: 'Benevento'
            }, {
                code: 'BG',
                name: 'Bergamo'
            }, {
                code: 'BI',
                name: 'Biella'
            }, {
                code: 'BO',
                name: 'Bologna'
            }, {
                code: 'BZ',
                name: 'Bolzano'
            }, {
                code: 'BS',
                name: 'Brescia'
            }, {
                code: 'BR',
                name: 'Brindisi'
            }, {
                code: 'CA',
                name: 'Cagliari'
            }, {
                code: '78',
                name: 'Calabria'
            }, {
                code: 'CL',
                name: 'Caltanissetta'
            }, {
                code: '72',
                name: 'Campania'
            }, {
                code: 'CB',
                name: 'Campobasso'
            }, {
                code: 'CI',
                name: 'Carbonia-Iglesias'
            }, {
                code: 'CE',
                name: 'Caserta'
            }, {
                code: 'CT',
                name: 'Catania'
            }, {
                code: 'CZ',
                name: 'Catanzaro'
            }, {
                code: 'CH',
                name: 'Chieti'
            }, {
                code: 'CO',
                name: 'Como'
            }, {
                code: 'CS',
                name: 'Cosenza'
            }, {
                code: 'CR',
                name: 'Cremona'
            }, {
                code: 'KR',
                name: 'Crotone'
            }, {
                code: 'CN',
                name: 'Cuneo'
            }, {
                code: '45',
                name: 'Emilia-Romagna'
            }, {
                code: 'EN',
                name: 'Enna'
            }, {
                code: 'FM',
                name: 'Fermo'
            }, {
                code: 'FE',
                name: 'Ferrara'
            }, {
                code: 'FI',
                name: 'Firenze'
            }, {
                code: 'FG',
                name: 'Foggia'
            }, {
                code: 'FC',
                name: 'Forli-Cesena'
            }, {
                code: '36',
                name: 'Friuli-Venezia Giulia'
            }, {
                code: 'FR',
                name: 'Frosinone'
            }, {
                code: 'GE',
                name: 'Genova'
            }, {
                code: 'GO',
                name: 'Gorizia'
            }, {
                code: 'GR',
                name: 'Grosseto'
            }, {
                code: 'IM',
                name: 'Imperia'
            }, {
                code: 'IS',
                name: 'Isernia'
            }, {
                code: 'AQ',
                name: 'L\'Aquila'
            }, {
                code: 'SP',
                name: 'La Spezia'
            }, {
                code: 'LT',
                name: 'Latina'
            }, {
                code: '62',
                name: 'Lazio'
            }, {
                code: 'LE',
                name: 'Lecce'
            }, {
                code: 'LC',
                name: 'Lecco'
            }, {
                code: '42',
                name: 'Liguria'
            }, {
                code: 'LI',
                name: 'Livorno'
            }, {
                code: 'LO',
                name: 'Lodi'
            }, {
                code: '25',
                name: 'Lombardia'
            }, {
                code: 'LU',
                name: 'Lucca'
            }, {
                code: 'MC',
                name: 'Macerata'
            }, {
                code: 'MN',
                name: 'Mantova'
            }, {
                code: '57',
                name: 'Marche'
            }, {
                code: 'MS',
                name: 'Massa-Carrara'
            }, {
                code: 'MT',
                name: 'Matera'
            }, {
                code: 'VS',
                name: 'Medio Campidano'
            }, {
                code: 'ME',
                name: 'Messina'
            }, {
                code: 'MI',
                name: 'Milano'
            }, {
                code: 'MO',
                name: 'Modena'
            }, {
                code: '67',
                name: 'Molise'
            }, {
                code: 'MB',
                name: 'Monza e Brianza'
            }, {
                code: 'NA',
                name: 'Napoli'
            }, {
                code: 'NO',
                name: 'Novara'
            }, {
                code: 'NU',
                name: 'Nuoro'
            }, {
                code: 'OG',
                name: 'Ogliastra'
            }, {
                code: 'OT',
                name: 'Olbia-Tempio'
            }, {
                code: 'OR',
                name: 'Oristano'
            }, {
                code: 'PD',
                name: 'Padova'
            }, {
                code: 'PA',
                name: 'Palermo'
            }, {
                code: 'PR',
                name: 'Parma'
            }, {
                code: 'PV',
                name: 'Pavia'
            }, {
                code: 'PG',
                name: 'Perugia'
            }, {
                code: 'PU',
                name: 'Pesaro e Urbino'
            }, {
                code: 'PE',
                name: 'Pescara'
            }, {
                code: 'PC',
                name: 'Piacenza'
            }, {
                code: '21',
                name: 'Piemonte'
            }, {
                code: 'PI',
                name: 'Pisa'
            }, {
                code: 'PT',
                name: 'Pistoia'
            }, {
                code: 'PN',
                name: 'Pordenone'
            }, {
                code: 'PZ',
                name: 'Potenza'
            }, {
                code: 'PO',
                name: 'Prato'
            }, {
                code: '75',
                name: 'Puglia'
            }, {
                code: 'RG',
                name: 'Ragusa'
            }, {
                code: 'RA',
                name: 'Ravenna'
            }, {
                code: 'RC',
                name: 'Reggio Calabria'
            }, {
                code: 'RE',
                name: 'Reggio Emilia'
            }, {
                code: 'RI',
                name: 'Rieti'
            }, {
                code: 'RN',
                name: 'Rimini'
            }, {
                code: 'RM',
                name: 'Roma'
            }, {
                code: 'RO',
                name: 'Rovigo'
            }, {
                code: 'SA',
                name: 'Salerno'
            }, {
                code: '88',
                name: 'Sardegna'
            }, {
                code: 'SS',
                name: 'Sassari'
            }, {
                code: 'SV',
                name: 'Savona'
            }, {
                code: '82',
                name: 'Sicilia'
            }, {
                code: 'SI',
                name: 'Siena'
            }, {
                code: 'SR',
                name: 'Siracusa'
            }, {
                code: 'SO',
                name: 'Sondrio'
            }, {
                code: 'TA',
                name: 'Taranto'
            }, {
                code: 'TE',
                name: 'Teramo'
            }, {
                code: 'TR',
                name: 'Terni'
            }, {
                code: 'TO',
                name: 'Torino'
            }, {
                code: '52',
                name: 'Toscana'
            }, {
                code: 'TP',
                name: 'Trapani'
            }, {
                code: '32',
                name: 'Trentino-Alto Adige'
            }, {
                code: 'TN',
                name: 'Trento'
            }, {
                code: 'TV',
                name: 'Treviso'
            }, {
                code: 'TS',
                name: 'Trieste'
            }, {
                code: 'UD',
                name: 'Udine'
            }, {
                code: '55',
                name: 'Umbria'
            }, {
                code: '23',
                name: 'Valle d\'Aosta'
            }, {
                code: 'VA',
                name: 'Varese'
            }, {
                code: '34',
                name: 'Veneto'
            }, {
                code: 'VE',
                name: 'Venezia'
            }, {
                code: 'VB',
                name: 'Verbano-Cusio-Ossola'
            }, {
                code: 'VC',
                name: 'Vercelli'
            }, {
                code: 'VR',
                name: 'Verona'
            }, {
                code: 'VV',
                name: 'Vibo Valentia'
            }, {
                code: 'VI',
                name: 'Vicenza'
            }, {
                code: 'VT',
                name: 'Viterbo'
            }]
    }, {
        code: 'JM',
        id: 2269,
        name: 'Jamaica',
        states: []
    }, {
        code: 'JP',
        id: 2270,
        name: 'Japan',
        states: [{
                code: 'JP23',
                name: 'Aichi'
            }, {
                code: 'JP05',
                name: 'Akita'
            }, {
                code: 'JP02',
                name: 'Aomori'
            }, {
                code: 'JP12',
                name: 'Chiba'
            }, {
                code: 'JP38',
                name: 'Ehime'
            }, {
                code: 'JP18',
                name: 'Fukui'
            }, {
                code: 'JP40',
                name: 'Fukuoka'
            }, {
                code: 'JP07',
                name: 'Fukushima'
            }, {
                code: 'JP21',
                name: 'Gifu'
            }, {
                code: 'JP10',
                name: 'Gunma'
            }, {
                code: 'JP34',
                name: 'Hiroshima'
            }, {
                code: 'JP01',
                name: 'Hokkaido'
            }, {
                code: 'JP28',
                name: 'Hyogo'
            }, {
                code: 'JP08',
                name: 'Ibaraki'
            }, {
                code: 'JP17',
                name: 'Ishikawa'
            }, {
                code: 'JP03',
                name: 'Iwate'
            }, {
                code: 'JP37',
                name: 'Kagawa'
            }, {
                code: 'JP46',
                name: 'Kagoshima'
            }, {
                code: 'JP14',
                name: 'Kanagawa'
            }, {
                code: 'JP39',
                name: 'Kochi'
            }, {
                code: 'JP43',
                name: 'Kumamoto'
            }, {
                code: 'JP26',
                name: 'Kyoto'
            }, {
                code: 'JP24',
                name: 'Mie'
            }, {
                code: 'JP04',
                name: 'Miyagi'
            }, {
                code: 'JP45',
                name: 'Miyazaki'
            }, {
                code: 'JP20',
                name: 'Nagano'
            }, {
                code: 'JP42',
                name: 'Nagasaki'
            }, {
                code: 'JP29',
                name: 'Nara'
            }, {
                code: 'JP15',
                name: 'Niigata'
            }, {
                code: 'JP44',
                name: 'Oita'
            }, {
                code: 'JP33',
                name: 'Okayama'
            }, {
                code: 'JP47',
                name: 'Okinawa'
            }, {
                code: 'JP27',
                name: 'Osaka'
            }, {
                code: 'JP41',
                name: 'Saga'
            }, {
                code: 'JP11',
                name: 'Saitama'
            }, {
                code: 'JP25',
                name: 'Shiga'
            }, {
                code: 'JP32',
                name: 'Shimane'
            }, {
                code: 'JP22',
                name: 'Shizuoka'
            }, {
                code: 'JP09',
                name: 'Tochigi'
            }, {
                code: 'JP36',
                name: 'Tokushima'
            }, {
                code: 'JP13',
                name: 'Tokyo'
            }, {
                code: 'JP31',
                name: 'Tottori'
            }, {
                code: 'JP16',
                name: 'Toyama'
            }, {
                code: 'JP30',
                name: 'Wakayama'
            }, {
                code: 'JP06',
                name: 'Yamagata'
            }, {
                code: 'JP35',
                name: 'Yamaguchi'
            }, {
                code: 'JP19',
                name: 'Yamanashi'
            }]
    }, {
        code: 'JO',
        id: 2271,
        name: 'Jordan',
        states: [{
                code: 'JO01',
                name: 'Ajlun'
            }, {
                code: 'JO02',
                name: 'Amman'
            }, {
                code: 'JO03',
                name: 'Aqaba'
            }, {
                code: 'JO04',
                name: 'Balqa'
            }, {
                code: 'JO05',
                name: 'Irbid'
            }, {
                code: 'JO06',
                name: 'JarasJ'
            }, {
                code: 'JO07',
                name: 'Karak'
            }, {
                code: 'JO08',
                name: 'Ma\'an'
            }, {
                code: 'JO09',
                name: 'Madaba'
            }, {
                code: 'JO10',
                name: 'Mafraq'
            }, {
                code: 'JO11',
                name: 'Tafilah'
            }, {
                code: 'JO12',
                name: 'Zarqa'
            }]
    }, {
        code: 'KZ',
        id: 2272,
        name: 'Kazakhstan',
        states: [{
                code: 'KZ01',
                name: 'Almaty'
            }, {
                code: 'KZ02',
                name: 'Almaty (City)'
            }, {
                code: 'KZ03',
                name: 'Aqmola'
            }, {
                code: 'KZ04',
                name: 'Aqtbe'
            }, {
                code: 'KZ05',
                name: 'Astana'
            }, {
                code: 'KZ06',
                name: 'Atyrau'
            }, {
                code: 'KZ08',
                name: 'Bayqonyr'
            }, {
                code: 'KZ15',
                name: 'East Kazakhstan'
            }, {
                code: 'KZ09',
                name: 'Mangghystau'
            }, {
                code: 'KZ16',
                name: 'North Kazakhstan'
            }, {
                code: 'KZ11',
                name: 'Pavlodar'
            }, {
                code: 'KZ12',
                name: 'Qaraghandy'
            }, {
                code: 'KZ13',
                name: 'Qostanay'
            }, {
                code: 'KZ14',
                name: 'Qyzylorda'
            }, {
                code: 'KZ10',
                name: 'South Kazakhstan'
            }, {
                code: 'KZ07',
                name: 'West Kazakhstan'
            }, {
                code: 'KZ17',
                name: 'Zhambyl'
            }]
    }, {
        code: 'KE',
        id: 2273,
        name: 'Kenya',
        states: [{
                code: 'KE10',
                name: 'Baringo'
            }, {
                code: 'KE11',
                name: 'Bomet'
            }, {
                code: 'KE12',
                name: 'Bungoma'
            }, {
                code: 'KE13',
                name: 'Busia'
            }, {
                code: 'KE14',
                name: 'Elgeyo Marakwet'
            }, {
                code: 'KE15',
                name: 'Embu'
            }, {
                code: 'KE16',
                name: 'Garissa'
            }, {
                code: 'KE17',
                name: 'Homa Bay'
            }, {
                code: 'KE18',
                name: 'Isiolo'
            }, {
                code: 'KE19',
                name: 'Kajiado'
            }, {
                code: 'KE20',
                name: 'Kakamega'
            }, {
                code: 'KE21',
                name: 'Kericho'
            }, {
                code: 'KE22',
                name: 'Kiambu'
            }, {
                code: 'KE23',
                name: 'Kilifi'
            }, {
                code: 'KE24',
                name: 'Kirinyaga'
            }, {
                code: 'KE25',
                name: 'Kisii'
            }, {
                code: 'KE26',
                name: 'Kisumu'
            }, {
                code: 'KE27',
                name: 'Kitui'
            }, {
                code: 'KE28',
                name: 'Kwale'
            }, {
                code: 'KE29',
                name: 'Laikipia'
            }, {
                code: 'KE30',
                name: 'Lamu'
            }, {
                code: 'KE31',
                name: 'Machakos'
            }, {
                code: 'KE32',
                name: 'Makueni'
            }, {
                code: 'KE33',
                name: 'Mandera'
            }, {
                code: 'KE34',
                name: 'Marsabit'
            }, {
                code: 'KE35',
                name: 'Meru'
            }, {
                code: 'KE36',
                name: 'Migori'
            }, {
                code: 'KE37',
                name: 'Mombasa'
            }, {
                code: 'KE38',
                name: 'Murang'
            }, {
                code: 'KE05',
                name: 'Nairobi'
            }, {
                code: 'KE39',
                name: 'Nakuru'
            }, {
                code: 'KE40',
                name: 'Nandi'
            }, {
                code: 'KE41',
                name: 'Narok'
            }, {
                code: 'KE42',
                name: 'Nyamira'
            }, {
                code: 'KE43',
                name: 'Nyandarua'
            }, {
                code: 'KE44',
                name: 'Nyeri'
            }, {
                code: 'KE45',
                name: 'Samburu'
            }, {
                code: 'KE46',
                name: 'Siaya'
            }, {
                code: 'KE47',
                name: 'Taita Taveta'
            }, {
                code: 'KE48',
                name: 'Tana River'
            }, {
                code: 'KE49',
                name: 'Tharaka Nithi'
            }, {
                code: 'KE50',
                name: 'Trans Nzoia'
            }, {
                code: 'KE51',
                name: 'Turkana'
            }, {
                code: 'KE52',
                name: 'Uasin Gishu'
            }, {
                code: 'KE53',
                name: 'Vihiga'
            }, {
                code: 'KE54',
                name: 'Wajir'
            }, {
                code: 'KE55',
                name: 'West Pokot'
            }]
    }, {
        code: 'KP',
        id: 2274,
        name: 'Korea; Democratic People\'s Republic Of (North)',
        states: [{
                code: 'KN01',
                name: 'Chagang-do'
            }, {
                code: 'KN17',
                name: 'Hamgyong-bukto'
            }, {
                code: 'KN03',
                name: 'Hamgyong-namdo'
            }, {
                code: 'KN07',
                name: 'Hwanghae-bukto'
            }, {
                code: 'KN06',
                name: 'Hwanghae-namdo'
            }, {
                code: 'KN09',
                name: 'Kangwon-do'
            }, {
                code: 'KN18',
                name: 'Najin Sonbong-si'
            }, {
                code: 'KN11',
                name: 'P\'yongan-bukto'
            }, {
                code: 'KN15',
                name: 'P\'yongan-namdo'
            }, {
                code: 'KN12',
                name: 'P\'yongyang-si'
            }, {
                code: 'KN13',
                name: 'Yanggang-do'
            }]
    }, {
        code: 'KR',
        id: 2275,
        name: 'Korea; Republic Of (South)',
        states: [{
                code: 'KS10',
                name: 'Busan'
            }, {
                code: 'KS05',
                name: 'Chungcheongbuk-do'
            }, {
                code: 'KS17',
                name: 'Chungcheongnam-do'
            }, {
                code: 'KS15',
                name: 'Daegu'
            }, {
                code: 'KS19',
                name: 'Daejeon'
            }, {
                code: 'KS06',
                name: 'Gangwon-do'
            }, {
                code: 'KS18',
                name: 'Gwangju'
            }, {
                code: 'KS13',
                name: 'Gyeonggi-do'
            }, {
                code: 'KS14',
                name: 'Gyeongsangbuk-do'
            }, {
                code: 'KS20',
                name: 'Gyeongsangnam-do'
            }, {
                code: 'KS12',
                name: 'Incheon'
            }, {
                code: 'KS01',
                name: 'Jeju-do'
            }, {
                code: 'KS03',
                name: 'Jeollabuk-do'
            }, {
                code: 'KS16',
                name: 'Jeollanam-do'
            }, {
                code: 'KS22',
                name: 'Sejong'
            }, {
                code: 'KS11',
                name: 'Seoul'
            }, {
                code: 'KS21',
                name: 'Ulsan'
            }]
    }, {
        code: 'KW',
        id: 2276,
        name: 'Kuwait',
        states: [{
                code: 'KU04',
                name: 'Al Ahmadi'
            }, {
                code: 'KU07',
                name: 'Al Farwaniyah'
            }, {
                code: 'KU05',
                name: 'Al Jahrah'
            }, {
                code: 'KU02',
                name: 'Al Kuwayt'
            }, {
                code: 'KU08',
                name: 'Hawalli'
            }, {
                code: 'KU09',
                name: 'Mubarak Al-Kabir'
            }]
    }, {
        code: 'KG',
        id: 2277,
        name: 'Kyrgyzstan',
        states: []
    }, {
        code: 'LA',
        id: 2278,
        name: 'Lao People\'s Democratic Republic',
        states: []
    }, {
        code: 'LV',
        id: 2279,
        name: 'Latvia',
        states: []
    }, {
        code: 'LB',
        id: 2280,
        name: 'Lebanon',
        states: [{
                code: 'LE10',
                name: 'Aakkar'
            }, {
                code: 'LE07',
                name: 'An Nabatiyah'
            }, {
                code: 'LE11',
                name: 'Baalbek-Hermel'
            }, {
                code: 'LE04',
                name: 'Beirut'
            }, {
                code: 'LE08',
                name: 'Beqaa'
            }, {
                code: 'LE05',
                name: 'Mount Lebanon'
            }, {
                code: 'LE09',
                name: 'North Lebanon'
            }, {
                code: 'LE06',
                name: 'South Lebanon'
            }]
    }, {
        code: 'LS',
        id: 2281,
        name: 'Lesotho',
        states: []
    }, {
        code: 'LR',
        id: 2282,
        name: 'Liberia',
        states: []
    }, {
        code: 'LI',
        id: 2284,
        name: 'Liechtenstein',
        states: []
    }, {
        code: 'LT',
        id: 2285,
        name: 'Lithuania',
        states: [{
                code: 'LH56',
                name: 'Alytus'
            }, {
                code: 'LH57',
                name: 'Kaunas'
            }, {
                code: 'LH58',
                name: 'Klaipeda'
            }, {
                code: 'LH59',
                name: 'Marijampole'
            }, {
                code: 'LH60',
                name: 'Paneveys'
            }, {
                code: 'LH61',
                name: 'Siauliai'
            }, {
                code: 'LH62',
                name: 'Taurage'
            }, {
                code: 'LH63',
                name: 'Teliai'
            }, {
                code: 'LH64',
                name: 'Utena'
            }, {
                code: 'LH65',
                name: 'Vilnius'
            }]
    }, {
        code: 'LU',
        id: 2286,
        name: 'Luxembourg',
        states: [{
                code: 'LU01',
                name: 'Diekirch'
            }, {
                code: 'LU02',
                name: 'Grevenmacher'
            }, {
                code: 'LU03',
                name: 'Luxembourg'
            }]
    }, {
        code: 'MO',
        id: 2287,
        name: 'Macau',
        states: []
    }, {
        code: 'MK',
        id: 2288,
        name: 'Macedonia',
        states: []
    }, {
        code: 'MG',
        id: 2289,
        name: 'Madagascar',
        states: []
    }, {
        code: 'MW',
        id: 2290,
        name: 'Malawi',
        states: []
    }, {
        code: 'MY',
        id: 2291,
        name: 'Malaysia',
        states: [{
                code: 'MY01',
                name: 'Johor'
            }, {
                code: 'MY02',
                name: 'Kedah'
            }, {
                code: 'MY03',
                name: 'Kelantan'
            }, {
                code: 'MY04',
                name: 'Melaka'
            }, {
                code: 'MY05',
                name: 'Negeri Sembilan'
            }, {
                code: 'MY06',
                name: 'Pahang'
            }, {
                code: 'MY08',
                name: 'Perak'
            }, {
                code: 'MY09',
                name: 'Perlis'
            }, {
                code: 'MY07',
                name: 'Pulau Pinang'
            }, {
                code: 'MY12',
                name: 'Sabah'
            }, {
                code: 'MY13',
                name: 'Sarawak'
            }, {
                code: 'MY10',
                name: 'Selangor'
            }, {
                code: 'MY11',
                name: 'Terengganu'
            }, {
                code: 'MY14',
                name: 'W.P. Kuala Lumpur'
            }, {
                code: 'MY15',
                name: 'W.P. Labuan'
            }, {
                code: 'MY16',
                name: 'W.P. Putrajaya'
            }]
    }, {
        code: 'ML',
        id: 2292,
        name: 'Mali',
        states: []
    }, {
        code: 'MT',
        id: 2293,
        name: 'Malta',
        states: [{
                code: 'MT.CE',
                name: 'Central'
            }, {
                code: 'MT.GO',
                name: 'Gozo'
            }, {
                code: 'MT.NO',
                name: 'Northern'
            }, {
                code: 'MT.SE',
                name: 'South Eastern'
            }, {
                code: 'MT.SO',
                name: 'Southern'
            }]
    }, {
        code: 'MR',
        id: 2294,
        name: 'Mauritania',
        states: []
    }, {
        code: 'MU',
        id: 2295,
        name: 'Mauritius',
        states: []
    }, {
        code: 'MX',
        id: 2296,
        name: 'Mexico',
        states: [{
                code: 'AGU',
                name: 'Aguascalientes'
            }, {
                code: 'BCN',
                name: 'Baja California'
            }, {
                code: 'BCS',
                name: 'Baja California Sur'
            }, {
                code: 'CAM',
                name: 'Campeche'
            }, {
                code: 'CHP',
                name: 'Chiapas'
            }, {
                code: 'CHH',
                name: 'Chihuahua'
            }, {
                code: 'COA',
                name: 'Coahuila'
            }, {
                code: 'COL',
                name: 'Colima'
            }, {
                code: 'DIF',
                name: 'Distrito Federal'
            }, {
                code: 'DUR',
                name: 'Durango'
            }, {
                code: 'GUA',
                name: 'Guanajuato'
            }, {
                code: 'GRO',
                name: 'Guerrero'
            }, {
                code: 'HID',
                name: 'Hidalgo'
            }, {
                code: 'JAL',
                name: 'Jalisco'
            }, {
                code: 'MIC',
                name: 'Michoacn'
            }, {
                code: 'MOR',
                name: 'Morelos'
            }, {
                code: 'MEX',
                name: 'Mxico'
            }, {
                code: 'NAY',
                name: 'Nayarit'
            }, {
                code: 'NLE',
                name: 'Nuevo Len'
            }, {
                code: 'OAX',
                name: 'Oaxaca'
            }, {
                code: 'PUE',
                name: 'Puebla'
            }, {
                code: 'QUE',
                name: 'Quertaro'
            }, {
                code: 'ROO',
                name: 'Quintana Roo'
            }, {
                code: 'SLP',
                name: 'San Luis Potos'
            }, {
                code: 'SIN',
                name: 'Sinaloa'
            }, {
                code: 'SON',
                name: 'Sonora'
            }, {
                code: 'TAB',
                name: 'Tabasco'
            }, {
                code: 'TAM',
                name: 'Tamaulipas'
            }, {
                code: 'TLA',
                name: 'Tlaxcala'
            }, {
                code: 'VER',
                name: 'Veracruz'
            }, {
                code: 'YUC',
                name: 'Yucatn'
            }, {
                code: 'ZAC',
                name: 'Zacatecas'
            }]
    }, {
        code: 'FM',
        id: 2297,
        name: 'Micronesia; Federated States of',
        states: []
    }, {
        code: 'MC',
        id: 2299,
        name: 'Monaco',
        states: []
    }, {
        code: 'MN',
        id: 2300,
        name: 'Mongolia',
        states: []
    }, {
        code: 'MA',
        id: 2301,
        name: 'Morocco',
        states: [{
                code: 'MA.BK',
                name: 'Bni Mellal-Khnifra'
            }, {
                code: 'MA.CS',
                name: 'Casablanca-Settat'
            }, {
                code: 'MA.OL',
                name: 'Dakhla-Oued Ed-Dahab'
            }, {
                code: 'MA.DT',
                name: 'Dra-Tafilalet'
            }, {
                code: 'MA.FK',
                name: 'Fs-Mekns'
            }, {
                code: 'MA.GN',
                name: 'Guelmim-Oued Noun'
            }, {
                code: 'MA.OF',
                name: 'L\'oriental'
            }, {
                code: 'MA.LS',
                name: 'Layoune-Sakia al Hamra'
            }, {
                code: 'MA.MS',
                name: 'Marrakech-Safi'
            }, {
                code: 'MA.RK',
                name: 'Rabat-Sal-Knitra'
            }, {
                code: 'MA.SS',
                name: 'Souss-Massa'
            }, {
                code: 'MA.TC',
                name: 'Tanger-Ttouan-Al Hoceima'
            }]
    }, {
        code: 'MZ',
        id: 2302,
        name: 'Mozambique',
        states: [{
                code: 'MZ01',
                name: 'Cabo Delgado'
            }, {
                code: 'MZ02',
                name: 'Gaza'
            }, {
                code: 'MZ03',
                name: 'Inhambane'
            }, {
                code: 'MZ10',
                name: 'Manica'
            }, {
                code: 'MZ04',
                name: 'Maputo'
            }, {
                code: 'MZ11',
                name: 'Maputo [city]'
            }, {
                code: 'MZ06',
                name: 'Nampula'
            }, {
                code: 'MZ07',
                name: 'Niassa'
            }, {
                code: 'MZ05',
                name: 'Sofala'
            }, {
                code: 'MZ08',
                name: 'Tete'
            }, {
                code: 'MZ09',
                name: 'Zambzia'
            }]
    }, {
        code: 'MM',
        id: 2303,
        name: 'Myanmar',
        states: [{
                code: 'MM.AY',
                name: 'Ayeyarwady'
            }, {
                code: 'MM.BA',
                name: 'Bago'
            }, {
                code: 'MM.CH',
                name: 'Chin'
            }, {
                code: 'MM.KC',
                name: 'Kachin'
            }, {
                code: 'MM.KH',
                name: 'Kayah'
            }, {
                code: 'MM.KN',
                name: 'Kayin'
            }, {
                code: 'MM.MG',
                name: 'Magway'
            }, {
                code: 'MM.ML',
                name: 'Mandalay'
            }, {
                code: 'MM.MO',
                name: 'Mon'
            }, {
                code: 'MM.NY',
                name: 'Naypyidaw'
            }, {
                code: 'MM.RA',
                name: 'Rakhine'
            }, {
                code: 'MM.SA',
                name: 'Sagaing'
            }, {
                code: 'MM.SH',
                name: 'Shan'
            }, {
                code: 'MM.TN',
                name: 'Tanintharyi'
            }, {
                code: 'MM.YA',
                name: 'Yangon'
            }]
    }, {
        code: 'NA',
        id: 2304,
        name: 'Namibia',
        states: []
    }, {
        code: 'NP',
        id: 2305,
        name: 'Nepal',
        states: []
    }, {
        code: 'NL',
        id: 2306,
        name: 'Netherlands',
        states: [{
                code: 'DR',
                name: 'Drenthe'
            }, {
                code: 'FL',
                name: 'Flevoland'
            }, {
                code: 'FR',
                name: 'Friesland'
            }, {
                code: 'GE',
                name: 'Gelderland'
            }, {
                code: 'GR',
                name: 'Groningen'
            }, {
                code: 'LI',
                name: 'Limburg'
            }, {
                code: 'NB',
                name: 'Noord-Brabant'
            }, {
                code: 'NH',
                name: 'Noord-Holland'
            }, {
                code: 'OV',
                name: 'Overijssel'
            }, {
                code: 'UT',
                name: 'Utrecht'
            }, {
                code: 'ZE',
                name: 'Zeeland'
            }, {
                code: 'ZH',
                name: 'Zuid-Holland'
            }]
    }, {
        code: 'NZ',
        id: 2307,
        name: 'New Zealand',
        states: [{
                code: 'AUK',
                name: 'Auckland'
            }, {
                code: 'BOP',
                name: 'Bay of Plenty'
            }, {
                code: 'CAN',
                name: 'Canterbury'
            }, {
                code: 'CIT',
                name: 'Chatham Islands Territory'
            }, {
                code: 'GIS',
                name: 'Gisborne'
            }, {
                code: 'HKB',
                name: 'Hawke\'s Bay'
            }, {
                code: 'MWT',
                name: 'Manawatu-Wanganui'
            }, {
                code: 'MBH',
                name: 'Marlborough'
            }, {
                code: 'NSN',
                name: 'Nelson'
            }, {
                code: 'N',
                name: 'North Island'
            }, {
                code: 'NTL',
                name: 'Northland'
            }, {
                code: 'OTA',
                name: 'Otago'
            }, {
                code: 'S',
                name: 'South Island'
            }, {
                code: 'STL',
                name: 'Southland'
            }, {
                code: 'TKI',
                name: 'Taranaki'
            }, {
                code: 'TAS',
                name: 'Tasman District'
            }, {
                code: 'WKO',
                name: 'Waikato'
            }, {
                code: 'WGN',
                name: 'Wellington'
            }, {
                code: 'WTC',
                name: 'West Coast'
            }]
    }, {
        code: 'NI',
        id: 2308,
        name: 'Nicaragua',
        states: []
    }, {
        code: 'NE',
        id: 2309,
        name: 'Niger',
        states: []
    }, {
        code: 'NG',
        id: 2310,
        name: 'Nigeria',
        states: [{
                code: 'NI45',
                name: 'Abia'
            }, {
                code: 'NI35',
                name: 'Adamawa'
            }, {
                code: 'NI21',
                name: 'Akwa Ibom'
            }, {
                code: 'NI25',
                name: 'Anambra'
            }, {
                code: 'NI46',
                name: 'Bauchi'
            }, {
                code: 'NI52',
                name: 'Bayelsa'
            }, {
                code: 'NI26',
                name: 'Benue'
            }, {
                code: 'NI27',
                name: 'Borno'
            }, {
                code: 'NI22',
                name: 'Cross River'
            }, {
                code: 'NI36',
                name: 'Delta'
            }, {
                code: 'NI53',
                name: 'Ebonyi'
            }, {
                code: 'NI37',
                name: 'Edo'
            }, {
                code: 'NI54',
                name: 'Ekiti'
            }, {
                code: 'NI47',
                name: 'Enugu'
            }, {
                code: 'NI11',
                name: 'Federal Capital Territory'
            }, {
                code: 'NI55',
                name: 'Gombe'
            }, {
                code: 'NI28',
                name: 'Imo'
            }, {
                code: 'NI39',
                name: 'Jigawa'
            }, {
                code: 'NI23',
                name: 'Kaduna'
            }, {
                code: 'NI29',
                name: 'Kano'
            }, {
                code: 'NI24',
                name: 'Katsina'
            }, {
                code: 'NI40',
                name: 'Kebbi'
            }, {
                code: 'NI41',
                name: 'Kogi'
            }, {
                code: 'NI30',
                name: 'Kwara'
            }, {
                code: 'NI05',
                name: 'Lagos'
            }, {
                code: 'NI56',
                name: 'Nassarawa'
            }, {
                code: 'NI31',
                name: 'Niger'
            }, {
                code: 'NI16',
                name: 'Ogun'
            }, {
                code: 'NI48',
                name: 'Ondo'
            }, {
                code: 'NI42',
                name: 'Osun'
            }, {
                code: 'NI32',
                name: 'Oyo'
            }, {
                code: 'NI49',
                name: 'Plateau'
            }, {
                code: 'NI50',
                name: 'Rivers'
            }, {
                code: 'NI51',
                name: 'Sokoto'
            }, {
                code: 'NI43',
                name: 'Taraba'
            }, {
                code: 'NI44',
                name: 'Yobe'
            }, {
                code: 'NI57',
                name: 'Zamfara'
            }]
    }, {
        code: 'NO',
        id: 2311,
        name: 'Norway',
        states: [{
                code: 'NO02',
                name: 'Akershus'
            }, {
                code: 'NO09',
                name: 'Aust-Agder'
            }, {
                code: 'NO06',
                name: 'Buskerud'
            }, {
                code: 'NO20',
                name: 'Finnmark'
            }, {
                code: 'NO04',
                name: 'Hedmark'
            }, {
                code: 'NO12',
                name: 'Hordaland'
            }, {
                code: 'NO22',
                name: 'Jan Mayen (Arctic Region)'
            }, {
                code: 'NO15',
                name: 'Mre og Romsdal'
            }, {
                code: 'NO17',
                name: 'Nord-Trndelag'
            }, {
                code: 'NO18',
                name: 'Nordland'
            }, {
                code: 'NO05',
                name: 'Oppland'
            }, {
                code: 'NO03',
                name: 'Oslo'
            }, {
                code: 'NO11',
                name: 'Rogaland'
            }, {
                code: 'NO14',
                name: 'Sogn og Fjordane'
            }, {
                code: 'NO21',
                name: 'Svalbard (Arctic Region) '
            }, {
                code: 'NO16',
                name: 'Sr-Trndelag'
            }, {
                code: 'NO08',
                name: 'Telemark'
            }, {
                code: 'NO19',
                name: 'Troms'
            }, {
                code: 'NO10',
                name: 'Vest-Agder'
            }, {
                code: 'NO07',
                name: 'Vestfold'
            }, {
                code: 'NO01',
                name: 'stfold'
            }]
    }, {
        code: 'OM',
        id: 2312,
        name: 'Oman',
        states: [{
                code: 'MU01',
                name: 'Ad Dakhliyah'
            }, {
                code: 'MU09',
                name: 'Adh Dhahirah'
            }, {
                code: 'MU11',
                name: 'Al Batinah North'
            }, {
                code: 'MU02',
                name: 'Al Batinah South'
            }, {
                code: 'MU10',
                name: 'Al Buraymi'
            }, {
                code: 'MU03',
                name: 'Al Wusta'
            }, {
                code: 'MU12',
                name: 'Ash Sharqiyah North'
            }, {
                code: 'MU04',
                name: 'Ash Sharqiyah South'
            }, {
                code: 'MU08',
                name: 'Dhofar'
            }, {
                code: 'MU07',
                name: 'Musandam'
            }, {
                code: 'MU06',
                name: 'Muscat'
            }]
    }, {
        code: 'PK',
        id: 2313,
        name: 'Pakistan',
        states: [{
                code: 'PK06',
                name: 'Azad Kashmir'
            }, {
                code: 'PK02',
                name: 'Balochistan'
            }, {
                code: 'PK01',
                name: 'Federally Administered Tribal Areas'
            }, {
                code: 'PK07',
                name: 'Gilgit-Baltistan'
            }, {
                code: 'PK08',
                name: 'Islamabad'
            }, {
                code: 'PK03',
                name: 'Khyber-Pakhtunkhwa'
            }, {
                code: 'PK04',
                name: 'Punjab'
            }, {
                code: 'PK05',
                name: 'Sindh'
            }]
    }, {
        code: 'PW',
        id: 2314,
        name: 'Palau',
        states: []
    }, {
        code: 'PA',
        id: 2315,
        name: 'Panama',
        states: []
    }, {
        code: 'PG',
        id: 2316,
        name: 'Papua New Guinea',
        states: [{
                code: 'PP07',
                name: 'Bougainville'
            }, {
                code: 'PP01',
                name: 'Central'
            }, {
                code: 'PP08',
                name: 'Chimbu'
            }, {
                code: 'PP10',
                name: 'East New Britain'
            }, {
                code: 'PP11',
                name: 'East Sepik'
            }, {
                code: 'PP09',
                name: 'Eastern Highlands'
            }, {
                code: 'PP19',
                name: 'Enga'
            }, {
                code: 'PP02',
                name: 'Gulf'
            }, {
                code: 'PP21',
                name: 'Hela'
            }, {
                code: 'PP22',
                name: 'Jiwaka'
            }, {
                code: 'PP12',
                name: 'Madang'
            }, {
                code: 'PP13',
                name: 'Manus'
            }, {
                code: 'PP03',
                name: 'Milne Bay'
            }, {
                code: 'PP14',
                name: 'Morobe'
            }, {
                code: 'PP20',
                name: 'National Capital District'
            }, {
                code: 'PP15',
                name: 'New Ireland'
            }, {
                code: 'PP04',
                name: 'Northern'
            }, {
                code: 'PP18',
                name: 'Sandaun'
            }, {
                code: 'PP05',
                name: 'Southern Highlands'
            }, {
                code: 'PP17',
                name: 'West New Britain'
            }, {
                code: 'PP06',
                name: 'Western'
            }, {
                code: 'PP16',
                name: 'Western Highlands'
            }]
    }, {
        code: 'PY',
        id: 2317,
        name: 'Paraguay',
        states: []
    }, {
        code: 'PE',
        id: 2318,
        name: 'Peru',
        states: [{
                code: 'PE01',
                name: 'Amazonas'
            }, {
                code: 'PE02',
                name: 'Ancash'
            }, {
                code: 'PE03',
                name: 'Apurmac'
            }, {
                code: 'PE04',
                name: 'Arequipa'
            }, {
                code: 'PE05',
                name: 'Ayacucho'
            }, {
                code: 'PE06',
                name: 'Cajamarca'
            }, {
                code: 'PE07',
                name: 'Callao'
            }, {
                code: 'PE08',
                name: 'Cusco'
            }, {
                code: 'PE09',
                name: 'Huancavelica'
            }, {
                code: 'PE10',
                name: 'Hunuco'
            }, {
                code: 'PE11',
                name: 'Ica'
            }, {
                code: 'PE12',
                name: 'Junn'
            }, {
                code: 'PE13',
                name: 'La Libertad'
            }, {
                code: 'PE14',
                name: 'Lambayeque'
            }, {
                code: 'PE15',
                name: 'Lima'
            }, {
                code: 'PE26',
                name: 'Lima [Province]'
            }, {
                code: 'PE16',
                name: 'Loreto'
            }, {
                code: 'PE17',
                name: 'Madre de Dios'
            }, {
                code: 'PE18',
                name: 'Moquegua'
            }, {
                code: 'PE19',
                name: 'Pasco'
            }, {
                code: 'PE20',
                name: 'Piura'
            }, {
                code: 'PE21',
                name: 'Puno'
            }, {
                code: 'PE22',
                name: 'San Martn'
            }, {
                code: 'PE23',
                name: 'Tacna'
            }, {
                code: 'PE24',
                name: 'Tumbes'
            }, {
                code: 'PE25',
                name: 'Ucayali'
            }]
    }, {
        code: 'PH',
        id: 2319,
        name: 'Philippines',
        states: [{
                code: 'RP01',
                name: 'Abra'
            }, {
                code: 'RP02',
                name: 'Agusan del Norte'
            }, {
                code: 'RP03',
                name: 'Agusan del Sur'
            }, {
                code: 'RP04',
                name: 'Aklan'
            }, {
                code: 'RP05',
                name: 'Albay'
            }, {
                code: 'RP06',
                name: 'Antique'
            }, {
                code: 'RPH6',
                name: 'Apayao'
            }, {
                code: 'RPG8',
                name: 'Aurora'
            }, {
                code: 'RP22',
                name: 'Basilan'
            }, {
                code: 'RP07',
                name: 'Bataan'
            }, {
                code: 'RP08',
                name: 'Batanes'
            }, {
                code: 'RP09',
                name: 'Batangas'
            }, {
                code: 'RP10',
                name: 'Benguet'
            }, {
                code: 'RPH9',
                name: 'Biliran'
            }, {
                code: 'RP11',
                name: 'Bohol'
            }, {
                code: 'RP12',
                name: 'Bukidnon'
            }, {
                code: 'RP13',
                name: 'Bulacan'
            }, {
                code: 'RP14',
                name: 'Cagayan'
            }, {
                code: 'RP15',
                name: 'Camarines Norte'
            }, {
                code: 'RP16',
                name: 'Camarines Sur'
            }, {
                code: 'RP17',
                name: 'Camiguin'
            }, {
                code: 'RP18',
                name: 'Capiz'
            }, {
                code: 'RP19',
                name: 'Catanduanes'
            }, {
                code: 'RP20',
                name: 'Cavite'
            }, {
                code: 'RP21',
                name: 'Cebu'
            }, {
                code: 'RPI6',
                name: 'Compostela Valley'
            }, {
                code: 'RP57',
                name: 'Cotabato'
            }, {
                code: 'RP26',
                name: 'Davao Oriental'
            }, {
                code: 'RPI7',
                name: 'Davao del Norte'
            }, {
                code: 'RP25',
                name: 'Davao del Sur'
            }, {
                code: 'RPI9',
                name: 'Dinagat Islands'
            }, {
                code: 'RP23',
                name: 'Eastern Samar'
            }, {
                code: 'RPJ3',
                name: 'Guimaras'
            }, {
                code: 'RP27',
                name: 'Ifugao'
            }, {
                code: 'RP28',
                name: 'Ilocos Norte'
            }, {
                code: 'RP29',
                name: 'Ilocos Sur'
            }, {
                code: 'RP30',
                name: 'Iloilo'
            }, {
                code: 'RP31',
                name: 'Isabela'
            }, {
                code: 'RPJ7',
                name: 'Kalinga'
            }, {
                code: 'RP36',
                name: 'La Union'
            }, {
                code: 'RP33',
                name: 'Laguna'
            }, {
                code: 'RP34',
                name: 'Lanao del Norte'
            }, {
                code: 'RP35',
                name: 'Lanao del Sur'
            }, {
                code: 'RP37',
                name: 'Leyte'
            }, {
                code: 'RP56',
                name: 'Maguindanao'
            }, {
                code: 'RP38',
                name: 'Marinduque'
            }, {
                code: 'RP39',
                name: 'Masbate'
            }, {
                code: 'RPD9',
                name: 'Metropolitan Manila'
            }, {
                code: 'RP42',
                name: 'Misamis Occidental'
            }, {
                code: 'RP43',
                name: 'Misamis Oriental'
            }, {
                code: 'RP44',
                name: 'Mountain'
            }, {
                code: 'RPH3',
                name: 'Negros Occidental'
            }, {
                code: 'RP46',
                name: 'Negros Oriental'
            }, {
                code: 'RP67',
                name: 'Northern Samar'
            }, {
                code: 'RP47',
                name: 'Nueva Ecija'
            }, {
                code: 'RP48',
                name: 'Nueva Vizcaya'
            }, {
                code: 'RP40',
                name: 'Occidental Mindoro'
            }, {
                code: 'RP41',
                name: 'Oriental Mindoro'
            }, {
                code: 'RP49',
                name: 'Palawan'
            }, {
                code: 'RP50',
                name: 'Pampanga'
            }, {
                code: 'RP51',
                name: 'Pangasinan'
            }, {
                code: 'RPH2',
                name: 'Quezon'
            }, {
                code: 'RP68',
                name: 'Quirino'
            }, {
                code: 'RP53',
                name: 'Rizal'
            }, {
                code: 'RP54',
                name: 'Romblon'
            }, {
                code: 'RP55',
                name: 'Samar'
            }, {
                code: 'PH72',
                name: 'Sarangani'
            }, {
                code: 'RP69',
                name: 'Siquijor'
            }, {
                code: 'RP58',
                name: 'Sorsogon'
            }, {
                code: 'RP70',
                name: 'South Cotabato'
            }, {
                code: 'RP59',
                name: 'Southern Leyte'
            }, {
                code: 'RP71',
                name: 'Sultan Kudarat'
            }, {
                code: 'RP60',
                name: 'Sulu'
            }, {
                code: 'RP61',
                name: 'Surigao del Norte'
            }, {
                code: 'RP62',
                name: 'Surigao del Sur'
            }, {
                code: 'RPO3',
                name: 'Tarlac'
            }, {
                code: 'RPO4',
                name: 'Tawi-Tawi'
            }, {
                code: 'RPP1',
                name: 'Zambales'
            }, {
                code: 'RPG7',
                name: 'Zamboanga del Norte'
            }, {
                code: 'RP65',
                name: 'Zamboanga del Sur'
            }, {
                code: 'RP66',
                name: 'Zamboanga-Sibugay'
            }]
    }, {
        code: 'PL',
        id: 2320,
        name: 'Poland',
        states: [{
                code: 'PL-DS',
                name: 'Dolnoslaskie'
            }, {
                code: 'PL-KP',
                name: 'Kujawsko-pomorskie'
            }, {
                code: 'PL-LU',
                name: 'Lubelskie'
            }, {
                code: 'PL-LB',
                name: 'Lubuskie'
            }, {
                code: 'PL-LD',
                name: 'Ldzkie'
            }, {
                code: 'PL-MA',
                name: 'Malopolskie'
            }, {
                code: 'PL-MZ',
                name: 'Mazowieckie'
            }, {
                code: 'PL-OP',
                name: 'Opolskie'
            }, {
                code: 'PL-PK',
                name: 'Podkarpackie'
            }, {
                code: 'PL-PD',
                name: 'Podlaskie'
            }, {
                code: 'PL-PM',
                name: 'Pomorskie'
            }, {
                code: 'PL-SL',
                name: 'Slaskie'
            }, {
                code: 'PL-SK',
                name: 'Swietokrzyskie'
            }, {
                code: 'PL-WN',
                name: 'Warminsko-mazurskie'
            }, {
                code: 'PL-WP',
                name: 'Wielkopolskie'
            }]
    }, {
        code: 'PT',
        id: 2321,
        name: 'Portugal',
        states: [{
                code: 'PO23',
                name: 'Acores Autonomous'
            }, {
                code: 'PO02',
                name: 'Aveiro'
            }, {
                code: 'PO03',
                name: 'Beja'
            }, {
                code: 'PO04',
                name: 'Braga'
            }, {
                code: 'PO05',
                name: 'Braganca'
            }, {
                code: 'PO06',
                name: 'Castelo Branco'
            }, {
                code: 'PO07',
                name: 'Coimbra'
            }, {
                code: 'PO08',
                name: 'Evora'
            }, {
                code: 'PO09',
                name: 'Faro'
            }, {
                code: 'PO11',
                name: 'Guarda'
            }, {
                code: 'PO13',
                name: 'Leiria'
            }, {
                code: 'PO14',
                name: 'Lisboa'
            }, {
                code: 'PO10',
                name: 'Madeira Autonomous'
            }, {
                code: 'PO16',
                name: 'Portalegre'
            }, {
                code: 'PO17',
                name: 'Porto'
            }, {
                code: 'PO18',
                name: 'Santarem'
            }, {
                code: 'PO19',
                name: 'Setubal'
            }, {
                code: 'PO20',
                name: 'Viana do Castelo'
            }, {
                code: 'PO21',
                name: 'Vila Real'
            }, {
                code: 'PO22',
                name: 'Viseu'
            }]
    }, {
        code: 'QA',
        id: 2322,
        name: 'Qatar',
        states: [{
                code: 'QA01',
                name: 'Ad Dawhah'
            }, {
                code: 'QA13',
                name: 'Al Daayen'
            }, {
                code: 'QA04',
                name: 'Al Khawr'
            }, {
                code: 'QA10',
                name: 'Al Wakrah'
            }, {
                code: 'QA06',
                name: 'Ar Rayyan'
            }, {
                code: 'QA08',
                name: 'Madinat ach Shamal'
            }, {
                code: 'QA09',
                name: 'Umm Salal'
            }]
    }, {
        code: 'RO',
        id: 2323,
        name: 'Romania',
        states: [{
                code: 'RO-AB',
                name: 'Alba'
            }, {
                code: 'RO-AR',
                name: 'Arad'
            }, {
                code: 'RO-AG',
                name: 'Arges'
            }, {
                code: 'RO-BC',
                name: 'Bacau'
            }, {
                code: 'RO-BH',
                name: 'Bihor'
            }, {
                code: 'RO-BN',
                name: 'Bistrita-Nasaud'
            }, {
                code: 'RO-BT',
                name: 'Botosani'
            }, {
                code: 'RO-BR',
                name: 'Braila'
            }, {
                code: 'RO-BV',
                name: 'Brasov'
            }, {
                code: 'RO-B',
                name: 'Bucuresti'
            }, {
                code: 'RO-BZ',
                name: 'Buzau'
            }, {
                code: 'RO-CL',
                name: 'Calarasi'
            }, {
                code: 'RO-CS',
                name: 'Caras-Severin'
            }, {
                code: 'RO-CJ',
                name: 'Cluj'
            }, {
                code: 'RO-CT',
                name: 'Constanta'
            }, {
                code: 'RO-CV',
                name: 'Covasna'
            }, {
                code: 'RO-DJ',
                name: 'Dolj'
            }, {
                code: 'RO-DB',
                name: 'Dmbovita'
            }, {
                code: 'RO-GL',
                name: 'Galati'
            }, {
                code: 'RO-GR',
                name: 'Giurgiu'
            }, {
                code: 'RO-GJ',
                name: 'Gorj'
            }, {
                code: 'RO-HR',
                name: 'Harghita'
            }, {
                code: 'RO-HD',
                name: 'Hunedoara'
            }, {
                code: 'RO-IL',
                name: 'Ialomita'
            }, {
                code: 'RO-IS',
                name: 'Iasi'
            }, {
                code: 'RO-IF',
                name: 'Ilfov'
            }, {
                code: 'RO-MM',
                name: 'Maramures'
            }, {
                code: 'RO-MH',
                name: 'Mehedinti'
            }, {
                code: 'RO-MS',
                name: 'Mures'
            }, {
                code: 'RO-NT',
                name: 'Neamt'
            }, {
                code: 'RO-OT',
                name: 'Olt'
            }, {
                code: 'RO-PH',
                name: 'Prahova'
            }, {
                code: 'RO-SJ',
                name: 'Salaj'
            }, {
                code: 'RO-SM',
                name: 'Satu Mare'
            }, {
                code: 'RO-SB',
                name: 'Sibiu'
            }, {
                code: 'RO-SV',
                name: 'Suceava'
            }, {
                code: 'RO-TR',
                name: 'Teleorman'
            }, {
                code: 'RO-TM',
                name: 'Timis'
            }, {
                code: 'RO-TL',
                name: 'Tulcea'
            }, {
                code: 'RO-VS',
                name: 'Vaslui'
            }, {
                code: 'RO-VN',
                name: 'Vrancea'
            }, {
                code: 'RO-VL',
                name: 'Vlcea'
            }]
    }, {
        code: 'RU',
        id: 2324,
        name: 'Russian Federation',
        states: [{
                code: 'RS01',
                name: 'Adygeya Republic'
            }, {
                code: 'RS02',
                name: 'Aginskiy Buryatskiy Avtonomnyy Okrug'
            }, {
                code: 'RS03',
                name: 'Altay Republic'
            }, {
                code: 'RS04',
                name: 'Altayskiy Kray'
            }, {
                code: 'RS05',
                name: 'Amurskaya Oblast\''
            }, {
                code: 'RS06',
                name: 'Arkhangel\'skaya Oblast\''
            }, {
                code: 'RS07',
                name: 'Astrakhanskaya Oblast\''
            }, {
                code: 'RS08',
                name: 'Bashkortostan Republic'
            }, {
                code: 'RS09',
                name: 'Belgorodskaya Oblast\''
            }, {
                code: 'RS10',
                name: 'Bryanskaya Oblast\''
            }, {
                code: 'RS11',
                name: 'Buryatiya Republic'
            }, {
                code: 'RSCI',
                name: 'Chechnya Republic'
            }, {
                code: 'RS13',
                name: 'Chelyabinskaya Oblast\''
            }, {
                code: 'RS14',
                name: 'Chitinskaya Oblast\''
            }, {
                code: 'RS15',
                name: 'Chukotskiy Avtonomnyy Okrug'
            }, {
                code: 'RS16',
                name: 'Chuvashiya Republic'
            }, {
                code: 'RS17',
                name: 'Dagestan Republic'
            }, {
                code: 'RS18',
                name: 'Evenkiyskiy Avtonomnyy Okrug'
            }, {
                code: 'RS20',
                name: 'Irkutskaya Oblast\''
            }, {
                code: 'RS21',
                name: 'Ivanovskaya Oblast\''
            }, {
                code: 'RS22',
                name: 'Kabardino-Balkariya Republic'
            }, {
                code: 'RS23',
                name: 'Kaliningradskaya Oblast\''
            }, {
                code: 'RS24',
                name: 'Kalmykiya Republic'
            }, {
                code: 'RS25',
                name: 'Kaluzhskaya Oblast\''
            }, {
                code: 'RS26',
                name: 'Kamchatskaya Oblast\''
            }, {
                code: 'RS27',
                name: 'Karachayevo-Cherkesiya Republic'
            }, {
                code: 'RS28',
                name: 'Kareliya Republic'
            }, {
                code: 'RS29',
                name: 'Kemerovskaya Oblast\''
            }, {
                code: 'RS30',
                name: 'Khabarovskiy Kray'
            }, {
                code: 'RS31',
                name: 'Khakasiya Republic'
            }, {
                code: 'RS32',
                name: 'Khanty-Mansiyskiy Avtonomnyy Okrug'
            }, {
                code: 'RS33',
                name: 'Kirovskaya Oblast\''
            }, {
                code: 'RS34',
                name: 'Komi Republic'
            }, {
                code: 'RS36',
                name: 'Koryakskiy Avtonomnyy Okrug'
            }, {
                code: 'RS37',
                name: 'Kostromskaya Oblast\''
            }, {
                code: 'RS38',
                name: 'Krasnodarskiy Kray'
            }, {
                code: 'RS39',
                name: 'Krasnoyarskiy Kray'
            }, {
                code: 'RS40',
                name: 'Kurganskaya Oblast\''
            }, {
                code: 'RS41',
                name: 'Kurskaya Oblast\''
            }, {
                code: 'RS42',
                name: 'Leningradskaya Oblast\''
            }, {
                code: 'RS43',
                name: 'Lipetskaya Oblast\''
            }, {
                code: 'RS44',
                name: 'Magadanskaya Oblast\''
            }, {
                code: 'RS45',
                name: 'Mariy-El Republic'
            }, {
                code: 'RS46',
                name: 'Mordoviya Republic'
            }, {
                code: 'RS47',
                name: 'Moskovskaya Oblast\''
            }, {
                code: 'RS48',
                name: 'Moskva Federal City'
            }, {
                code: 'RS49',
                name: 'Murmanskaya Oblast\''
            }, {
                code: 'RS50',
                name: 'Nenetskiy Avtonomnyy Okrug'
            }, {
                code: 'RS51',
                name: 'Nizhegorodskaya Oblast\''
            }, {
                code: 'RS52',
                name: 'Novgorodskaya Oblast\''
            }, {
                code: 'RS53',
                name: 'Novosibirskaya Oblast\''
            }, {
                code: 'RS54',
                name: 'Omskaya Oblast\''
            }, {
                code: 'RS55',
                name: 'Orenburgskaya Oblast\''
            }, {
                code: 'RS56',
                name: 'Orlovskaya Oblast\''
            }, {
                code: 'RS57',
                name: 'Penzenskaya Oblast\''
            }, {
                code: 'RS90',
                name: 'Permskiy Kray'
            }, {
                code: 'RS59',
                name: 'Primorskiy Kray'
            }, {
                code: 'RS60',
                name: 'Pskovskaya Oblast\''
            }, {
                code: 'RS61',
                name: 'Rostovskaya Oblast\''
            }, {
                code: 'RS62',
                name: 'Ryazanskaya Oblast\''
            }, {
                code: 'RS63',
                name: 'Sakha (Yakutiya) Republic'
            }, {
                code: 'RS64',
                name: 'Sakhalinskaya Oblast\''
            }, {
                code: 'RS65',
                name: 'Samarskaya Oblast\''
            }, {
                code: 'RS66',
                name: 'Sankt-Peterburg Federal City'
            }, {
                code: 'RS67',
                name: 'Saratovskaya Oblast\''
            }, {
                code: 'RS68',
                name: 'Severnaya Osetiya-Alaniya Respublika'
            }, {
                code: 'RS69',
                name: 'Smolenskaya Oblast\''
            }, {
                code: 'RS70',
                name: 'Stavropol\'skiy Kray'
            }, {
                code: 'RS71',
                name: 'Sverdlovskaya Oblast\''
            }, {
                code: 'RS72',
                name: 'Tambovskaya Oblast\''
            }, {
                code: 'RS73',
                name: 'Tatarstan Republic'
            }, {
                code: 'RS74',
                name: 'Taymyrskiy (Dolgano-Nenetskiy) Avtonomnyy Okrug'
            }, {
                code: 'RS75',
                name: 'Tomskaya Oblast\''
            }, {
                code: 'RS76',
                name: 'Tul\'skaya Oblast\''
            }, {
                code: 'RS77',
                name: 'Tverskaya Oblast\''
            }, {
                code: 'RS78',
                name: 'Tyumenskaya Oblast\''
            }, {
                code: 'RS79',
                name: 'Tyva Republic'
            }, {
                code: 'RS80',
                name: 'Udmurtiya Republic'
            }, {
                code: 'RS81',
                name: 'Ul\'yanovskaya Oblast\''
            }, {
                code: 'RS82',
                name: 'Ust\'-Ordynskiy Buryatskiy Avtonomnyy Okrug'
            }, {
                code: 'RS83',
                name: 'Vladimirskaya Oblast\''
            }, {
                code: 'RS84',
                name: 'Volgogradskaya Oblast\''
            }, {
                code: 'RS85',
                name: 'Vologodskaya Oblast\''
            }, {
                code: 'RS86',
                name: 'Voronezhskaya Oblast\''
            }, {
                code: 'RS87',
                name: 'Yamalo-Nenetskiy Avtonomnyy Okrug'
            }, {
                code: 'RS88',
                name: 'Yaroslavskaya Oblast\''
            }, {
                code: 'RS89',
                name: 'Yevreyskaya Avtonomnaya Oblast\''
            }]
    }, {
        code: 'RW',
        id: 2325,
        name: 'Rwanda',
        states: []
    }, {
        code: 'LC',
        id: 2326,
        name: 'Saint Lucia',
        states: []
    }, {
        code: 'SM',
        id: 2327,
        name: 'San Marino',
        states: []
    }, {
        code: 'SA',
        id: 2328,
        name: 'Saudi Arabia',
        states: [{
                code: 'SA02',
                name: 'Al Bahah'
            }, {
                code: 'SA15',
                name: 'Al Hudud ash Shamaliyah'
            }, {
                code: 'SA20',
                name: 'Al Jawf'
            }, {
                code: 'SA05',
                name: 'Al Madinah'
            }, {
                code: 'SA08',
                name: 'Al Qasim'
            }, {
                code: 'SA10',
                name: 'Ar Riyad'
            }, {
                code: 'SA06',
                name: 'Ash Sharqiyah'
            }, {
                code: 'SA11',
                name: 'Asir'
            }, {
                code: 'SA13',
                name: 'Ha\'il'
            }, {
                code: 'SA17',
                name: 'Jizan'
            }, {
                code: 'SA14',
                name: 'Makkah'
            }, {
                code: 'SA16',
                name: 'Najran'
            }, {
                code: 'SA19',
                name: 'Tabuk'
            }]
    }, {
        code: 'SN',
        id: 2329,
        name: 'Senegal',
        states: [{
                code: 'SG01',
                name: 'Dakar'
            }, {
                code: 'SG03',
                name: 'Diourbel'
            }, {
                code: 'SG09',
                name: 'Fatick'
            }, {
                code: 'SG16',
                name: 'Kaffrine'
            }, {
                code: 'SG10',
                name: 'Kaolack'
            }, {
                code: 'SG11',
                name: 'Kolda'
            }, {
                code: 'SG17',
                name: 'Kdougou'
            }, {
                code: 'SG13',
                name: 'Louga'
            }, {
                code: 'SG15',
                name: 'Matam'
            }, {
                code: 'SG14',
                name: 'Saint-Louis'
            }, {
                code: 'SG18',
                name: 'Sdhiou'
            }, {
                code: 'SG05',
                name: 'Tambacounda'
            }, {
                code: 'SG07',
                name: 'This'
            }, {
                code: 'SG12',
                name: 'Ziguinchor'
            }]
    }, {
        code: 'SC',
        id: 2331,
        name: 'Seychelles',
        states: []
    }, {
        code: 'SL',
        id: 2332,
        name: 'Sierra Leone',
        states: []
    }, {
        code: 'SG',
        id: 2333,
        name: 'Singapore',
        states: [{
                code: 'SG01',
                name: 'Central Singapore'
            }, {
                code: 'SG02',
                name: 'North East'
            }, {
                code: 'SG03',
                name: 'North West'
            }, {
                code: 'SG04',
                name: 'South East'
            }, {
                code: 'SG05',
                name: 'South West'
            }]
    }, {
        code: 'SK',
        id: 2334,
        name: 'Slovakia',
        states: [{
                code: 'SK-BC',
                name: 'Banskobystrick kraj'
            }, {
                code: 'SK-BL',
                name: 'Bratislavsk kraj'
            }, {
                code: 'SK-KI',
                name: 'Koick kraj'
            }, {
                code: 'SK-NI',
                name: 'Nitriansky kraj'
            }, {
                code: 'SK-PV',
                name: 'Preovsk kraj'
            }, {
                code: 'SK-TC',
                name: 'Trenciansky kraj'
            }, {
                code: 'SK-TA',
                name: 'Trnavsk kraj'
            }, {
                code: 'SK-ZI',
                name: 'ilinsk kraj'
            }]
    }, {
        code: 'SI',
        id: 2335,
        name: 'Slovenia',
        states: [{
                code: 'SI-001',
                name: 'Ajdovcina'
            }, {
                code: 'SI-195',
                name: 'Apace'
            }, {
                code: 'SI-002',
                name: 'Beltinci'
            }, {
                code: 'SI-148',
                name: 'Benedikt'
            }, {
                code: 'SI-149',
                name: 'Bistrica ob Sotli'
            }, {
                code: 'SI-003',
                name: 'Bled'
            }, {
                code: 'SI-150',
                name: 'Bloke'
            }, {
                code: 'SI-004',
                name: 'Bohinj'
            }, {
                code: 'SI-005',
                name: 'Borovnica'
            }, {
                code: 'SI-006',
                name: 'Bovec'
            }, {
                code: 'SI-151',
                name: 'Braslovce'
            }, {
                code: 'SI-007',
                name: 'Brda'
            }, {
                code: 'SI-008',
                name: 'Brezovica'
            }, {
                code: 'SI-009',
                name: 'Breice'
            }, {
                code: 'SI-152',
                name: 'Cankova'
            }, {
                code: 'SI-011',
                name: 'Celje'
            }, {
                code: 'SI-012',
                name: 'Cerklje na Gorenjskem'
            }, {
                code: 'SI-013',
                name: 'Cerknica'
            }, {
                code: 'SI-014',
                name: 'Cerkno'
            }, {
                code: 'SI-153',
                name: 'Cerkvenjak'
            }, {
                code: 'SI-197',
                name: 'Cirkulane'
            }, {
                code: 'SI-015',
                name: 'Crenovci'
            }, {
                code: 'SI-016',
                name: 'Crna na Korokem'
            }, {
                code: 'SI-017',
                name: 'Crnomelj'
            }, {
                code: 'SI-018',
                name: 'Destrnik'
            }, {
                code: 'SI-019',
                name: 'Divaca'
            }, {
                code: 'SI-154',
                name: 'Dobje'
            }, {
                code: 'SI-020',
                name: 'Dobrepolje'
            }, {
                code: 'SI-155',
                name: 'Dobrna'
            }, {
                code: 'SI-021',
                name: 'Dobrova-Polhov Gradec'
            }, {
                code: 'SI-156',
                name: 'Dobrovnik/Dobronak'
            }, {
                code: 'SI-022',
                name: 'Dol pri Ljubljani'
            }, {
                code: 'SI-157',
                name: 'Dolenjske Toplice'
            }, {
                code: 'SI-023',
                name: 'Domale'
            }, {
                code: 'SI-024',
                name: 'Dornava'
            }, {
                code: 'SI-025',
                name: 'Dravograd'
            }, {
                code: 'SI-026',
                name: 'Duplek'
            }, {
                code: 'SI-027',
                name: 'Gorenja vas-Poljane'
            }, {
                code: 'SI-028',
                name: 'Gorinica'
            }, {
                code: 'SI-207',
                name: 'Gorje'
            }, {
                code: 'SI-029',
                name: 'Gornja Radgona'
            }, {
                code: 'SI-030',
                name: 'Gornji Grad'
            }, {
                code: 'SI-031',
                name: 'Gornji Petrovci'
            }, {
                code: 'SI-158',
                name: 'Grad'
            }, {
                code: 'SI-032',
                name: 'Grosuplje'
            }, {
                code: 'SI-159',
                name: 'Hajdina'
            }, {
                code: 'SI-160',
                name: 'Hoce-Slivnica'
            }, {
                code: 'SI-161',
                name: 'Hodo/Hodos'
            }, {
                code: 'SI-162',
                name: 'Horjul'
            }, {
                code: 'SI-034',
                name: 'Hrastnik'
            }, {
                code: 'SI-035',
                name: 'Hrpelje-Kozina'
            }, {
                code: 'SI-036',
                name: 'Idrija'
            }, {
                code: 'SI-037',
                name: 'Ig'
            }, {
                code: 'SI-038',
                name: 'Ilirska Bistrica'
            }, {
                code: 'SI-039',
                name: 'Ivancna Gorica'
            }, {
                code: 'SI-040',
                name: 'Izola/Isola'
            }, {
                code: 'SI-041',
                name: 'Jesenice'
            }, {
                code: 'SI-163',
                name: 'Jezersko'
            }, {
                code: 'SI-042',
                name: 'Jurinci'
            }, {
                code: 'SI-043',
                name: 'Kamnik'
            }, {
                code: 'SI-044',
                name: 'Kanal'
            }, {
                code: 'SI-045',
                name: 'Kidricevo'
            }, {
                code: 'SI-046',
                name: 'Kobarid'
            }, {
                code: 'SI-047',
                name: 'Kobilje'
            }, {
                code: 'SI-048',
                name: 'Kocevje'
            }, {
                code: 'SI-049',
                name: 'Komen'
            }, {
                code: 'SI-164',
                name: 'Komenda'
            }, {
                code: 'SI-050',
                name: 'Koper/Capodistria'
            }, {
                code: 'SI-196',
                name: 'Kosanjevica na Krki'
            }, {
                code: 'SI-165',
                name: 'Kostel'
            }, {
                code: 'SI-051',
                name: 'Kozje'
            }, {
                code: 'SI-052',
                name: 'Kranj'
            }, {
                code: 'SI-053',
                name: 'Kranjska Gora'
            }, {
                code: 'SI-166',
                name: 'Krievci'
            }, {
                code: 'SI-054',
                name: 'Krko'
            }, {
                code: 'SI-055',
                name: 'Kungota'
            }, {
                code: 'SI-056',
                name: 'Kuzma'
            }, {
                code: 'SI-057',
                name: 'Lako'
            }, {
                code: 'SI-058',
                name: 'Lenart'
            }, {
                code: 'SI-059',
                name: 'Lendava/Lendva'
            }, {
                code: 'SI-060',
                name: 'Litija'
            }, {
                code: 'SI-061',
                name: 'Ljubljana'
            }, {
                code: 'SI-062',
                name: 'Ljubno'
            }, {
                code: 'SI-063',
                name: 'Ljutomer'
            }, {
                code: 'SI-208',
                name: 'Log-Dragomer'
            }, {
                code: 'SI-064',
                name: 'Logatec'
            }, {
                code: 'SI-167',
                name: 'Lovrenc na Pohorju'
            }, {
                code: 'SI-065',
                name: 'Loka dolina'
            }, {
                code: 'SI-066',
                name: 'Loki Potok'
            }, {
                code: 'SI-067',
                name: 'Luce'
            }, {
                code: 'SI-068',
                name: 'Lukovica'
            }, {
                code: 'SI-069',
                name: 'Majperk'
            }, {
                code: 'SI-198',
                name: 'Makole'
            }, {
                code: 'SI-070',
                name: 'Maribor'
            }, {
                code: 'SI-168',
                name: 'Markovci'
            }, {
                code: 'SI-071',
                name: 'Medvode'
            }, {
                code: 'SI-072',
                name: 'Menge'
            }, {
                code: 'SI-073',
                name: 'Metlika'
            }, {
                code: 'SI-074',
                name: 'Meica'
            }, {
                code: 'SI-169',
                name: 'Miklav na Dravskem polju'
            }, {
                code: 'SI-075',
                name: 'Miren-Kostanjevica'
            }, {
                code: 'SI-170',
                name: 'Mirna Pec'
            }, {
                code: 'SI-076',
                name: 'Mislinja'
            }, {
                code: 'SI-199',
                name: 'Mokronog-Trebelno'
            }, {
                code: 'SI-077',
                name: 'Moravce'
            }, {
                code: 'SI-078',
                name: 'Moravske Toplice'
            }, {
                code: 'SI-079',
                name: 'Mozirje'
            }, {
                code: 'SI-080',
                name: 'Murska Sobota'
            }, {
                code: 'SI-081',
                name: 'Muta'
            }, {
                code: 'SI-082',
                name: 'Naklo'
            }, {
                code: 'SI-083',
                name: 'Nazarje'
            }, {
                code: 'SI-084',
                name: 'Nova Gorica'
            }, {
                code: 'SI-085',
                name: 'Novo mesto'
            }, {
                code: 'SI-086',
                name: 'Odranci'
            }, {
                code: 'SI-171',
                name: 'Oplotnica'
            }, {
                code: 'SI-087',
                name: 'Ormo'
            }, {
                code: 'SI-088',
                name: 'Osilnica'
            }, {
                code: 'SI-089',
                name: 'Pesnica'
            }, {
                code: 'SI-090',
                name: 'Piran/Pirano'
            }, {
                code: 'SI-091',
                name: 'Pivka'
            }, {
                code: 'SI-092',
                name: 'Podcetrtek'
            }, {
                code: 'SI-172',
                name: 'Podlehnik'
            }, {
                code: 'SI-093',
                name: 'Podvelka'
            }, {
                code: 'SI-200',
                name: 'Poljcane'
            }, {
                code: 'SI-173',
                name: 'Polzela'
            }, {
                code: 'SI-094',
                name: 'Postojna'
            }, {
                code: 'SI-174',
                name: 'Prebold'
            }, {
                code: 'SI-095',
                name: 'Preddvor'
            }, {
                code: 'SI-175',
                name: 'Prevalje'
            }, {
                code: 'SI-096',
                name: 'Ptuj'
            }, {
                code: 'SI-097',
                name: 'Puconci'
            }, {
                code: 'SI-098',
                name: 'Race-Fram'
            }, {
                code: 'SI-099',
                name: 'Radece'
            }, {
                code: 'SI-100',
                name: 'Radenci'
            }, {
                code: 'SI-101',
                name: 'Radlje ob Dravi'
            }, {
                code: 'SI-102',
                name: 'Radovljica'
            }, {
                code: 'SI-103',
                name: 'Ravne na Korokem'
            }, {
                code: 'SI-176',
                name: 'Razkrije'
            }, {
                code: 'SI-209',
                name: 'Recica ob Savinji'
            }, {
                code: 'SI-201',
                name: 'Rence-Vogrsko'
            }, {
                code: 'SI-104',
                name: 'Ribnica'
            }, {
                code: 'SI-177',
                name: 'Ribnica na Pohorju'
            }, {
                code: 'SI-107',
                name: 'Rogatec'
            }, {
                code: 'SI-106',
                name: 'Rogaka Slatina'
            }, {
                code: 'SI-105',
                name: 'Rogaovci'
            }, {
                code: 'SI-108',
                name: 'Rue'
            }, {
                code: 'SI-178',
                name: 'Selnica ob Dravi'
            }, {
                code: 'SI-109',
                name: 'Semic'
            }, {
                code: 'SI-110',
                name: 'Sevnica'
            }, {
                code: 'SI-111',
                name: 'Seana'
            }, {
                code: 'SI-112',
                name: 'Slovenj Gradec'
            }, {
                code: 'SI-113',
                name: 'Slovenska Bistrica'
            }, {
                code: 'SI-114',
                name: 'Slovenske Konjice'
            }, {
                code: 'SI-179',
                name: 'Sodraica'
            }, {
                code: 'SI-180',
                name: 'Solcava'
            }, {
                code: 'SI-202',
                name: 'Sredice ob Dravi'
            }, {
                code: 'SI-115',
                name: 'Stare'
            }, {
                code: 'SI-203',
                name: 'Straa'
            }, {
                code: 'SI-181',
                name: 'Sveta Ana'
            }, {
                code: 'SI-204',
                name: 'Sveta Trojica v Slovenskih Goricah'
            }, {
                code: 'SI-182',
                name: 'Sveti Andra v Slovenskih goricah'
            }, {
                code: 'SI-116',
                name: 'Sveti Jurij'
            }, {
                code: 'SI-210',
                name: 'Sveti Jurij v Slovenskih Goricah'
            }, {
                code: 'SI-205',
                name: 'Sveti Toma'
            }, {
                code: 'SI-184',
                name: 'Tabor'
            }, {
                code: 'SI-010',
                name: 'Tiina'
            }, {
                code: 'SI-128',
                name: 'Tolmin'
            }, {
                code: 'SI-129',
                name: 'Trbovlje'
            }, {
                code: 'SI-130',
                name: 'Trebnje'
            }, {
                code: 'SI-185',
                name: 'Trnovska vas'
            }, {
                code: 'SI-186',
                name: 'Trzin'
            }, {
                code: 'SI-131',
                name: 'Tric'
            }, {
                code: 'SI-132',
                name: 'Turnice'
            }, {
                code: 'SI-133',
                name: 'Velenje'
            }, {
                code: 'SI-187',
                name: 'Velika Polana'
            }, {
                code: 'SI-134',
                name: 'Velike Lace'
            }, {
                code: 'SI-188',
                name: 'Verej'
            }, {
                code: 'SI-135',
                name: 'Videm'
            }, {
                code: 'SI-136',
                name: 'Vipava'
            }, {
                code: 'SI-137',
                name: 'Vitanje'
            }, {
                code: 'SI-138',
                name: 'Vodice'
            }, {
                code: 'SI-139',
                name: 'Vojnik'
            }, {
                code: 'SI-189',
                name: 'Vransko'
            }, {
                code: 'SI-140',
                name: 'Vrhnika'
            }, {
                code: 'SI-141',
                name: 'Vuzenica'
            }, {
                code: 'SI-142',
                name: 'Zagorje ob Savi'
            }, {
                code: 'SI-143',
                name: 'Zavrc'
            }, {
                code: 'SI-144',
                name: 'Zrece'
            }, {
                code: 'SI-033',
                name: 'alovci'
            }, {
                code: 'SI-183',
                name: 'empeter-Vrtojba'
            }, {
                code: 'SI-117',
                name: 'encur'
            }, {
                code: 'SI-118',
                name: 'entilj'
            }, {
                code: 'SI-119',
                name: 'entjernej'
            }, {
                code: 'SI-120',
                name: 'entjur pri Celju'
            }, {
                code: 'SI-211',
                name: 'entrupert'
            }, {
                code: 'SI-121',
                name: 'kocjan'
            }, {
                code: 'SI-122',
                name: 'kofja Loka'
            }, {
                code: 'SI-123',
                name: 'kofljica'
            }, {
                code: 'SI-124',
                name: 'marje pri Jelah'
            }, {
                code: 'SI-206',
                name: 'marjeke Toplice'
            }, {
                code: 'SI-125',
                name: 'martno ob Paki'
            }, {
                code: 'SI-194',
                name: 'martno pri Litiji'
            }, {
                code: 'SI-194',
                name: 'martno pri Litiji'
            }, {
                code: 'SI-126',
                name: 'otanj'
            }, {
                code: 'SI-127',
                name: 'tore'
            }, {
                code: 'SI-190',
                name: 'alec'
            }, {
                code: 'SI-146',
                name: 'elezniki'
            }, {
                code: 'SI-191',
                name: 'etale'
            }, {
                code: 'SI-147',
                name: 'iri'
            }, {
                code: 'SI-192',
                name: 'irovnica'
            }, {
                code: 'SI-193',
                name: 'uemberk'
            }]
    }, {
        code: 'SB',
        id: 2336,
        name: 'Solomon Islands',
        states: []
    }, {
        code: 'SO',
        id: 2337,
        name: 'Somalia',
        states: []
    }, {
        code: 'ZA',
        id: 2338,
        name: 'South Africa',
        states: [{
                code: 'SF01',
                name: 'Cape Province'
            }, {
                code: 'SF05',
                name: 'Eastern Cape'
            }, {
                code: 'SF03',
                name: 'Free State'
            }, {
                code: 'SF06',
                name: 'Gauteng'
            }, {
                code: 'SF02',
                name: 'KwaZulu-Natal'
            }, {
                code: 'SF09',
                name: 'Limpopo'
            }, {
                code: 'SF07',
                name: 'Mpumalanga'
            }, {
                code: 'SF10',
                name: 'North-West'
            }, {
                code: 'SF08',
                name: 'Northern Cape'
            }, {
                code: 'SF04',
                name: 'Transvaal'
            }, {
                code: 'SF11',
                name: 'Western Cape'
            }]
    }, {
        code: 'ES',
        id: 2339,
        name: 'Spain',
        states: [{
                code: 'SP23',
                name: 'A Corua'
            }, {
                code: 'SP01',
                name: 'Alava'
            }, {
                code: 'SP02',
                name: 'Albacete'
            }, {
                code: 'SP03',
                name: 'Alicante'
            }, {
                code: 'SP04',
                name: 'Almeria'
            }, {
                code: 'SP51',
                name: 'Andalucia'
            }, {
                code: 'SP52',
                name: 'Aragon'
            }, {
                code: 'SP34',
                name: 'Asturias'
            }, {
                code: 'SP05',
                name: 'Avila'
            }, {
                code: 'SP06',
                name: 'Badajoz'
            }, {
                code: 'SP08',
                name: 'Barcelona'
            }, {
                code: 'SP09',
                name: 'Burgos'
            }, {
                code: 'SP10',
                name: 'Caceres'
            }, {
                code: 'SP11',
                name: 'Cadiz'
            }, {
                code: 'SP53',
                name: 'Canarias'
            }, {
                code: 'SP39',
                name: 'Cantabria'
            }, {
                code: 'SP12',
                name: 'Castellon'
            }, {
                code: 'SP55',
                name: 'Castilla y Leon'
            }, {
                code: 'SP54',
                name: 'Castilla-La Mancha'
            }, {
                code: 'SP56',
                name: 'Cataluna'
            }, {
                code: 'SP13',
                name: 'Ciudad Real'
            }, {
                code: 'SP14',
                name: 'Cordoba'
            }, {
                code: 'SP15',
                name: 'Cuenca'
            }, {
                code: 'SP57',
                name: 'Extremadura'
            }, {
                code: 'SP58',
                name: 'Galicia'
            }, {
                code: 'SP16',
                name: 'Gerona'
            }, {
                code: 'SP17',
                name: 'Granada'
            }, {
                code: 'SP18',
                name: 'Guadalajara'
            }, {
                code: 'SP19',
                name: 'Guipuzcoa'
            }, {
                code: 'SP20',
                name: 'Huelva'
            }, {
                code: 'SP21',
                name: 'Huesca'
            }, {
                code: 'SP07',
                name: 'Islas Baleares'
            }, {
                code: 'SP22',
                name: 'Jaen'
            }, {
                code: 'SP23',
                name: 'La Coruna'
            }, {
                code: 'SP27',
                name: 'La Rioja'
            }, {
                code: 'SP24',
                name: 'Las Palmas'
            }, {
                code: 'SP25',
                name: 'Leon'
            }, {
                code: 'SP26',
                name: 'Lerida'
            }, {
                code: 'SP28',
                name: 'Lugo'
            }, {
                code: 'SP29',
                name: 'Madrid'
            }, {
                code: 'SP30',
                name: 'Malaga'
            }, {
                code: 'SP31',
                name: 'Murcia'
            }, {
                code: 'SP32',
                name: 'Navarra'
            }, {
                code: 'SP33',
                name: 'Orense'
            }, {
                code: 'SP59',
                name: 'Pais Vasco'
            }, {
                code: 'SP35',
                name: 'Palencia'
            }, {
                code: 'SP36',
                name: 'Pontevedra'
            }, {
                code: 'SP37',
                name: 'Salamanca'
            }, {
                code: 'SP38',
                name: 'Santa Cruz de Tenerife'
            }, {
                code: 'SP40',
                name: 'Segovia'
            }, {
                code: 'SP41',
                name: 'Sevilla'
            }, {
                code: 'SP42',
                name: 'Soria'
            }, {
                code: 'SP43',
                name: 'Tarragona'
            }, {
                code: 'SP44',
                name: 'Teruel'
            }, {
                code: 'SP45',
                name: 'Toledo'
            }, {
                code: 'SP46',
                name: 'Valencia'
            }, {
                code: 'SP60',
                name: 'Valenciana'
            }, {
                code: 'SP47',
                name: 'Valladolid'
            }, {
                code: 'SP48',
                name: 'Vizcaya'
            }, {
                code: 'SP49',
                name: 'Zamora'
            }, {
                code: 'SP50',
                name: 'Zaragoza'
            }]
    }, {
        code: 'LK',
        id: 2340,
        name: 'Sri Lanka',
        states: []
    }, {
        code: 'SD',
        id: 2341,
        name: 'Sudan',
        states: [{
                code: 'SU42',
                name: 'Blue Nile'
            }, {
                code: 'SU61',
                name: 'Central Darfur'
            }, {
                code: 'SU60',
                name: 'East Darfur'
            }, {
                code: 'SU39',
                name: 'Gedarif'
            }, {
                code: 'SU38',
                name: 'Gezira'
            }, {
                code: 'SU52',
                name: 'Kassala'
            }, {
                code: 'SU29',
                name: 'Khartoum'
            }, {
                code: 'SU55',
                name: 'North Darfur'
            }, {
                code: 'SU56',
                name: 'North Kordofan'
            }, {
                code: 'SU43',
                name: 'Northern'
            }, {
                code: 'SU36',
                name: 'Red Sea'
            }, {
                code: 'SU53',
                name: 'River Nile'
            }, {
                code: 'SU58',
                name: 'Sennar'
            }, {
                code: 'SU49',
                name: 'South Darfur'
            }, {
                code: 'SU50',
                name: 'South Kordofan'
            }, {
                code: 'SU47',
                name: 'West Darfur'
            }, {
                code: 'SU62',
                name: 'West Kordofan'
            }, {
                code: 'SU41',
                name: 'White Nile'
            }]
    }, {
        code: 'SR',
        id: 2342,
        name: 'Suriname',
        states: []
    }, {
        code: 'SZ',
        id: 2343,
        name: 'Swaziland',
        states: []
    }, {
        code: 'SE',
        id: 2344,
        name: 'Sweden',
        states: [{
                code: 'SE-K',
                name: 'Blekinge ln'
            }, {
                code: 'SE-W',
                name: 'Dalarnas ln'
            }, {
                code: 'SE-I',
                name: 'Gotlands ln'
            }, {
                code: 'SE-X',
                name: 'Gvleborgs ln'
            }, {
                code: 'SE-N',
                name: 'Hallands ln'
            }, {
                code: 'SE-Z',
                name: 'Jmtlands ln'
            }, {
                code: 'SE-F',
                name: 'Jnkpings ln'
            }, {
                code: 'SE-H',
                name: 'Kalmar ln'
            }, {
                code: 'SE-G',
                name: 'Kronobergs ln'
            }, {
                code: 'SE-BD',
                name: 'Norrbottens ln'
            }, {
                code: 'SE-M',
                name: 'Skne ln '
            }, {
                code: 'SE-AB',
                name: 'Stockholms ln'
            }, {
                code: 'SE-D',
                name: 'Sdermanlands ln'
            }, {
                code: 'SE-C',
                name: 'Uppsala ln'
            }, {
                code: 'SE-S',
                name: 'Vrmlands ln'
            }, {
                code: 'SE-AC',
                name: 'Vsterbottens ln'
            }, {
                code: 'SE-Y',
                name: 'Vsternorrlands ln'
            }, {
                code: 'SE-U',
                name: 'Vstmanlands ln'
            }, {
                code: 'SE-O',
                name: 'Vstra Gtalands ln'
            }, {
                code: 'SE-T',
                name: 'rebro ln'
            }, {
                code: 'SE-E',
                name: 'stergtlands ln'
            }]
    }, {
        code: 'CH',
        id: 2345,
        name: 'Switzerland',
        states: [{
                code: 'AG',
                name: 'Aargau '
            }, {
                code: 'AR',
                name: 'Appenzell Ausserrhoden '
            }, {
                code: 'AI',
                name: 'Appenzell Innerrhoden '
            }, {
                code: 'BL',
                name: 'Basel-Landschaft '
            }, {
                code: 'BS',
                name: 'Basel-Stadt '
            }, {
                code: 'BE',
                name: 'Bern '
            }, {
                code: 'FR',
                name: 'Fribourg '
            }, {
                code: 'GE',
                name: 'Genve '
            }, {
                code: 'GL',
                name: 'Glarus '
            }, {
                code: 'GR',
                name: 'Graubnden '
            }, {
                code: 'JU',
                name: 'Jura '
            }, {
                code: 'LU',
                name: 'Luzern '
            }, {
                code: 'NE',
                name: 'Neuchtel '
            }, {
                code: 'NW',
                name: 'Nidwalden '
            }, {
                code: 'OW',
                name: 'Obwalden '
            }, {
                code: 'SG',
                name: 'Sankt Gallen '
            }, {
                code: 'SH',
                name: 'Schaffhausen '
            }, {
                code: 'SZ',
                name: 'Schwyz '
            }, {
                code: 'SO',
                name: 'Solothurn '
            }, {
                code: 'TG',
                name: 'Thurgau '
            }, {
                code: 'TI',
                name: 'Ticino '
            }, {
                code: 'UR',
                name: 'Uri '
            }, {
                code: 'VS',
                name: 'Valais '
            }, {
                code: 'VD',
                name: 'Vaud '
            }, {
                code: 'ZG',
                name: 'Zug '
            }, {
                code: 'ZH',
                name: 'Zrich '
            }]
    }, {
        code: 'TJ',
        id: 2348,
        name: 'Tajikistan',
        states: []
    }, {
        code: 'TZ',
        id: 2349,
        name: 'Tanzania',
        states: [{
                code: 'TZ26',
                name: 'Arusha'
            }, {
                code: 'TZ23',
                name: 'Dar es Salaam'
            }, {
                code: 'TZ03',
                name: 'Dodoma'
            }, {
                code: 'TZ28',
                name: 'Geita'
            }, {
                code: 'TZ04',
                name: 'Iringa'
            }, {
                code: 'TZ19',
                name: 'Kagera'
            }, {
                code: 'TZ29',
                name: 'Katavi'
            }, {
                code: 'TZ05',
                name: 'Kigoma'
            }, {
                code: 'TZ06',
                name: 'Kilimanjaro'
            }, {
                code: 'TZ07',
                name: 'Lindi'
            }, {
                code: 'TZ27',
                name: 'Manyara'
            }, {
                code: 'TZ08',
                name: 'Mara'
            }, {
                code: 'TZ09',
                name: 'Mbeya'
            }, {
                code: 'TZ10',
                name: 'Morogoro'
            }, {
                code: 'TZ11',
                name: 'Mtwara'
            }, {
                code: 'TZ12',
                name: 'Mwanza'
            }, {
                code: 'TZ30',
                name: 'Njombe'
            }, {
                code: 'TZ13',
                name: 'Pemba North'
            }, {
                code: 'TZ20',
                name: 'Pemba South'
            }, {
                code: 'TZ02',
                name: 'Pwani'
            }, {
                code: 'TZ24',
                name: 'Rukwa'
            }, {
                code: 'TZ14',
                name: 'Ruvuma'
            }, {
                code: 'TZ15',
                name: 'Shinyanga'
            }, {
                code: 'TZ31',
                name: 'Simiyu'
            }, {
                code: 'TZ16',
                name: 'Singida'
            }, {
                code: 'TZ17',
                name: 'Tabora'
            }, {
                code: 'TZ18',
                name: 'Tanga'
            }, {
                code: 'TZ22',
                name: 'Zanzibar North'
            }, {
                code: 'TZ21',
                name: 'Zanzibar South and Central'
            }, {
                code: 'TZ25',
                name: 'Zanzibar West'
            }]
    }, {
        code: 'TH',
        id: 2350,
        name: 'Thailand',
        states: [{
                code: 'TH77',
                name: 'Amnat Charoen'
            }, {
                code: 'TH35',
                name: 'Ang Thong'
            }, {
                code: 'TH40',
                name: 'Bangkok Metropolis'
            }, {
                code: 'TH81',
                name: 'Bueng Kan'
            }, {
                code: 'TH28',
                name: 'Buri Ram'
            }, {
                code: 'TH44',
                name: 'Chachoengsao'
            }, {
                code: 'TH32',
                name: 'Chai Nat'
            }, {
                code: 'TH26',
                name: 'Chaiyaphum'
            }, {
                code: 'TH48',
                name: 'Chanthaburi'
            }, {
                code: 'TH02',
                name: 'Chiang Mai'
            }, {
                code: 'TH03',
                name: 'Chiang Rai'
            }, {
                code: 'TH46',
                name: 'Chon Buri'
            }, {
                code: 'TH58',
                name: 'Chumphon'
            }, {
                code: 'TH23',
                name: 'Kalasin'
            }, {
                code: 'TH11',
                name: 'Kamphaeng Phet'
            }, {
                code: 'TH50',
                name: 'Kanchanaburi'
            }, {
                code: 'TH22',
                name: 'Khon Kaen'
            }, {
                code: 'TH63',
                name: 'Krabi'
            }, {
                code: 'TH06',
                name: 'Lampang'
            }, {
                code: 'TH05',
                name: 'Lamphun'
            }, {
                code: 'TH18',
                name: 'Loei'
            }, {
                code: 'TH34',
                name: 'Lop Buri'
            }, {
                code: 'TH01',
                name: 'Mae Hong Son'
            }, {
                code: 'TH24',
                name: 'Maha Sarakham'
            }, {
                code: 'TH78',
                name: 'Mukdahan'
            }, {
                code: 'TH43',
                name: 'Nakhon Nayok'
            }, {
                code: 'TH53',
                name: 'Nakhon Pathom'
            }, {
                code: 'TH73',
                name: 'Nakhon Phanom'
            }, {
                code: 'TH27',
                name: 'Nakhon Ratchasima'
            }, {
                code: 'TH16',
                name: 'Nakhon Sawan'
            }, {
                code: 'TH64',
                name: 'Nakhon Si Thammarat'
            }, {
                code: 'TH04',
                name: 'Nan'
            }, {
                code: 'TH31',
                name: 'Narathiwat'
            }, {
                code: 'TH79',
                name: 'Nong Bua Lam Phu'
            }, {
                code: 'TH17',
                name: 'Nong Khai'
            }, {
                code: 'TH38',
                name: 'Nonthaburi'
            }, {
                code: 'TH39',
                name: 'Pathum Thani'
            }, {
                code: 'TH69',
                name: 'Pattani'
            }, {
                code: 'TH61',
                name: 'Phangnga'
            }, {
                code: 'TH66',
                name: 'Phatthalung'
            }, {
                code: 'TH41',
                name: 'Phayao'
            }, {
                code: 'TH14',
                name: 'Phetchabun'
            }, {
                code: 'TH56',
                name: 'Phetchaburi'
            }, {
                code: 'TH13',
                name: 'Phichit'
            }, {
                code: 'TH12',
                name: 'Phitsanulok'
            }, {
                code: 'TH36',
                name: 'Phra Nakhon Si Ayutthaya'
            }, {
                code: 'TH07',
                name: 'Phrae'
            }, {
                code: 'TH62',
                name: 'Phuket'
            }, {
                code: 'TH74',
                name: 'Prachin Buri'
            }, {
                code: 'TH57',
                name: 'Prachuap Khiri Khan'
            }, {
                code: 'TH59',
                name: 'Ranong'
            }, {
                code: 'TH52',
                name: 'Ratchaburi'
            }, {
                code: 'TH47',
                name: 'Rayong'
            }, {
                code: 'TH25',
                name: 'Roi Et'
            }, {
                code: 'TH80',
                name: 'Sa Kaeo'
            }, {
                code: 'TH20',
                name: 'Sakon Nakhon'
            }, {
                code: 'TH42',
                name: 'Samut Prakan'
            }, {
                code: 'TH55',
                name: 'Samut Sakhon'
            }, {
                code: 'TH54',
                name: 'Samut Songkhram'
            }, {
                code: 'TH37',
                name: 'Saraburi'
            }, {
                code: 'TH67',
                name: 'Satun'
            }, {
                code: 'TH30',
                name: 'Si Sa Ket'
            }, {
                code: 'TH33',
                name: 'Sing Buri'
            }, {
                code: 'TH68',
                name: 'Songkhla'
            }, {
                code: 'TH09',
                name: 'Sukhothai'
            }, {
                code: 'TH51',
                name: 'Suphan Buri'
            }, {
                code: 'TH60',
                name: 'Surat Thani'
            }, {
                code: 'TH29',
                name: 'Surin'
            }, {
                code: 'TH08',
                name: 'Tak'
            }, {
                code: 'TH65',
                name: 'Trang'
            }, {
                code: 'TH49',
                name: 'Trat'
            }, {
                code: 'TH75',
                name: 'Ubon Ratchathani'
            }, {
                code: 'TH76',
                name: 'Udon Thani'
            }, {
                code: 'TH15',
                name: 'Uthai Thani'
            }, {
                code: 'TH10',
                name: 'Uttaradit'
            }, {
                code: 'TH70',
                name: 'Yala'
            }, {
                code: 'TH72',
                name: 'Yasothon'
            }]
    }, {
        code: 'TG',
        id: 2351,
        name: 'Togo',
        states: []
    }, {
        code: 'TT',
        id: 2352,
        name: 'Trinidad and Tobago',
        states: [{
                code: 'TD01',
                name: 'Arima'
            }, {
                code: 'TD13',
                name: 'Chaguanas'
            }, {
                code: 'TD14',
                name: 'Couva/Tabaquite/Talparo'
            }, {
                code: 'TD15',
                name: 'Diego Martin'
            }, {
                code: 'TD11',
                name: 'Eastern Tobago'
            }, {
                code: 'TD16',
                name: 'Mayaro/Rio Claro'
            }, {
                code: 'TD17',
                name: 'Penal/Debe'
            }, {
                code: 'TD18',
                name: 'Point Fortin'
            }, {
                code: 'TD05',
                name: 'Port of Spain'
            }, {
                code: 'TD19',
                name: 'Princes Town'
            }, {
                code: 'TD10',
                name: 'San Fernando'
            }, {
                code: 'TD20',
                name: 'San Juan/Laventille'
            }, {
                code: 'TD21',
                name: 'Sangre Grande'
            }, {
                code: 'TD22',
                name: 'Siparia'
            }, {
                code: 'TD23',
                name: 'Tunapuna/Piarco'
            }, {
                code: 'TD11',
                name: 'Western Tobago'
            }]
    }, {
        code: 'TN',
        id: 2353,
        name: 'Tunisia',
        states: []
    }, {
        code: 'TR',
        id: 2354,
        name: 'Turkey',
        states: [{
                code: 'TU81',
                name: 'Adana'
            }, {
                code: 'TU02',
                name: 'Adiyaman'
            }, {
                code: 'TU03',
                name: 'Afyonkarahisar'
            }, {
                code: 'TU04',
                name: 'Agri'
            }, {
                code: 'TU75',
                name: 'Aksaray'
            }, {
                code: 'TU05',
                name: 'Amasya'
            }, {
                code: 'TU68',
                name: 'Ankara'
            }, {
                code: 'TU07',
                name: 'Antalya'
            }, {
                code: 'TU86',
                name: 'Ardahan'
            }, {
                code: 'TU08',
                name: 'Artvin'
            }, {
                code: 'TU09',
                name: 'Aydin'
            }, {
                code: 'TU10',
                name: 'Balikesir'
            }, {
                code: 'TU87',
                name: 'Bartin'
            }, {
                code: 'TU76',
                name: 'Batman'
            }, {
                code: 'TU77',
                name: 'Bayburt'
            }, {
                code: 'TU11',
                name: 'Bilecik'
            }, {
                code: 'TU12',
                name: 'Bingl'
            }, {
                code: 'TU13',
                name: 'Bitlis'
            }, {
                code: 'TU14',
                name: 'Bolu'
            }, {
                code: 'TU15',
                name: 'Burdur'
            }, {
                code: 'TU16',
                name: 'Bursa'
            }, {
                code: 'TU20',
                name: 'Denizli'
            }, {
                code: 'TU21',
                name: 'Diyarbakir'
            }, {
                code: 'TU93',
                name: 'Dzce'
            }, {
                code: 'TU22',
                name: 'Edirne'
            }, {
                code: 'TU23',
                name: 'Elazig'
            }, {
                code: 'TU24',
                name: 'Erzincan'
            }, {
                code: 'TU25',
                name: 'Erzurum'
            }, {
                code: 'TU26',
                name: 'Eskisehir'
            }, {
                code: 'TU83',
                name: 'Gaziantep'
            }, {
                code: 'TU28',
                name: 'Giresun'
            }, {
                code: 'TU69',
                name: 'Gmshane'
            }, {
                code: 'TU70',
                name: 'Hakkari'
            }, {
                code: 'TU31',
                name: 'Hatay'
            }, {
                code: 'TU88',
                name: 'Igdir'
            }, {
                code: 'TU33',
                name: 'Isparta'
            }, {
                code: 'TU34',
                name: 'Istanbul'
            }, {
                code: 'TU35',
                name: 'Izmir'
            }, {
                code: 'TU46',
                name: 'Kahramanmaras'
            }, {
                code: 'TU89',
                name: 'Karabk'
            }, {
                code: 'TU78',
                name: 'Karaman'
            }, {
                code: 'TU84',
                name: 'Kars'
            }, {
                code: 'TU37',
                name: 'Kastamonu'
            }, {
                code: 'TU38',
                name: 'Kayseri'
            }, {
                code: 'TU90',
                name: 'Kilis'
            }, {
                code: 'TU79',
                name: 'Kirikkale'
            }, {
                code: 'TU39',
                name: 'Kirklareli'
            }, {
                code: 'TU40',
                name: 'Kirsehir'
            }, {
                code: 'TU41',
                name: 'Kocaeli'
            }, {
                code: 'TU71',
                name: 'Konya'
            }, {
                code: 'TU43',
                name: 'Ktahya'
            }, {
                code: 'TU44',
                name: 'Malatya'
            }, {
                code: 'TU45',
                name: 'Manisa'
            }, {
                code: 'TU72',
                name: 'Mardin'
            }, {
                code: 'TU32',
                name: 'Mersin'
            }, {
                code: 'TU48',
                name: 'Mugla'
            }, {
                code: 'TU49',
                name: 'Mus'
            }, {
                code: 'TU50',
                name: 'Nevsehir'
            }, {
                code: 'TU73',
                name: 'Nigde'
            }, {
                code: 'TU52',
                name: 'Ordu'
            }, {
                code: 'TU91',
                name: 'Osmaniye'
            }, {
                code: 'TU53',
                name: 'Rize'
            }, {
                code: 'TU54',
                name: 'Sakarya'
            }, {
                code: 'TU55',
                name: 'Samsun'
            }, {
                code: 'TU63',
                name: 'Sanliurfa'
            }, {
                code: 'TU74',
                name: 'Siirt'
            }, {
                code: 'TU57',
                name: 'Sinop'
            }, {
                code: 'TU80',
                name: 'Sirnak'
            }, {
                code: 'TU58',
                name: 'Sivas'
            }, {
                code: 'TU59',
                name: 'Tekirdag'
            }, {
                code: 'TU60',
                name: 'Tokat'
            }, {
                code: 'TU61',
                name: 'Trabzon'
            }, {
                code: 'TU62',
                name: 'Tunceli'
            }, {
                code: 'TU64',
                name: 'Usak'
            }, {
                code: 'TU65',
                name: 'Van'
            }, {
                code: 'TU92',
                name: 'Yalova'
            }, {
                code: 'TU66',
                name: 'Yozgat'
            }, {
                code: 'TU85',
                name: 'Zonguldak'
            }, {
                code: 'TU17',
                name: 'anakkale'
            }, {
                code: 'TU82',
                name: 'ankiri'
            }, {
                code: 'TU19',
                name: 'orum'
            }]
    }, {
        code: 'TM',
        id: 2355,
        name: 'Turkmenistan',
        states: []
    }, {
        code: 'UG',
        id: 2356,
        name: 'Uganda',
        states: []
    }, {
        code: 'UA',
        id: 2357,
        name: 'Ukraine',
        states: [{
                code: 'UP01',
                name: 'Cherkasy'
            }, {
                code: 'UP02',
                name: 'Chernihiv'
            }, {
                code: 'UP03',
                name: 'Chernivtsi'
            }, {
                code: 'UP11',
                name: 'Crimea'
            }, {
                code: 'UP04',
                name: 'Dnipropetrovs\'k'
            }, {
                code: 'UP05',
                name: 'Donets\'k'
            }, {
                code: 'UP06',
                name: 'Ivano-Frankivs\'k'
            }, {
                code: 'UP07',
                name: 'Kharkiv'
            }, {
                code: 'UP08',
                name: 'Kherson'
            }, {
                code: 'UP09',
                name: 'Khmel\'nyts\'kyy'
            }, {
                code: 'UP13',
                name: 'Kiev'
            }, {
                code: 'UP12',
                name: 'Kiev City'
            }, {
                code: 'UP10',
                name: 'Kirovohrad'
            }, {
                code: 'UP15',
                name: 'L\'viv'
            }, {
                code: 'UP14',
                name: 'Luhans\'k'
            }, {
                code: 'UP16',
                name: 'Mykolayiv'
            }, {
                code: 'UP17',
                name: 'Odessa'
            }, {
                code: 'UP18',
                name: 'Poltava'
            }, {
                code: 'UP19',
                name: 'Rivne'
            }, {
                code: 'UP20',
                name: 'Sevastopol\' City'
            }, {
                code: 'UP21',
                name: 'Sumy'
            }, {
                code: 'UP22',
                name: 'Ternopil\''
            }, {
                code: 'UP25',
                name: 'Transcarpathia'
            }, {
                code: 'UP23',
                name: 'Vinnytsya'
            }, {
                code: 'UP24',
                name: 'Volyn'
            }, {
                code: 'UP26',
                name: 'Zaporizhzhya'
            }, {
                code: 'UP27',
                name: 'Zhytomyr'
            }]
    }, {
        code: 'AE',
        id: 2358,
        name: 'United Arab Emirates',
        states: [{
                code: 'AE02',
                name: '\'Ajman'
            }, {
                code: 'AE01',
                name: 'Abu Dhabi'
            }, {
                code: 'AE04',
                name: 'Al Fujayrah'
            }, {
                code: 'AE03',
                name: 'Dubai'
            }, {
                code: 'AE05',
                name: 'Ra\'s al Khaymah'
            }, {
                code: 'AE06',
                name: 'Sharjah'
            }, {
                code: 'AE07',
                name: 'Umm al Qaywayn'
            }]
    }, {
        code: 'UK',
        id: 2359,
        name: 'United Kingdom',
        states: [{
                code: 'ABC',
                name: 'Aberconwy and Colwyn'
            }, {
                code: 'ABD',
                name: 'Aberdeenshire'
            }, {
                code: 'ALD',
                name: 'Alderney'
            }, {
                code: 'ANS',
                name: 'Angus'
            }, {
                code: 'ANT',
                name: 'Antrim'
            }, {
                code: 'ARD',
                name: 'Ards'
            }, {
                code: 'ARG',
                name: 'Argyllshire'
            }, {
                code: 'ARM',
                name: 'Armagh'
            }, {
                code: 'AVN',
                name: 'Avon'
            }, {
                code: 'AYR',
                name: 'Ayrshire'
            }, {
                code: 'BLA',
                name: 'Ballymena'
            }, {
                code: 'BAY',
                name: 'Ballymoney'
            }, {
                code: 'BNB',
                name: 'Banbridge'
            }, {
                code: 'BAN',
                name: 'Banffshire'
            }, {
                code: 'BDF',
                name: 'Bedfordshire'
            }, {
                code: 'BEL',
                name: 'Belfast'
            }, {
                code: 'BRK',
                name: 'Berkshire'
            }, {
                code: 'BEW',
                name: 'Berwickshire'
            }, {
                code: 'BGW',
                name: 'Blaenau Gwent'
            }, {
                code: 'BOR',
                name: 'Borders'
            }, {
                code: 'BRE',
                name: 'Breconshire'
            }, {
                code: 'BRG',
                name: 'Bridgend'
            }, {
                code: 'BKM',
                name: 'Buckinghamshire'
            }, {
                code: 'BUT',
                name: 'Bute'
            }, {
                code: 'CAE',
                name: 'Caernarvonshire'
            }, {
                code: 'UKX4',
                name: 'Caerphilly'
            }, {
                code: 'CAI',
                name: 'Caithness'
            }, {
                code: 'CAM',
                name: 'Cambridgeshire'
            }, {
                code: 'UKX5',
                name: 'Cardiff'
            }, {
                code: 'CGN',
                name: 'Cardiganshire'
            }, {
                code: 'CMN',
                name: 'Carmarthenshire'
            }, {
                code: 'CAR',
                name: 'Carrickfergus'
            }, {
                code: 'CAS',
                name: 'Castlereagh'
            }, {
                code: 'CEN',
                name: 'Central'
            }, {
                code: 'UKX6',
                name: 'Ceredigion'
            }, {
                code: 'CHS',
                name: 'Cheshire'
            }, {
                code: 'CLK',
                name: 'Clackmannanshire'
            }, {
                code: 'CLV',
                name: 'Cleveland'
            }, {
                code: 'CWD',
                name: 'Clwyd'
            }, {
                code: 'COL',
                name: 'Coleraine'
            }, {
                code: 'UKX8',
                name: 'Conwy'
            }, {
                code: 'COO',
                name: 'Cookstown'
            }, {
                code: 'CON',
                name: 'Cornwall'
            }, {
                code: 'CRA',
                name: 'Craigavon'
            }, {
                code: 'CUL',
                name: 'Cumberland'
            }, {
                code: 'CMA',
                name: 'Cumbria'
            }, {
                code: 'DEN',
                name: 'Denbighshire'
            }, {
                code: 'DBY',
                name: 'Derbyshire'
            }, {
                code: 'DEV',
                name: 'Devon'
            }, {
                code: 'DOR',
                name: 'Dorset'
            }, {
                code: 'DOW',
                name: 'Down'
            }, {
                code: 'DNB',
                name: 'Dumbartonshire'
            }, {
                code: 'DGY',
                name: 'Dumfries and Galloway'
            }, {
                code: 'DFS',
                name: 'Dumfries-shire'
            }, {
                code: 'DUN',
                name: 'Dungannon'
            }, {
                code: 'DUR',
                name: 'Durham'
            }, {
                code: 'DFD',
                name: 'Dyfed'
            }, {
                code: 'SXE',
                name: 'East Sussex'
            }, {
                code: 'ERY',
                name: 'East Yorkshire'
            }, {
                code: 'ELG',
                name: 'Elgin'
            }, {
                code: 'ESS',
                name: 'Essex'
            }, {
                code: 'FER',
                name: 'Fermanagh'
            }, {
                code: 'FIF',
                name: 'Fife'
            }, {
                code: 'FLN',
                name: 'Flintshire'
            }, {
                code: 'GLM',
                name: 'Glamorgan'
            }, {
                code: 'GLS',
                name: 'Gloucestershire'
            }, {
                code: 'GMP',
                name: 'Grampian'
            }, {
                code: 'LON',
                name: 'Greater London'
            }, {
                code: 'GTM',
                name: 'Greater Manchester'
            }, {
                code: 'GSY',
                name: 'Guernsey'
            }, {
                code: 'GNT',
                name: 'Gwent'
            }, {
                code: 'GWN',
                name: 'Gwynedd'
            }, {
                code: 'GWO',
                name: 'Gwynedo'
            }, {
                code: 'HDG',
                name: 'Haddingtonshire'
            }, {
                code: 'HAM',
                name: 'Hampshire'
            }, {
                code: 'HWR',
                name: 'Hereford and Worcester'
            }, {
                code: 'HEF',
                name: 'Herefordshire'
            }, {
                code: 'HRM',
                name: 'Herm'
            }, {
                code: 'HRT',
                name: 'Hertfordshire'
            }, {
                code: 'HLD',
                name: 'Highland'
            }, {
                code: 'HUM',
                name: 'Humberside'
            }, {
                code: 'HUN',
                name: 'Huntingdonshire'
            }, {
                code: 'INV',
                name: 'Inverness-shire'
            }, {
                code: 'AGY',
                name: 'Isle of Anglesey'
            }, {
                code: 'IOM',
                name: 'Isle of Man'
            }, {
                code: 'IOW',
                name: 'Isle of Wight'
            }, {
                code: 'JSY',
                name: 'Jersey'
            }, {
                code: 'KEN',
                name: 'Kent'
            }, {
                code: 'KCD',
                name: 'Kincardineshire'
            }, {
                code: 'KRS',
                name: 'Kinross-shire'
            }, {
                code: 'KKD',
                name: 'Kirkcudbrightshire'
            }, {
                code: 'LKS',
                name: 'Lanarkshire'
            }, {
                code: 'LAN',
                name: 'Lancashire'
            }, {
                code: 'LAR',
                name: 'Larne'
            }, {
                code: 'LEI',
                name: 'Leicestershire'
            }, {
                code: 'LIM',
                name: 'Limavady'
            }, {
                code: 'LIN',
                name: 'Lincolnshire'
            }, {
                code: 'LIS',
                name: 'Lisburn'
            }, {
                code: 'LDY',
                name: 'Londonderry/Derry'
            }, {
                code: 'LTN',
                name: 'Lothian'
            }, {
                code: 'MAG',
                name: 'Magherafelt'
            }, {
                code: 'MTH',
                name: 'Merionethshire'
            }, {
                code: 'MER',
                name: 'Merseyside'
            }, {
                code: 'UKY3',
                name: 'Merthyr Tydfil'
            }, {
                code: 'MGM',
                name: 'Mid Glamorgan'
            }, {
                code: 'MDX',
                name: 'Middlesex'
            }, {
                code: 'MLN',
                name: 'Midlothian'
            }, {
                code: 'MON',
                name: 'Monmouthshire'
            }, {
                code: 'MGY',
                name: 'Montgomeryshire'
            }, {
                code: 'MOR',
                name: 'Morayshire'
            }, {
                code: 'MOY',
                name: 'Moyle'
            }, {
                code: 'NAI',
                name: 'Nairn'
            }, {
                code: 'NPT',
                name: 'Neath Port Talbot'
            }, {
                code: 'UKY6',
                name: 'Newport'
            }, {
                code: 'NEM',
                name: 'Newry and Mourne'
            }, {
                code: 'NWT',
                name: 'Newtownabbey'
            }, {
                code: 'NFK',
                name: 'Norfolk'
            }, {
                code: 'NDW',
                name: 'North Down'
            }, {
                code: 'NRY',
                name: 'North Yorkshire'
            }, {
                code: 'NTH',
                name: 'Northamptonshire'
            }, {
                code: 'NBL',
                name: 'Northumberland'
            }, {
                code: 'NOT',
                name: 'Nottinghamshire'
            }, {
                code: 'OMA',
                name: 'Omagh'
            }, {
                code: 'UKV9',
                name: 'Orkney Islands'
            }, {
                code: 'OXF',
                name: 'Oxfordshire'
            }, {
                code: 'PEE',
                name: 'Peebles-shire'
            }, {
                code: 'PEM',
                name: 'Pembrokeshire'
            }, {
                code: 'PER',
                name: 'Perthshire and Kinross'
            }, {
                code: 'POW',
                name: 'Powys'
            }, {
                code: 'RAD',
                name: 'Radnorshire'
            }, {
                code: 'RFW',
                name: 'Renfrewshire'
            }, {
                code: 'RCT',
                name: 'Rhondda Cynon Taff'
            }, {
                code: 'ROC',
                name: 'Ross and Cromarty'
            }, {
                code: 'ROX',
                name: 'Roxburghshire'
            }, {
                code: 'RUT',
                name: 'Rutland'
            }, {
                code: 'SRK',
                name: 'Sark'
            }, {
                code: 'SEL',
                name: 'Selkirkshire'
            }, {
                code: 'SHI',
                name: 'Shetland'
            }, {
                code: 'SAL',
                name: 'Shropshire'
            }, {
                code: 'SOM',
                name: 'Somerset'
            }, {
                code: 'SGM',
                name: 'South Glamorgan'
            }, {
                code: 'SYK',
                name: 'South Yorkshire'
            }, {
                code: 'STS',
                name: 'Staffordshire'
            }, {
                code: 'STI',
                name: 'Stirlingshire'
            }, {
                code: 'STR',
                name: 'Strabane'
            }, {
                code: 'STD',
                name: 'Strathclyde'
            }, {
                code: 'SFK',
                name: 'Suffolk'
            }, {
                code: 'SRY',
                name: 'Surrey'
            }, {
                code: 'SSX',
                name: 'Sussex'
            }, {
                code: 'SUT',
                name: 'Sutherland'
            }, {
                code: 'SWA',
                name: 'Swansea'
            }, {
                code: 'TAY',
                name: 'Tayside'
            }, {
                code: 'TRF',
                name: 'Torfaen'
            }, {
                code: 'TWR',
                name: 'Tyne and Wear'
            }, {
                code: 'TRN',
                name: 'Tyrone'
            }, {
                code: 'VOG',
                name: 'Vale of Glamorgan'
            }, {
                code: 'WAR',
                name: 'Warwickshire'
            }, {
                code: 'WGM',
                name: 'West Glamorgan'
            }, {
                code: 'WLN',
                name: 'West Lothian'
            }, {
                code: 'WMD',
                name: 'West Midlands'
            }, {
                code: 'SWX',
                name: 'West Sussex'
            }, {
                code: 'WRY',
                name: 'West Yorkshire'
            }, {
                code: 'WIS',
                name: 'Western Isles'
            }, {
                code: 'WES',
                name: 'Westmoreland'
            }, {
                code: 'WIG',
                name: 'Wigtownshire'
            }, {
                code: 'WIL',
                name: 'Wiltshire'
            }, {
                code: 'WOR',
                name: 'Worcestershire'
            }, {
                code: 'UKZ4',
                name: 'Wrexham'
            }, {
                code: 'YKS',
                name: 'Yorkshire'
            }]
    }, {
        code: 'UY',
        id: 2360,
        name: 'Uruguay',
        states: []
    }, {
        code: 'UZ',
        id: 2361,
        name: 'Uzbekistan',
        states: []
    }, {
        code: 'VA',
        id: 2362,
        name: 'Holy See (Vatican City State)',
        states: []
    }, {
        code: 'VE',
        id: 2363,
        name: 'Venezuela; Bolivarian Republic of',
        states: [{
                code: 'VE01',
                name: 'Amazonas'
            }, {
                code: 'VE02',
                name: 'Anzotegui'
            }, {
                code: 'VE03',
                name: 'Apure'
            }, {
                code: 'VE04',
                name: 'Aragua'
            }, {
                code: 'VE05',
                name: 'Barinas'
            }, {
                code: 'VE06',
                name: 'Bolvar'
            }, {
                code: 'VE07',
                name: 'Carabobo'
            }, {
                code: 'VE08',
                name: 'Cojedes'
            }, {
                code: 'VE09',
                name: 'Delta Amacuro'
            }, {
                code: 'VE24',
                name: 'Dependencias Federales'
            }, {
                code: 'VE25',
                name: 'Distrito Capital'
            }, {
                code: 'VE11',
                name: 'Falcn'
            }, {
                code: 'VE12',
                name: 'Gurico'
            }, {
                code: 'VE13',
                name: 'Lara'
            }, {
                code: 'VE15',
                name: 'Miranda'
            }, {
                code: 'VE16',
                name: 'Monagas'
            }, {
                code: 'VE14',
                name: 'Mrida'
            }, {
                code: 'VE17',
                name: 'Nueva Esparta'
            }, {
                code: 'VE18',
                name: 'Portuguesa'
            }, {
                code: 'VE19',
                name: 'Sucre'
            }, {
                code: 'VE21',
                name: 'Trujillo'
            }, {
                code: 'VE20',
                name: 'Tchira'
            }, {
                code: 'VE26',
                name: 'Vargas'
            }, {
                code: 'VE22',
                name: 'Yaracuy'
            }, {
                code: 'VE23',
                name: 'Zulia'
            }]
    }, {
        code: 'VN',
        id: 2364,
        name: 'Vietnam',
        states: [{
                code: 'VM01',
                name: 'An Giang'
            }, {
                code: 'VM45',
                name: 'Ba Ria-Vung Tau'
            }, {
                code: 'VM72',
                name: 'Bac Can'
            }, {
                code: 'VM71',
                name: 'Bac Giang'
            }, {
                code: 'VM73',
                name: 'Bac Lieu'
            }, {
                code: 'VM74',
                name: 'Bac Ninh'
            }, {
                code: 'VM03',
                name: 'Ben Tre'
            }, {
                code: 'VM46',
                name: 'Binh Dinh'
            }, {
                code: 'VM75',
                name: 'Binh Duong'
            }, {
                code: 'VM76',
                name: 'Binh Phuoc'
            }, {
                code: 'VM47',
                name: 'Binh Thuan'
            }, {
                code: 'VM77',
                name: 'Ca Mau'
            }, {
                code: 'VM87',
                name: 'Can Tho'
            }, {
                code: 'VM05',
                name: 'Cao Bang'
            }, {
                code: 'VM78',
                name: 'Da Nang'
            }, {
                code: 'VM88',
                name: 'Dac Lac'
            }, {
                code: 'VM91',
                name: 'Dac Nong'
            }, {
                code: 'VM92',
                name: 'Dien Bien'
            }, {
                code: 'VM43',
                name: 'Dong Nai'
            }, {
                code: 'VM09',
                name: 'Dong Thap'
            }, {
                code: 'VM49',
                name: 'Gia Lai'
            }, {
                code: 'VM50',
                name: 'Ha Giang'
            }, {
                code: 'VM80',
                name: 'Ha Nam'
            }, {
                code: 'VM52',
                name: 'Ha Tinh'
            }, {
                code: 'VM79',
                name: 'Hai Duong'
            }, {
                code: 'VM13',
                name: 'Haiphong'
            }, {
                code: 'VM44',
                name: 'Hanoi'
            }, {
                code: 'VM93',
                name: 'Hau Giang'
            }, {
                code: 'VM20',
                name: 'Ho Chi Minh'
            }, {
                code: 'VM53',
                name: 'Hoa Binh'
            }, {
                code: 'VM81',
                name: 'Hung Yen'
            }, {
                code: 'VM54',
                name: 'Khanh Hoa'
            }, {
                code: 'VM21',
                name: 'Kien Giang'
            }, {
                code: 'VM55',
                name: 'Kon Tum'
            }, {
                code: 'VM89',
                name: 'Lai Chau'
            }, {
                code: 'VM23',
                name: 'Lam Dong'
            }, {
                code: 'VM39',
                name: 'Lang Son'
            }, {
                code: 'VM90',
                name: 'Lao Cai'
            }, {
                code: 'VM24',
                name: 'Long An'
            }, {
                code: 'VM82',
                name: 'Nam Dinh'
            }, {
                code: 'VM58',
                name: 'Nghe An'
            }, {
                code: 'VM59',
                name: 'Ninh Binh'
            }, {
                code: 'VM60',
                name: 'Ninh Thuan'
            }, {
                code: 'VM83',
                name: 'Phu Tho'
            }, {
                code: 'VM61',
                name: 'Phu Yen'
            }, {
                code: 'VM62',
                name: 'Quang Binh'
            }, {
                code: 'VM84',
                name: 'Quang Nam'
            }, {
                code: 'VM63',
                name: 'Quang Ngai'
            }, {
                code: 'VM30',
                name: 'Quang Ninh'
            }, {
                code: 'VM64',
                name: 'Quang Tri'
            }, {
                code: 'VM65',
                name: 'Soc Trang'
            }, {
                code: 'VM32',
                name: 'Son La'
            }, {
                code: 'VM33',
                name: 'Tay Ninh'
            }, {
                code: 'VM35',
                name: 'Thai Binh'
            }, {
                code: 'VM85',
                name: 'Thai Nguyen'
            }, {
                code: 'VM34',
                name: 'Thanh Hoa'
            }, {
                code: 'VM66',
                name: 'Thua Thien-Hue'
            }, {
                code: 'VM37',
                name: 'Tien Giang'
            }, {
                code: 'VM67',
                name: 'Tra Vinh'
            }, {
                code: 'VM68',
                name: 'Tuyen Quang'
            }, {
                code: 'VM69',
                name: 'Vinh Long'
            }, {
                code: 'VM86',
                name: 'Vinh Phuc'
            }, {
                code: 'VM70',
                name: 'Yen Bai'
            }]
    }, {
        code: 'YU',
        id: 2367,
        name: 'Macedonia; the Former Yugoslav Republic',
        states: []
    }, {
        code: 'ZR',
        id: 2368,
        name: 'Congo; Democratic Republic of',
        states: []
    }, {
        code: 'ZM',
        id: 2369,
        name: 'Zambia',
        states: [{
                code: 'ZA02',
                name: 'Central'
            }, {
                code: 'ZA08',
                name: 'Copperbelt'
            }, {
                code: 'ZA03',
                name: 'Eastern'
            }, {
                code: 'ZA04',
                name: 'Luapula'
            }, {
                code: 'ZA09',
                name: 'Lusaka'
            }, {
                code: 'ZA10',
                name: 'Muchinga'
            }, {
                code: 'ZA06',
                name: 'North-Western'
            }, {
                code: 'ZA05',
                name: 'Northern'
            }, {
                code: 'ZA07',
                name: 'Southern'
            }, {
                code: 'ZA01',
                name: 'Western'
            }]
    }, {
        code: 'ZW',
        id: 2370,
        name: 'Zimbabwe',
        states: []
    }, {
        code: 'GT',
        id: 2371,
        name: 'Guatemala',
        states: []
    }, {
        code: 'BU',
        id: 2372,
        name: 'Bermuda',
        states: [{
                code: 'BD01',
                name: 'Devonshire'
            }, {
                code: 'BD02',
                name: 'Hamilton'
            }, {
                code: 'BD03',
                name: 'Hamilton municipality'
            }, {
                code: 'BD04',
                name: 'Paget'
            }, {
                code: 'BD05',
                name: 'Pembroke'
            }, {
                code: 'BD06',
                name: 'Saint George municipality'
            }, {
                code: 'BD07',
                name: 'Saint George\'s'
            }, {
                code: 'BD08',
                name: 'Sandys'
            }, {
                code: 'BD09',
                name: 'Smiths'
            }, {
                code: 'BD10',
                name: 'Southampton'
            }, {
                code: 'BD11',
                name: 'Warwick'
            }]
    }, {
        code: 'AB',
        id: 2373,
        name: 'Aruba',
        states: []
    }, {
        code: 'PR',
        id: 2374,
        name: 'Puerto Rico',
        states: []
    }, {
        code: 'TW',
        id: 2375,
        name: 'Taiwan',
        states: [{
                code: 'TW02',
                name: 'Kaohsiung'
            }, {
                code: 'TW03',
                name: 'Taipei'
            }]
    }, {
        code: 'GU',
        id: 2376,
        name: 'Guam',
        states: []
    }, {
        code: 'HK',
        id: 2377,
        name: 'Hong Kong',
        states: [{
                code: 'HK001',
                name: 'Hong Kong Island'
            }, {
                code: 'HK002',
                name: 'Kowloon'
            }, {
                code: 'HK003',
                name: 'New Territories'
            }]
    }, {
        code: 'NONE',
        id: 2378,
        name: '- None Specified -',
        states: []
    }, {
        code: 'KY',
        id: 2379,
        name: 'Cayman Islands',
        states: [{
                code: 'KY.BT',
                name: 'Bodden Town'
            }, {
                code: 'KY.EE',
                name: 'East End'
            }, {
                code: 'KY.GT',
                name: 'George Town'
            }, {
                code: 'KY.NS',
                name: 'North Side'
            }, {
                code: 'KY.SI',
                name: 'Sister Islands'
            }, {
                code: 'KY.WB',
                name: 'West Bay'
            }]
    }, {
        code: 'LY',
        id: 2380,
        name: 'Libyan Arab Jamahiriya',
        states: []
    }, {
        code: 'SY',
        id: 2381,
        name: 'Syrian Arab Republic',
        states: [{
                code: 'SY01',
                name: 'Al Hasakah'
            }, {
                code: 'SY09',
                name: 'Aleppo'
            }, {
                code: 'SY04',
                name: 'Ar Raqqah'
            }, {
                code: 'SY05',
                name: 'As Suwayda\''
            }, {
                code: 'SY13',
                name: 'Damascus'
            }, {
                code: 'SY06',
                name: 'Dar`a'
            }, {
                code: 'SY07',
                name: 'Dayr az Zawr'
            }, {
                code: 'SY10',
                name: 'Hama'
            }, {
                code: 'SY11',
                name: 'Hims'
            }, {
                code: 'SY12',
                name: 'Idlib'
            }, {
                code: 'SY02',
                name: 'Latakia'
            }, {
                code: 'SY03',
                name: 'Quneitra'
            }, {
                code: 'SY08',
                name: 'Rif Dimashq'
            }, {
                code: 'SY14',
                name: 'Tartus'
            }]
    }, {
        code: 'YE',
        id: 2382,
        name: 'Yemen',
        states: []
    }, {
        code: 'CG',
        id: 2383,
        name: 'Congo; Republic of',
        states: []
    }, {
        code: 'MV',
        id: 2384,
        name: 'Maldives; Republic of',
        states: []
    }, {
        code: 'BM',
        id: 2385,
        name: 'Burma',
        states: []
    }, {
        code: 'CH99',
        id: 2386,
        name: 'Channel Islands',
        states: []
    }, {
        code: 'C999',
        id: 2387,
        name: 'Curacao',
        states: []
    }, {
        code: 'FI99',
        id: 2388,
        name: 'Faroe Islands',
        states: []
    }, {
        code: 'GM',
        id: 2389,
        name: 'Gambia',
        states: []
    }, {
        code: 'G999',
        id: 2390,
        name: 'Gibraltar',
        states: [{
                code: 'GI.GI',
                name: 'Gibraltar'
            }]
    }, {
        code: 'KI',
        id: 2391,
        name: 'Kiribati',
        states: []
    }, {
        code: 'KV',
        id: 2392,
        name: 'Kosovo',
        states: []
    }, {
        code: 'M999',
        id: 2393,
        name: 'Mayotte',
        states: []
    }, {
        code: 'RM',
        id: 2394,
        name: 'Marshall Islands',
        states: []
    }, {
        code: 'MD',
        id: 2395,
        name: 'Moldova; Republic of',
        states: []
    }, {
        code: 'MJ',
        id: 2396,
        name: 'Montenegro',
        states: [{
                code: 'ME-1',
                name: 'Andrijevica'
            }, {
                code: 'ME-2',
                name: 'Bar'
            }, {
                code: 'ME-3',
                name: 'Berane'
            }, {
                code: 'ME-4',
                name: 'Bijelo Polje'
            }, {
                code: 'ME-5',
                name: 'Budva'
            }, {
                code: 'ME-6',
                name: 'Cetinje'
            }, {
                code: 'ME-7',
                name: 'Danilovgrad'
            }, {
                code: 'ME-8',
                name: 'Herceg Novi'
            }, {
                code: 'ME-9',
                name: 'Kolain'
            }, {
                code: 'ME-10',
                name: 'Kotor'
            }, {
                code: 'ME-11',
                name: 'Mojkovac'
            }, {
                code: 'ME-12',
                name: 'Nikic'
            }, {
                code: 'ME-13',
                name: 'Plav'
            }, {
                code: 'ME-14',
                name: 'Pljevlja'
            }, {
                code: 'ME-15',
                name: 'Pluine'
            }, {
                code: 'ME-16',
                name: 'Podgorica'
            }, {
                code: 'ME-17',
                name: 'Roaje'
            }, {
                code: 'ME-19',
                name: 'Tivat'
            }, {
                code: 'ME-20',
                name: 'Ulcinj'
            }, {
                code: 'ME-18',
                name: 'avnik'
            }, {
                code: 'ME-21',
                name: 'abljak'
            }]
    }, {
        code: 'NR',
        id: 2397,
        name: 'Nauru',
        states: []
    }, {
        code: 'R999',
        id: 2398,
        name: 'Reunion',
        states: []
    }, {
        code: 'KN',
        id: 2399,
        name: 'Saint Kitts and Nevis',
        states: []
    }, {
        code: 'VC',
        id: 2400,
        name: 'Saint Vincent and Grenadines',
        states: []
    }, {
        code: 'WS',
        id: 2401,
        name: 'Samoa',
        states: [{
                code: 'WS01',
                name: 'A\'ana'
            }, {
                code: 'WS02',
                name: 'Aiga-i-le-Tai'
            }, {
                code: 'WS03',
                name: 'Atua'
            }, {
                code: 'WS04',
                name: 'Fa\'asaleleaga'
            }, {
                code: 'WS05',
                name: 'Gaga\'emauga'
            }, {
                code: 'WS07',
                name: 'Gagaifomauga'
            }, {
                code: 'WS08',
                name: 'Palauli'
            }, {
                code: 'WS09',
                name: 'Satupa\'itea'
            }, {
                code: 'WS10',
                name: 'Tuamasaga'
            }, {
                code: 'WS06',
                name: 'Va\'a-o-Fonoti'
            }, {
                code: 'WS11',
                name: 'Vaisigano'
            }]
    }, {
        code: 'RI',
        id: 2402,
        name: 'Serbia',
        states: [{
                code: 'RS-00',
                name: 'Belgrade'
            }, {
                code: 'RS-14',
                name: 'Borski okrug'
            }, {
                code: 'RS-11',
                name: 'Branicevski okrug'
            }, {
                code: 'RS-23',
                name: 'Jablanicki okrug'
            }, {
                code: 'RS-04',
                name: 'Junobanatski okrug'
            }, {
                code: 'RS-06',
                name: 'Junobanatski okrug'
            }, {
                code: 'RS-09',
                name: 'Kolubarski okrug'
            }, {
                code: 'RS-25',
                name: 'Kosovski okrug'
            }, {
                code: 'RS-28',
                name: 'Kosovsko-Mitrovacki okrug'
            }, {
                code: 'RS-29',
                name: 'Kosovsko-Pomoravski okrug'
            }, {
                code: 'RS-08',
                name: 'Macvanski okrug'
            }, {
                code: 'RS-17',
                name: 'Moravicki okrug'
            }, {
                code: 'RS-20',
                name: 'Niavski okrug'
            }, {
                code: 'RS-24',
                name: 'Pcinjski okrug'
            }, {
                code: 'RS-26',
                name: 'Pecki okrug'
            }, {
                code: 'RS-22',
                name: 'Pirotski okrug'
            }, {
                code: 'RS-10',
                name: 'Podunavski okrug'
            }, {
                code: 'RS-13',
                name: 'Pomoravski okrug'
            }, {
                code: 'RS-27',
                name: 'Prizrenski okrug'
            }, {
                code: 'RS-19',
                name: 'Rasinski okrug'
            }, {
                code: 'RS-18',
                name: 'Raka okrug'
            }, {
                code: 'RS-01',
                name: 'Severnobacki okrug'
            }, {
                code: 'RS-03',
                name: 'Severnobanatski okrug'
            }, {
                code: 'RS-02',
                name: 'Srednjebanatski okrug'
            }, {
                code: 'RS-07',
                name: 'Sremski okrug'
            }, {
                code: 'RS-21',
                name: 'Topliki okrug'
            }, {
                code: 'RS-15',
                name: 'Zajearski okrug'
            }, {
                code: 'RS-05',
                name: 'Zapadnobaki okrug'
            }, {
                code: 'RS-16',
                name: 'Zlatiborski okrug'
            }, {
                code: 'RS-12',
                name: 'umadijski okrug'
            }]
    }, {
        code: 'TP',
        id: 2403,
        name: 'Sao Tome and Principe',
        states: []
    }, {
        code: 'TL',
        id: 2404,
        name: 'Timor-Leste',
        states: []
    }, {
        code: 'TO',
        id: 2405,
        name: 'Tonga',
        states: []
    }, {
        code: 'NH',
        id: 2406,
        name: 'Vanuatu',
        states: []
    }, {
        code: 'AX',
        id: 2407,
        name: 'land Islands',
        states: []
    }, {
        code: 'AS',
        id: 2408,
        name: 'American Samoa',
        states: []
    }, {
        code: 'AI',
        id: 2409,
        name: 'Anguilla',
        states: []
    }, {
        code: 'BV',
        id: 2410,
        name: 'Bouvet Island',
        states: []
    }, {
        code: 'IO',
        id: 2411,
        name: 'British Indian Ocean Territory',
        states: []
    }, {
        code: 'CX',
        id: 2412,
        name: 'Christmas Island',
        states: []
    }, {
        code: 'CC',
        id: 2413,
        name: 'Cocos (Keeling) Islands',
        states: []
    }, {
        code: 'CK',
        id: 2414,
        name: 'Cook Islands',
        states: []
    }, {
        code: 'FK',
        id: 2415,
        name: 'Falkland Islands (Malvinas)',
        states: []
    }, {
        code: 'GF',
        id: 2416,
        name: 'French Guiana',
        states: []
    }, {
        code: 'PF',
        id: 2417,
        name: 'French Polynesia',
        states: []
    }, {
        code: 'TF',
        id: 2418,
        name: 'French Southern Territories',
        states: []
    }, {
        code: 'GP',
        id: 2419,
        name: 'Guadeloupe',
        states: []
    }, {
        code: 'GG',
        id: 2420,
        name: 'Guernsey',
        states: []
    }, {
        code: 'HM',
        id: 2421,
        name: 'Heard and McDonald Islands',
        states: []
    }, {
        code: 'JE',
        id: 2422,
        name: 'Jersey',
        states: []
    }, {
        code: 'MQ',
        id: 2423,
        name: 'Martinique',
        states: []
    }, {
        code: 'MS',
        id: 2424,
        name: 'Montserrat',
        states: []
    }, {
        code: 'AN',
        id: 2425,
        name: 'Netherlands Antilles',
        states: []
    }, {
        code: 'NC',
        id: 2426,
        name: 'New Caledonia',
        states: []
    }, {
        code: 'NU',
        id: 2427,
        name: 'Niue',
        states: []
    }, {
        code: 'NF',
        id: 2428,
        name: 'Norfolk Island',
        states: []
    }, {
        code: 'MP',
        id: 2429,
        name: 'Northern Mariana Islands',
        states: []
    }, {
        code: 'PS',
        id: 2430,
        name: 'Palestinian Territory; Occupied',
        states: []
    }, {
        code: 'PN',
        id: 2431,
        name: 'Pitcairn',
        states: []
    }, {
        code: 'BL',
        id: 2432,
        name: 'Saint Barthlemy',
        states: []
    }, {
        code: 'SH',
        id: 2433,
        name: 'Saint Helena; Ascension and Tristan Da Cunha',
        states: []
    }, {
        code: 'MF',
        id: 2434,
        name: 'Saint Martin',
        states: []
    }, {
        code: 'PM',
        id: 2435,
        name: 'Saint Pierre And Miquelon',
        states: []
    }, {
        code: 'GS',
        id: 2436,
        name: 'South Georgia and the South Sandwich Islands',
        states: []
    }, {
        code: 'SJ',
        id: 2437,
        name: 'Svalbard And Jan Mayen',
        states: []
    }, {
        code: 'TK',
        id: 2438,
        name: 'Tokelau',
        states: []
    }, {
        code: 'TC',
        id: 2439,
        name: 'Turks and Caicos Islands',
        states: []
    }, {
        code: 'TV',
        id: 2440,
        name: 'Tuvalu',
        states: []
    }, {
        code: 'UM',
        id: 2441,
        name: 'United States Minor Outlying Islands',
        states: []
    }, {
        code: 'VI',
        id: 2442,
        name: 'Virgin Islands; U.S.',
        states: [{
                code: '010',
                name: 'Saint Croix'
            }, {
                code: '020',
                name: 'Saint John'
            }, {
                code: '030',
                name: 'Saint Thomas'
            }]
    }, {
        code: 'WF',
        id: 2443,
        name: 'Wallis and Futuna',
        states: []
    }, {
        code: 'EH',
        id: 2444,
        name: 'Western Sahara',
        states: []
    }, {
        code: 'IM',
        id: 2445,
        name: 'Isle of Man',
        states: []
    }, {
        code: 'VG',
        id: 2446,
        name: 'Virgin Islands; British',
        states: []
    }, {
        code: 'SS',
        id: 2447,
        name: 'South Sudan',
        states: [{
                code: 'OD01',
                name: 'Central Equatoria'
            }, {
                code: 'OD02',
                name: 'East Equatoria'
            }, {
                code: 'OD03',
                name: 'Jungoli'
            }, {
                code: 'OD04',
                name: 'Lakes'
            }, {
                code: 'OD05',
                name: 'North Bahr-al-Ghazal'
            }, {
                code: 'OD06',
                name: 'Unity'
            }, {
                code: 'OD07',
                name: 'Upper Nile'
            }, {
                code: 'OD08',
                name: 'Warap'
            }, {
                code: 'OD09',
                name: 'West Bahr-al-Ghazal'
            }, {
                code: 'OD10',
                name: 'West Equatoria'
            }]
    }];
/**
 * @return {?}
 */
function getCountries() {
    return COUNTRIES.map(country => country.name);
}
/**
 * @param {?} id
 * @return {?}
 */
function findByCountryId(id) {
    return COUNTRIES.find(country => country.id === id);
}
/**
 * @param {?} name
 * @return {?}
 */
function findByCountryName(name) {
    return COUNTRIES.find(country => country.name === name.trim());
}
/**
 * @param {?} code
 * @return {?}
 */
function findByCountryCode(code) {
    return COUNTRIES.find(country => country.code === code.trim());
}
/**
 * @param {?} name
 * @return {?}
 */
function getStateObjects(name) {
    const /** @type {?} */ foundCountry = COUNTRIES.find(country => country.name === name.trim());
    return foundCountry && foundCountry.states || [];
}
/**
 * @param {?} name
 * @return {?}
 */
function getStates(name) {
    return getStateObjects(name).map(state$$1 => state$$1.name);
}

// NG2
// APP
// Value accessor for the component (supports ngModel)
const ADDRESS_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => NovoAddressElement),
    multi: true
};
class NovoAddressElement {
    /**
     * @param {?} labels
     */
    constructor(labels) {
        this.labels = labels;
        this.states = [];
        this.countries = getCountries();
        this.onModelChange = () => {
        };
        this.onModelTouched = () => {
        };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.model) {
            this.writeValue(this.model);
            this.updateControl();
        }
        else if (!this.model) {
            this.model = {};
        }
    }
    /**
     * @param {?} evt
     * @return {?}
     */
    onCountryChange(evt) {
        let /** @type {?} */ country = findByCountryName(evt);
        if (country) {
            this.model.countryName = country.name;
            this.model.countryCode = country.code;
            this.model.countryID = country.id;
            this.updateStates();
        }
        // Update state
        this.model.state = undefined;
        this.updateControl();
    }
    /**
     * @param {?} evt
     * @return {?}
     */
    onStateChange(evt) {
        this.model.state = evt;
        this.updateControl();
    }
    /**
     * @return {?}
     */
    updateStates() {
        if (this.model.countryName) {
            this.states = getStates(this.model.countryName);
        }
        else {
            this.states = [];
        }
    }
    /**
     * @return {?}
     */
    updateControl() {
        this.onModelChange(this.model);
    }
    /**
     * @param {?} model
     * @return {?}
     */
    writeValue(model) {
        if (model) {
            let /** @type {?} */ countryName;
            if (model.countryName) {
                countryName = model.countryName;
            }
            else if (model.countryID) {
                let /** @type {?} */ country = findByCountryId(model.countryID);
                if (country) {
                    countryName = country.name;
                }
                
            }
            if (countryName) {
                countryName = countryName.trim();
                model.state = model.state || '';
                let /** @type {?} */ stateObj = getStateObjects(countryName).find(state$$1 => {
                    return state$$1.code === model.state.replace(/\W+/g, '').toUpperCase() || state$$1.name === model.state;
                }) || {};
                this.model = Object.assign(model, { countryName: countryName, state: stateObj.name });
                this.updateStates();
            }
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onModelChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onModelTouched = fn;
    }
}
NovoAddressElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-address',
                providers: [ADDRESS_VALUE_ACCESSOR],
                template: `
        <input type="text" class="street-address" id="address1" name="address1" placeholder="{{ labels.address }}" [(ngModel)]="model.address1" (ngModelChange)="updateControl()"/>
        <input type="text" class="apt suite" id="address2" name="address2" placeholder="{{ labels.apt }}" [(ngModel)]="model.address2" (ngModelChange)="updateControl()"/>
        <input type="text" class="city locality" id="city" name="city" placeholder="{{ labels.city }}" [(ngModel)]="model.city" (ngModelChange)="updateControl()"/>
        <novo-select class="state region" id="state" [options]="states" placeholder="{{ labels.state }}" [(ngModel)]="model.state" (ngModelChange)="onStateChange($event)"></novo-select>
        <input type="text" class="zip postal-code" id="zip" name="zip" placeholder="{{ labels.zipCode }}" [(ngModel)]="model.zip" (ngModelChange)="updateControl()"/>
        <novo-select class="country-name" id="country" [options]="countries" placeholder="{{ labels.country }}" [(ngModel)]="model.countryName" (ngModelChange)="onCountryChange($event)"></novo-select>
    `
            },] },
];
/**
 * @nocollapse
 */
NovoAddressElement.ctorParameters = () => [
    { type: NovoLabelService, },
];

// NG2
// APP
// Value accessor for the component (supports ngModel)
const CHECKBOX_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => NovoCheckboxElement),
    multi: true
};
const LAYOUT_DEFAULTS = { iconStyle: 'box' };
class NovoCheckboxElement {
    /**
     * @param {?} ref
     */
    constructor(ref) {
        this.ref = ref;
        this.indeterminate = false;
        this.boxIcon = true;
        this.onModelChange = () => {
        };
        this.onModelTouched = () => {
        };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.layoutOptions = Object.assign({}, LAYOUT_DEFAULTS, this.layoutOptions);
        this.boxIcon = this.layoutOptions.iconStyle === 'box';
    }
    /**
     * @param {?} event
     * @return {?}
     */
    select(event) {
        Helpers.swallowEvent(event);
        this.model = !this.model;
        this.onModelChange(this.model);
    }
    /**
     * @param {?} model
     * @return {?}
     */
    writeValue(model) {
        this.model = model;
        this.ref.markForCheck();
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onModelChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onModelTouched = fn;
    }
}
NovoCheckboxElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-checkbox',
                providers: [CHECKBOX_VALUE_ACCESSOR],
                template: `
        <div class="check-box-group" [class.checked]="model" [class.disabled]="disabled">
            <input [name]="name" type="checkbox" [(ngModel)]="model" [attr.id]="name">
            <label [attr.for]="name" (click)="select($event)">
              <i [class.bhi-checkbox-empty]="!model && !indeterminate && boxIcon"
                 [class.bhi-checkbox-filled]="model && !indeterminate && boxIcon"
                 [class.bhi-checkbox-indeterminate]="indeterminate && boxIcon"
                 [class.bhi-circle-o]="!model && !indeterminate && !boxIcon"
                 [class.bhi-check]="model && !indeterminate && !boxIcon"
                 [class.bhi-circle]="indeterminate && !boxIcon"></i>
              <span *ngIf="label">{{ label }}</span>
            </label>
        </div>
    `,
                changeDetection: ChangeDetectionStrategy.OnPush
            },] },
];
/**
 * @nocollapse
 */
NovoCheckboxElement.ctorParameters = () => [
    { type: ChangeDetectorRef, },
];
NovoCheckboxElement.propDecorators = {
    'name': [{ type: Input },],
    'label': [{ type: Input },],
    'indeterminate': [{ type: Input },],
    'disabled': [{ type: Input },],
    'layoutOptions': [{ type: Input },],
};

// NG2
// APP
// Value accessor for the component (supports ngModel)
const CHECKLIST_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => NovoCheckListElement),
    multi: true
};
class NovoCheckListElement {
    constructor() {
        this.onSelect = new EventEmitter();
        this.onModelChange = () => {
        };
        this.onModelTouched = () => {
        };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.setModel();
        this.setupOptions();
    }
    /**
     * @param {?} event
     * @param {?} item
     * @return {?}
     */
    select(event, item) {
        Helpers.swallowEvent(event);
        item.checked = !item.checked;
        this.model = this._options.filter(checkBox => checkBox.checked).map(x => x.value);
        this.onModelChange(this.model.length > 0 ? this.model : '');
        this.onSelect.emit({ selected: this.model });
    }
    /**
     * @return {?}
     */
    setupOptions() {
        this.options = this.options || [];
        this._options = [];
        if (this.options.length && !this.options[0].value) {
            this.options.forEach(option => {
                let /** @type {?} */ formattedOption = {
                    value: option,
                    label: option,
                    checked: (this.model && this.model.length && (this.model.indexOf(option.value) !== -1))
                };
                this._options.push(formattedOption);
            });
        }
        else {
            this.options.forEach(option => {
                let /** @type {?} */ formattedOption = option;
                formattedOption.checked = (this.model && this.model.length && (this.model.indexOf(option.value) !== -1));
                this._options.push(formattedOption);
            });
        }
    }
    /**
     * @return {?}
     */
    setModel() {
        let /** @type {?} */ checkedOptions = this.options.filter(checkBox => checkBox.checked).map(x => x.value);
        this.writeValue(checkedOptions);
    }
    /**
     * @param {?} model
     * @return {?}
     */
    writeValue(model) {
        this.model = model || [];
        if (model) {
            this.setupOptions();
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onModelChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onModelTouched = fn;
    }
}
NovoCheckListElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-check-list',
                providers: [CHECKLIST_VALUE_ACCESSOR],
                template: `
        <div class="check-box-group" *ngFor="let option of _options; let i = index" [ngClass]="{checked: option.checked}" >
            <input [name]="name" type="checkbox" [ngModel]="option.checked" [attr.id]="name+i" [value]="option.checked" (change)="select($event, option)">
            <label [attr.for]="name+i" (click)="select($event, option)">
              <i [ngClass]="{'bhi-checkbox-empty': !option.checked, 'bhi-checkbox-filled': option.checked }"></i>
              <span>{{option.label}}</span>
            </label>
        </div>
    `
            },] },
];
/**
 * @nocollapse
 */
NovoCheckListElement.ctorParameters = () => [];
NovoCheckListElement.propDecorators = {
    'name': [{ type: Input },],
    'options': [{ type: Input },],
    'onSelect': [{ type: Output },],
};

class NovoFile {
    /**
     * @param {?} file
     */
    constructor(file) {
        this.name = '';
        this.contentType = '';
        this.lastModified = 0;
        this.size = 0;
        this.loaded = false;
        this.reader = new FileReader();
        this.name = `${encodeURIComponent(file.name || '')}`;
        this.contentType = file.type;
        this.lastModified = file.lastModified;
        this.size = file.size;
        this.file = file;
        this.reader.onload = (event) => {
            this.fileContents = event.target.result.split(',')[1];
            this.dataURL = event.target.result;
            this.loaded = true;
        };
    }
    /**
     * @return {?}
     */
    read() {
        return new Promise((resolve) => {
            resolve(this);
            // when the file is read it triggers the onload event above.
            this.reader.readAsDataURL(this.file);
        });
    }
    /**
     * @return {?}
     */
    toJSON() {
        return {
            name: this.name,
            contentType: this.type,
            lastModified: this.lastModified,
            size: this.size,
            fileContents: this.fileContents
        };
    }
}

// NG2
// APP
// Value accessor for the component (supports ngModel)
const FILE_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => NovoFileInputElement),
    multi: true
};
const LAYOUT_DEFAULTS$1 = { order: 'default', download: true, labelStyle: 'default', draggable: false };
class NovoFileInputElement {
    /**
     * @param {?} element
     * @param {?} labels
     * @param {?} dragula
     */
    constructor(element, labels, dragula) {
        this.element = element;
        this.labels = labels;
        this.dragula = dragula;
        this.multiple = false;
        this.disabled = false;
        this.value = [];
        this.elements = [];
        this.files = [];
        this.active = false;
        this.onModelChange = () => {
        };
        this.onModelTouched = () => {
        };
        this.commands = {
            dragenter: this.dragEnterHandler.bind(this),
            dragleave: this.dragLeaveHandler.bind(this),
            dragover: this.dragOverHandler.bind(this),
            drop: this.dropHandler.bind(this)
        };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        ['dragenter', 'dragleave', 'dragover', 'drop'].forEach(type => {
            this.element.nativeElement.addEventListener(type, this.commands[type]);
        });
        this.updateLayout();
        this.initializeDragula();
        this.setInitialFileList();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        ['dragenter', 'dragleave', 'dragover', 'drop'].forEach(type => {
            this.element.nativeElement.removeEventListener(type, this.commands[type]);
        });
        let /** @type {?} */ dragulaHasFileOutputBag = this.dragula.bags.length > 0 && this.dragula.bags.filter(x => x.name === this.fileOutputBag).length > 0;
        if (dragulaHasFileOutputBag) {
            this.dragula.destroy(this.fileOutputBag);
        }
    }
    /**
     * @param {?=} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this.onModelChange(this.model);
    }
    /**
     * @return {?}
     */
    updateLayout() {
        this.layoutOptions = Object.assign({}, LAYOUT_DEFAULTS$1, this.layoutOptions);
        this.insertTemplatesBasedOnLayout();
    }
    /**
     * @return {?}
     */
    insertTemplatesBasedOnLayout() {
        let /** @type {?} */ order;
        switch (this.layoutOptions['order']) {
            case 'displayFilesBelow':
                order = ['fileInput', 'fileOutput'];
                break;
            default:
                order = ['fileOutput', 'fileInput'];
        }
        order.forEach((template) => {
            this.container.createEmbeddedView(this[template], 0);
        });
        return order;
    }
    /**
     * @return {?}
     */
    initializeDragula() {
        this.fileOutputBag = `file-output-${this.dragula.bags.length}`;
        this.dragula.setOptions(this.fileOutputBag, {
            moves: (el, container, handle) => {
                return this.layoutOptions.draggable;
            }
        });
    }
    /**
     * @return {?}
     */
    setInitialFileList() {
        if (this.value) {
            this.files = this.value;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    dragEnterHandler(event) {
        event.preventDefault();
        event.dataTransfer.dropEffect = 'copy';
        this.target = event.target;
        this.active = true;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    dragLeaveHandler(event) {
        event.preventDefault();
        if (this.target === event.target) {
            this.active = false;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    dragOverHandler(event) {
        event.preventDefault();
        // no-op
    }
    /**
     * @param {?} event
     * @return {?}
     */
    dropHandler(event) {
        event.preventDefault();
        this.visible = false;
        if (event.dataTransfer.types[0] !== 'Files') {
            return;
        }
        let /** @type {?} */ filelist = Array.from(event.dataTransfer.files);
        this.process(this.multiple ? filelist : [filelist[0]]);
        this.active = false;
    }
    /**
     * @param {?} model
     * @return {?}
     */
    writeValue(model) {
        this.model = model;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onModelChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onModelTouched = fn;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    check(event) {
        this.process(Array.from(event.target.files));
    }
    /**
     * @param {?} filelist
     * @return {?}
     */
    process(filelist) {
        Promise.all(filelist.map((file) => this.readFile(file))).then((files) => {
            if (this.multiple) {
                this.files.push(...files);
            }
            else {
                this.files = files;
            }
            this.model = this.files;
            this.onModelChange(this.model);
        });
    }
    /**
     * @param {?} file
     * @return {?}
     */
    download(file) {
        window.open(file.dataURL, '_blank');
    }
    /**
     * @param {?} file
     * @return {?}
     */
    remove(file) {
        this.files.splice(this.files.findIndex(f => (f.name === file.name && f.size === file.size)), 1);
        this.model = this.files;
        this.onModelChange(this.model);
    }
    /**
     * @param {?} file
     * @return {?}
     */
    readFile(file) {
        return new NovoFile(file).read();
    }
}
NovoFileInputElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-file-input',
                providers: [FILE_VALUE_ACCESSOR],
                template: `
        <div #container></div>
        <ng-template #fileInput>
            <div class="file-input-group" [class.disabled]="disabled" [class.active]="active">
                <input type="file" [name]="name" [attr.id]="name" (change)="check($event)" [attr.multiple]="multiple" tabindex="-1"/>
                <section [ngSwitch]="layoutOptions.labelStyle">
                    <label *ngSwitchCase="'no-box'" [attr.for]="name" class="no-box">
                        <div><i class="bhi-dropzone"></i>{{ placeholder || labels.chooseAFile }} {{ labels.or }} <strong class="link">{{ labels.clickToBrowse }}</strong></div>
                    </label>
                    <label *ngSwitchDefault [attr.for]="name" class="boxed">
                        <span>{{ placeholder || labels.chooseAFile }}</span>
                        <small>{{ labels.or }} <strong class="link">{{ labels.clickToBrowse }}</strong></small>
                    </label>
                </section>
            </div>
        </ng-template>
        <ng-template #fileOutput>
            <div class="file-output-group" [dragula]="fileOutputBag" [dragulaModel]="files">
                <div class="file-item" *ngFor="let file of files">
                    <i *ngIf="layoutOptions.draggable" class="bhi-move"></i>
                    <label>{{ file.name | decodeURI }}</label>
                    <div class="actions" [attr.data-automation-id]="'file-actions'" *ngIf="file.loaded">
                        <button *ngIf="layoutOptions.download" type="button" theme="icon" icon="save" (click)="download(file)" [attr.data-automation-id]="'file-download'" tabindex="-1"></button>
                        <button type="button" theme="icon" icon="close" (click)="remove(file)" [attr.data-automation-id]="'file-remove'" tabindex="-1"></button>
                    </div>
                    <novo-loading *ngIf="!file.loaded"></novo-loading>
                </div>
            </div>
        </ng-template>`
            },] },
];
/**
 * @nocollapse
 */
NovoFileInputElement.ctorParameters = () => [
    { type: ElementRef, },
    { type: NovoLabelService, },
    { type: NovoDragulaService, },
];
NovoFileInputElement.propDecorators = {
    'fileInput': [{ type: ViewChild, args: ['fileInput',] },],
    'fileOutput': [{ type: ViewChild, args: ['fileOutput',] },],
    'container': [{ type: ViewChild, args: ['container', { read: ViewContainerRef },] },],
    'name': [{ type: Input },],
    'multiple': [{ type: Input },],
    'disabled': [{ type: Input },],
    'placeholder': [{ type: Input },],
    'layoutOptions': [{ type: Input },],
    'value': [{ type: Input },],
};

// NG2
// APP
class NovoFormExtrasModule {
}
NovoFormExtrasModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, FormsModule, NovoPipesModule, NovoButtonModule, NovoSelectModule, NovoLoadingModule, NovoDragulaModule],
                declarations: [NovoAddressElement, NovoCheckboxElement, NovoCheckListElement, NovoFileInputElement],
                exports: [NovoAddressElement, NovoCheckboxElement, NovoCheckListElement, NovoFileInputElement]
            },] },
];
/**
 * @nocollapse
 */
NovoFormExtrasModule.ctorParameters = () => [];

class NovoControlGroup {
    /**
     * @param {?} formUtils
     * @param {?} fb
     * @param {?} ref
     * @param {?} labels
     */
    constructor(formUtils, fb, ref, labels) {
        this.formUtils = formUtils;
        this.fb = fb;
        this.ref = ref;
        this.labels = labels;
        this._vertical = false;
        this._remove = false;
        this._edit = false;
        this._collapsible = false;
        this.onRemove = new EventEmitter();
        this.onEdit = new EventEmitter();
        this.onAdd = new EventEmitter();
        this.controlLabels = [];
        this.toggled = false;
        this.disabledArray = [];
        this.currentIndex = 0;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set vertical(v) {
        this._vertical = coerceBooleanProperty(v);
    }
    /**
     * @return {?}
     */
    get vertical() {
        return this._vertical;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set remove(v) {
        this._remove = coerceBooleanProperty(v);
    }
    /**
     * @return {?}
     */
    get remove() {
        return this._remove;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set edit(v) {
        this._edit = coerceBooleanProperty(v);
    }
    /**
     * @return {?}
     */
    get edit() {
        return this._edit;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set collapsible(v) {
        this._collapsible = coerceBooleanProperty(v);
    }
    /**
     * @return {?}
     */
    get collapsible() {
        return this._collapsible;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set icon(v) {
        this._icon = v && v.indexOf('bhi') !== -1 ? v : `bhi-${v}`;
    }
    /**
     * @return {?}
     */
    get icon() {
        return this._icon;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (!this.key) {
            throw new Error('novo-control-group must have the [key] attribute provided!');
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        let /** @type {?} */ initialValueChange = changes['initialValue'];
        // If initial value changes, clear the controls
        if (initialValueChange && initialValueChange.currentValue !== initialValueChange.previousValue && !initialValueChange.firstChange) {
            this.clearControls();
        }
        // Check for array, add a control for each value
        if (this.initialValue && Array.isArray(this.initialValue)) {
            if (this.initialValue.length !== 0) {
                this.currentIndex = 0;
                this.initialValue.forEach(value => this.addNewControl(value));
            }
        }
        else if (this.initialValue) {
            // If value is an object, just add one control
            this.addNewControl(this.initialValue);
        }
        // If we are horizontal, grab the labels to help with layout
        if (!this.vertical) {
            this.controlLabels = (this.controls || []).map((control) => {
                return {
                    value: control.label,
                    width: control.width
                };
            });
            this.ref.markForCheck();
        }
    }
    /**
     * @param {?=} value
     * @return {?}
     */
    addNewControl(value) {
        const /** @type {?} */ control = (this.form.controls[this.key]);
        const /** @type {?} */ newCtrl = this.buildControl(value);
        if (control) {
            control.push(newCtrl);
        }
        else {
            this.form.addControl(this.key, this.fb.array([newCtrl]));
        }
        this.disabledArray.push({
            edit: this.checkCanEdit(this.currentIndex),
            remove: this.checkCanRemove(this.currentIndex),
        });
        if (!value) {
            this.onAdd.emit();
        }
        this.currentIndex++;
        this.ref.markForCheck();
    }
    /**
     * @param {?=} value
     * @return {?}
     */
    buildControl(value) {
        const /** @type {?} */ newControls = this.getNewControls(this.controls);
        if (value) {
            this.formUtils.setInitialValues(newControls, value);
        }
        const /** @type {?} */ ctrl = this.formUtils.toFormGroup(newControls);
        return ctrl;
    }
    /**
     * @param {?} index
     * @param {?=} emitEvent
     * @return {?}
     */
    removeControl(index, emitEvent = true) {
        const /** @type {?} */ control = (this.form.controls[this.key]);
        if (emitEvent) {
            this.onRemove.emit({ value: control.at(index).value, index: index });
        }
        control.removeAt(index);
        this.ref.markForCheck();
    }
    /**
     * @param {?} index
     * @return {?}
     */
    editControl(index) {
        const /** @type {?} */ control = (this.form.controls[this.key]);
        this.onEdit.emit({ value: control.at(index).value, index: index });
    }
    /**
     * @param {?} event
     * @return {?}
     */
    toggle(event) {
        Helpers.swallowEvent(event);
        if (this.collapsible) {
            this.toggled = !this.toggled;
            this.ref.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    clearControls() {
        const /** @type {?} */ control = (this.form.controls[this.key]);
        if (control) {
            for (let /** @type {?} */ i = control.controls.length; i >= 0; i--) {
                this.removeControl(i, false);
            }
            this.currentIndex = 0;
        }
    }
    /**
     * @param {?} index
     * @return {?}
     */
    checkCanEdit(index) {
        if (this.canEdit) {
            const /** @type {?} */ control = (this.form.controls[this.key]);
            return this.canEdit(control.at(index).value, index);
        }
        return true;
    }
    /**
     * @param {?} index
     * @return {?}
     */
    checkCanRemove(index) {
        if (this.canRemove) {
            const /** @type {?} */ control = (this.form.controls[this.key]);
            return this.canRemove(control.at(index).value, index);
        }
        return true;
    }
    /**
     * @param {?} controls
     * @return {?}
     */
    getNewControls(controls) {
        let /** @type {?} */ ret = [];
        (this.controls || []).forEach((control) => {
            ret.push(new BaseControl(control.__type, control));
        });
        return ret;
    }
}
NovoControlGroup.decorators = [
    { type: Component, args: [{
                selector: 'novo-control-group',
                template: `
        <h6 class="novo-section-header" *ngIf="label">
            <span (click)="toggle($event)" [class.clickable]="collapsible">
                <i *ngIf="icon && !collapsible" [ngClass]="icon" [attr.data-automation-id]="'novo-control-group-icon-' + key"></i>
                <i *ngIf="collapsible" class="bhi-next" [class.toggled]="toggled" [attr.data-automation-id]="'novo-control-group-collapse-' + key"></i>
                <span [attr.data-automation-id]="'novo-control-group-label-' + key">{{ label }}</span>
            </span>
            <label class="novo-control-group-description" *ngIf="description" [attr.data-automation-id]="'novo-control-group-description-' + key">{{ description }}</label>
        </h6>
        <div class="novo-control-group-controls" [class.vertical]="vertical" [class.horizontal]="!vertical" [class.hidden]="collapsible && !toggled">
            <ng-template #defaultTemplate let-index="index" let-form="form" let-key="key">
                <div class="novo-control-group-control">
                    <div *ngFor="let c of controls" class="novo-control-container" [class.is-label]="c.controlType === 'read-only'" [style.max-width.px]="c.width">
                        <novo-control [form]="form?.controls[key]['controls'][index]" [control]="c" [condensed]="!vertical || c.controlType === 'read-only'"></novo-control>
                    </div>
                    <div class="novo-control-container last" *ngIf="edit && !vertical">
                        <button [disabled]="!disabledArray[index].edit" type="button" *ngIf="edit && !vertical" theme="icon" icon="edit" (click)="editControl(index)" [attr.data-automation-id]="'novo-control-group-edit-' + key" index="-1"></button>
                    </div>
                    <div class="novo-control-container last" *ngIf="remove && !vertical">
                        <button [disabled]="!disabledArray[index].remove" type="button" *ngIf="remove && !vertical" theme="icon" icon="delete-o" (click)="removeControl(index)" [attr.data-automation-id]="'novo-control-group-delete-' + key" index="-1"></button>
                    </div>
                </div>
                <button [disabled]="!disabledArray[index].edit" type="button" *ngIf="edit && vertical" theme="icon" icon="edit" (click)="editControl(index)" [attr.data-automation-id]="'novo-control-group-edit-' + key" index="-1"></button>
                <button [disabled]="!disabledArray[index].remove" type="button" *ngIf="remove && vertical" theme="icon" icon="delete-o" (click)="removeControl(index)" [attr.data-automation-id]="'novo-control-group-delete-' + key" index="-1"></button>
            </ng-template>
            <div class="novo-control-group-labels" *ngIf="!vertical && form?.controls[key] && form?.controls[key]['controls'].length !== 0">
                <div class="novo-control-group-control-label" *ngFor="let label of controlLabels" [style.max-width.px]="label.width">
                    <span [attr.data-automation-id]="'novo-control-group-label-' + label.value">{{ label.value }}</span>
                </div>
                <div class="novo-control-group-control-label last" *ngIf="edit" [attr.data-automation-id]="'novo-control-group-edit-' + key"></div>
                <div class="novo-control-group-control-label last" *ngIf="remove" [attr.data-automation-id]="'novo-control-group-delete-' + key"></div>
            </div>
            <ng-container *ngIf="form?.controls[key]">
                <div class="novo-control-group-row" *ngFor="let control of form?.controls[key]['controls']; let index = index;">
                    <ng-template
                        [ngTemplateOutlet]="rowTemplate || defaultTemplate"
                        [ngTemplateOutletContext]="{form: form, index: index, key: key, controls: controls}">
                    </ng-template>
                </div>
            </ng-container>
            <div class="novo-control-group-empty" *ngIf="form?.controls[key] && form?.controls[key]['controls'].length === 0" [attr.data-automation-id]="'novo-control-group-empty-' + key">
                {{ emptyMessage }}
            </div>
            <p *ngIf="add">
                <button type="button" theme="dialogue" icon="add-thin" (click)="addNewControl()" [attr.data-automation-id]="'novo-control-group-bottom-add-' + key" index="-1">{{ add?.label }}</button>
            </p>
        </div>
   `,
                changeDetection: ChangeDetectionStrategy.OnPush
            },] },
];
/**
 * @nocollapse
 */
NovoControlGroup.ctorParameters = () => [
    { type: FormUtils, },
    { type: FormBuilder, },
    { type: ChangeDetectorRef, },
    { type: NovoLabelService, },
];
NovoControlGroup.propDecorators = {
    'vertical': [{ type: Input },],
    'add': [{ type: Input },],
    'remove': [{ type: Input },],
    'edit': [{ type: Input },],
    'collapsible': [{ type: Input },],
    'form': [{ type: Input },],
    'controls': [{ type: Input },],
    'key': [{ type: Input },],
    'label': [{ type: Input },],
    'description': [{ type: Input },],
    'emptyMessage': [{ type: Input },],
    'icon': [{ type: Input },],
    'initialValue': [{ type: Input },],
    'canEdit': [{ type: Input },],
    'canRemove': [{ type: Input },],
    'rowTemplate': [{ type: Input },],
    'onRemove': [{ type: Output },],
    'onEdit': [{ type: Output },],
    'onAdd': [{ type: Output },],
};

// NG2
// Vendor
// APP
class NovoFormModule {
}
NovoFormModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    ReactiveFormsModule,
                    NovoRadioModule,
                    NovoTilesModule,
                    NovoSelectModule,
                    NovoPickerModule,
                    NovoChipsModule,
                    NovoDatePickerModule,
                    NovoTimePickerModule,
                    NovoNovoCKEditorModule,
                    NovoFormExtrasModule,
                    NovoQuickNoteModule,
                    NovoDateTimePickerModule,
                    NovoHeaderModule,
                    NovoTooltipModule,
                    NovoDragulaModule,
                    TextMaskModule,
                    NovoTipWellModule,
                    NovoModalModule,
                    NovoButtonModule
                ],
                declarations: [
                    NovoAutoSize, NovoControlElement, NovoDynamicFormElement, NovoFormElement,
                    NovoFieldsetElement, NovoFieldsetHeaderElement, NovoControlCustom,
                    NovoCustomControlContainerElement, ControlConfirmModal, ControlPromptModal, NovoControlGroup
                ],
                exports: [
                    NovoAutoSize, NovoDynamicFormElement, NovoControlElement, NovoFormElement,
                    NovoFieldsetHeaderElement, NovoControlCustom, NovoCustomControlContainerElement,
                    NovoControlGroup
                ],
                entryComponents: [ControlConfirmModal, ControlPromptModal]
            },] },
];
/**
 * @nocollapse
 */
NovoFormModule.ctorParameters = () => [];

// NG2
// APP
class Pagination {
    /**
     * @param {?} labels
     */
    constructor(labels) {
        this.labels = labels;
        this.itemsPerPage = 10;
        this.pageChange = new EventEmitter();
        this.itemsPerPageChange = new EventEmitter();
        this.onPageChange = new EventEmitter();
        this.maxPagesDisplayed = 5;
    }
    /**
     * @return {?}
     */
    get disablePageSelection() { return this.pageSelectDisabled; }
    /**
     * @param {?} val
     * @return {?}
     */
    set disablePageSelection(val) {
        this.pageSelectDisabled = coerceBooleanProperty(val);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.label = this.label || this.labels.itemsPerPage;
        this.rowOptions = this.rowOptions || this.getDefaultRowOptions();
    }
    /**
     * @param {?=} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this.page = this.page || 1;
        this.totalPages = this.calculateTotalPages();
        this.pages = this.getPages(this.page, this.totalPages);
    }
    /**
     * @return {?}
     */
    getDefaultRowOptions() {
        return [
            { value: 10, label: '10' },
            { value: 25, label: '25' },
            { value: 50, label: '50' },
            { value: 100, label: '100' }
        ];
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onPageSizeChanged(event) {
        this.page = 1;
        this.itemsPerPage = event.selected;
        this.totalPages = this.calculateTotalPages();
        this.pages = this.getPages(this.page, this.totalPages);
        this.pageChange.emit(this.page);
        this.itemsPerPageChange.emit(this.itemsPerPage);
        this.onPageChange.emit({
            page: this.page,
            itemsPerPage: this.itemsPerPage
        });
    }
    /**
     * @param {?} page
     * @param {?=} event
     * @return {?}
     */
    selectPage(page, event) {
        if (event) {
            event.preventDefault();
        }
        this.page = page;
        this.pages = this.getPages(this.page, this.totalPages);
        this.pageChange.emit(this.page);
        this.onPageChange.emit({
            page: this.page,
            itemsPerPage: this.itemsPerPage
        });
    }
    /**
     * @return {?}
     */
    noPrevious() {
        return this.page === 1;
    }
    /**
     * @return {?}
     */
    noNext() {
        return this.page === this.totalPages;
    }
    /**
     * @param {?} number
     * @param {?} text
     * @param {?} isActive
     * @return {?}
     */
    makePage(number, text, isActive) {
        return {
            number: number,
            text: text,
            active: isActive
        };
    }
    /**
     * @param {?} currentPage
     * @param {?} totalPages
     * @return {?}
     */
    getPages(currentPage, totalPages) {
        let /** @type {?} */ pages = [];
        // Default page limits
        let /** @type {?} */ startPage = 1;
        let /** @type {?} */ endPage = totalPages;
        const /** @type {?} */ isMaxSized = this.maxPagesDisplayed < totalPages;
        // recompute if maxPagesDisplayed
        if (isMaxSized) {
            // Current page is displayed in the middle of the visible ones
            startPage = Math.max(currentPage - Math.floor(this.maxPagesDisplayed / 2), 1);
            endPage = startPage + this.maxPagesDisplayed - 1;
            // Adjust if limit is exceeded
            if (endPage > totalPages) {
                endPage = totalPages;
                startPage = endPage - this.maxPagesDisplayed + 1;
            }
        }
        // Add page number links
        for (let /** @type {?} */ number = startPage; number <= endPage; number++) {
            const /** @type {?} */ page = this.makePage(number, number.toString(), number === currentPage);
            pages.push(page);
        }
        return pages;
    }
    /**
     * @return {?}
     */
    calculateTotalPages() {
        const /** @type {?} */ totalPages = this.itemsPerPage < 1 ? 1 : Math.ceil(this.totalItems / this.itemsPerPage);
        return Math.max(totalPages || 0, 1);
    }
}
Pagination.decorators = [
    { type: Component, args: [{
                selector: 'novo-pagination',
                template: `
        <h5 class="rows">{{label}}</h5>
        <novo-select [options]="rowOptions" [placeholder]="labels.select" [(ngModel)]="itemsPerPage" (onSelect)="onPageSizeChanged($event)" data-automation-id="pager-select"></novo-select>
        <span class="spacer"></span>
        <ul class="pager" data-automation-id="pager">
            <li class="page" (click)="selectPage(page-1)" [ngClass]="{'disabled': noPrevious()}"><i class="bhi-previous" data-automation-id="pager-previous"></i></li>
            <li class="page" [ngClass]="{active: p.number==page}" [class.disabled]="disablePageSelection" *ngFor="let p of pages" (click)="selectPage(p.number)">{{p.text}}</li>
            <li class="page" (click)="selectPage(page+1)" [ngClass]="{'disabled': noNext()}"><i class="bhi-next" data-automation-id="pager-next"></i></li>
        </ul>
  `
            },] },
];
/**
 * @nocollapse
 */
Pagination.ctorParameters = () => [
    { type: NovoLabelService, },
];
Pagination.propDecorators = {
    'page': [{ type: Input },],
    'totalItems': [{ type: Input },],
    'itemsPerPage': [{ type: Input },],
    'rowOptions': [{ type: Input },],
    'label': [{ type: Input },],
    'disablePageSelection': [{ type: Input },],
    'pageChange': [{ type: Output },],
    'itemsPerPageChange': [{ type: Output },],
    'onPageChange': [{ type: Output },],
};

class BaseRenderer {
    constructor() {
        this.data = {};
        this.value = '';
        this.meta = {};
    }
}

// NG2
// APP
class RowDetails {
    /**
     * @param {?} element
     * @param {?} componentUtils
     */
    constructor(element, componentUtils) {
        this.element = element;
        this.componentUtils = componentUtils;
        this.value = '';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.renderer) {
            if (this.renderer.prototype instanceof BaseRenderer) {
                let /** @type {?} */ componentRef = this.componentUtils.appendNextToLocation(this.renderer, this.container);
                componentRef.instance.data = this.data;
            }
            else {
                this.value = this.renderer(this.data);
            }
        }
        else {
            // this.value = this.row[this.column.name];
        }
    }
}
RowDetails.decorators = [
    { type: Component, args: [{
                selector: 'novo-row-details',
                template: `
        <span #container></span>
        <span>{{value}}</span>
    `
            },] },
];
/**
 * @nocollapse
 */
RowDetails.ctorParameters = () => [
    { type: ElementRef, },
    { type: ComponentUtils, },
];
RowDetails.propDecorators = {
    'container': [{ type: ViewChild, args: ['container', { read: ViewContainerRef },] },],
    'data': [{ type: Input },],
    'renderer': [{ type: Input },],
};

// NG2
// Vendor
// APP
class TableCell {
    /**
     * @param {?} element
     * @param {?} componentUtils
     */
    constructor(element, componentUtils) {
        this.element = element;
        this.componentUtils = componentUtils;
        this.value = '';
        this.element = element;
        this.componentUtils = componentUtils;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.column._type = this.column.type || 'text';
        if (this.column.renderer) {
            if (this.column.renderer.prototype instanceof BaseRenderer) {
                this.column._type = 'custom';
                let /** @type {?} */ componentRef = this.componentUtils.appendNextToLocation(this.column.renderer, this.container);
                componentRef.instance.meta = this.column;
                componentRef.instance.data = this.row;
                componentRef.instance.value = this.form && this.hasEditor ? this.form.value[this.column.name] : this.row[this.column.name];
                // TODO - save ref to this and update in the valueChanges below!!
            }
            else {
                // TODO - wtf to do here?
                this.value = this.column.renderer(this.row);
            }
        }
        else {
            this.value = this.form && this.hasEditor ? this.form.value[this.column.name] : this.row[this.column.name];
        }
        if (this.form && this.hasEditor) {
            this.valueChangeSubscription = this.form.valueChanges
                .debounceTime(300)
                .distinctUntilChanged()
                .subscribe((value) => {
                this.value = value[this.column.name];
            });
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.valueChangeSubscription) {
            this.valueChangeSubscription.unsubscribe();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onClick(event) {
        if (event) {
            event.preventDefault();
            event.stopPropagation();
        }
        if (this.column.onClick) {
            this.column.onClick(this.row);
        }
    }
}
TableCell.decorators = [
    { type: Component, args: [{
                selector: 'novo-table-cell',
                template: `
        <div [ngSwitch]="column._type">
            <span #container></span>
            <date-cell *ngSwitchCase="'date'" [value]="value"></date-cell>
            <a *ngSwitchCase="'link'" (click)="onClick($event);">{{ value }}</a>
            <span *ngSwitchDefault>{{ value }}</span>
        </div>
    `
            },] },
];
/**
 * @nocollapse
 */
TableCell.ctorParameters = () => [
    { type: ElementRef, },
    { type: ComponentUtils, },
];
TableCell.propDecorators = {
    'container': [{ type: ViewChild, args: ['container', { read: ViewContainerRef },] },],
    'column': [{ type: Input },],
    'row': [{ type: Input },],
    'form': [{ type: Input },],
    'hasEditor': [{ type: Input },],
};

// NG2
// APP
class TableFilter {
    /**
     * @param {?} element
     * @param {?} renderer
     */
    constructor(element, renderer) {
        this.element = element;
        this.renderer = renderer;
        this.onFilterChange = new EventEmitter();
        this.element = element;
        this.renderer = renderer;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.ngOnChanges();
    }
    /**
     * @param {?=} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        let /** @type {?} */ label = '';
        if (this.config.freetextFilter) {
            label = this.config.freetextFilter;
        }
        else if (this.config.filter) {
            label = this.config.filter;
        }
        this.renderer.setProperty(this.element, 'value', label);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onChangeFilter(event) {
        clearTimeout(this.filterThrottle);
        if (KeyCodes.ENTER === event.keyCode) {
            this.config.filter = ((event.target)).value;
            this.onFilterChange.emit({ filtering: this.config });
        }
        else {
            this.filterThrottle = setTimeout(() => {
                this.config.filter = ((event.target)).value;
                this.onFilterChange.emit({ filtering: this.config });
            }, 300);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onClick(event) {
        Helpers.swallowEvent(event);
    }
}
TableFilter.decorators = [
    { type: Directive, args: [{
                selector: '[novoTableFilter]',
            },] },
];
/**
 * @nocollapse
 */
TableFilter.ctorParameters = () => [
    { type: ElementRef, },
    { type: Renderer2, },
];
TableFilter.propDecorators = {
    'config': [{ type: Input, args: ['novoTableFilter',] },],
    'onFilterChange': [{ type: Output },],
    'onChangeFilter': [{ type: HostListener, args: ['keydown', ['$event'],] },],
    'onClick': [{ type: HostListener, args: ['click', ['$event'],] },],
};

// NG2
// App
class ThOrderable {
    /**
     * @param {?} element
     */
    constructor(element) {
        this.element = element;
        this.onOrderChange = new EventEmitter();
        this.element = element;
    }
    /**
     * @return {?}
     */
    get index() {
        let /** @type {?} */ index = null;
        if (this.element.nativeElement && this.element.nativeElement.parentNode) {
            let /** @type {?} */ children = Array.prototype.slice.call(this.element.nativeElement.parentNode.children);
            index = children.indexOf(this.element.nativeElement);
        }
        return index;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.column.ordering) {
            this.element.nativeElement.setAttribute('draggable', true);
            this.table = this.findTable(this.element.nativeElement);
        }
    }
    /**
     * \@name onDragStart
     * @param {?=} event
     * @return {?}
     */
    onDragStart(event) {
        if (this.column.ordering) {
            this.element.nativeElement.classList.add('dragging');
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/plain', JSON.stringify(this.column));
            this.clone = this.table.cloneNode(true);
            this.clone.style.position = 'absolute';
            this.clone.style.left = '100%';
            this.clone.style.width = '150px';
            this.deleteColumns(this.clone);
            document.body.appendChild(this.clone);
            event.dataTransfer.setDragImage(this.clone, 75, 30);
        }
    }
    /**
     * \@name deleteColumns
     * @param {?} table
     * @return {?}
     */
    deleteColumns(table$$1) {
        // TODO: `table` should be immutable and this method should return the modified data to its caller
        if (table$$1.rows.length > 0) {
            const /** @type {?} */ allRows = table$$1.rows;
            for (let /** @type {?} */ i = 0; i < allRows.length; i++) {
                if (i > 10) {
                    table$$1.deleteRow(-1);
                }
                else {
                    const /** @type {?} */ cellLength = allRows[i].cells.length;
                    for (let /** @type {?} */ c = 0; c < cellLength; c++) {
                        if (c < this.index) {
                            allRows[i].deleteCell(0);
                        }
                        else if (c > this.index) {
                            allRows[i].deleteCell(-1);
                        }
                    }
                }
            }
        }
    }
    /**
     * @param {?} start
     * @return {?}
     */
    findTable(start) {
        let /** @type {?} */ htmlElementNode = start;
        while (htmlElementNode) {
            htmlElementNode = htmlElementNode.parentNode;
            if (htmlElementNode && htmlElementNode.tagName.toLowerCase() === 'table') {
                return htmlElementNode;
            }
        }
        return undefined;
    }
    /**
     * @param {?=} event
     * @return {?}
     */
    onDrag(event) {
        Helpers.swallowEvent(event);
        return false;
    }
    /**
     * @param {?=} event
     * @return {?}
     */
    onDragEnd(event) {
        Helpers.swallowEvent(event);
        this.element.nativeElement.classList.remove('over');
        this.element.nativeElement.classList.remove('dragging');
        document.body.removeChild(this.clone);
        return false;
    }
    /**
     * @param {?=} event
     * @return {?}
     */
    onDrop(event) {
        Helpers.swallowEvent(event);
        this.element.nativeElement.classList.remove('over');
        const /** @type {?} */ data = JSON.parse(event.dataTransfer.getData('text/plain'));
        this.onOrderChange.emit({
            first: data,
            second: this.column
        });
        return false;
    }
    /**
     * \@name onDragOver
     * @param {?} event
     * @return {?}
     */
    onDragOver(event) {
        Helpers.swallowEvent(event);
        event.dataTransfer.dropEffect = 'move';
        return false;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onDragEnter(event) {
        this.element.nativeElement.classList.add('over');
        this.target = event.target;
    }
    /**
     * @param {?=} event
     * @return {?}
     */
    onDragLeave(event) {
        this.element.nativeElement.classList.remove('over');
    }
}
ThOrderable.decorators = [
    { type: Directive, args: [{
                selector: '[novoThOrderable]',
                host: {
                    '(dragstart)': 'onDragStart($event)',
                    '(dragover)': 'onDragOver($event)',
                    '(dragenter)': 'onDragEnter($event)',
                    '(dragleave)': 'onDragLeave($event)',
                    '(dragend)': 'onDragEnd($event)',
                    '(drop)': 'onDrop($event)'
                }
            },] },
];
/**
 * @nocollapse
 */
ThOrderable.ctorParameters = () => [
    { type: ElementRef, },
];
ThOrderable.propDecorators = {
    'column': [{ type: Input, args: ['novoThOrderable',] },],
    'onOrderChange': [{ type: Output },],
};

// NG2
class ThSortable {
    constructor() {
        this.onSortChange = new EventEmitter();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onToggleSort(event) {
        if (event) {
            event.preventDefault();
        }
        if (this.config && this.column && this.config.sorting !== false && this.column.sorting !== false) {
            switch (this.column.sort) {
                case 'asc':
                    this.column.sort = 'desc';
                    break;
                default:
                    this.column.sort = 'asc';
                    break;
            }
            this.onSortChange.emit(this.column);
        }
    }
}
ThSortable.decorators = [
    { type: Directive, args: [{
                selector: '[novoThSortable]',
                host: {
                    '(click)': 'onToggleSort($event)'
                }
            },] },
];
/**
 * @nocollapse
 */
ThSortable.ctorParameters = () => [];
ThSortable.propDecorators = {
    'config': [{ type: Input, args: ['novoThSortable',] },],
    'column': [{ type: Input },],
    'onSortChange': [{ type: Output },],
};

// NG2
// APP
class DateCell extends BaseRenderer {
}
DateCell.decorators = [
    { type: Component, args: [{
                selector: 'date-cell',
                template: `
        <div class="date-cell">
            <label>{{ value | date }}</label>
        </div>
    `
            },] },
];
/**
 * @nocollapse
 */
DateCell.ctorParameters = () => [];
DateCell.propDecorators = {
    'value': [{ type: Input },],
};

// NG2
// APP
class PercentageCell extends BaseRenderer {
}
PercentageCell.decorators = [
    { type: Component, args: [{
                selector: 'percentage-cell',
                template: `
        <div class="percentage" *ngIf="value || value === 0">{{ value | percent:'1.0-2' }}</div>
    `
            },] },
];
/**
 * @nocollapse
 */
PercentageCell.ctorParameters = () => [];

// NG2
// APP
class NovoDropdownCell extends BaseRenderer {
    /**
     * @return {?}
     */
    ngOnInit() {
        // Check for and fix bad config
        if (!this.meta.dropdownCellConfig) {
            throw new Error('Missing "dropdownCellConfig" on the column setup');
        }
    }
    /**
     * @param {?} config
     * @param {?} option
     * @param {?} value
     * @return {?}
     */
    onClick(config, option, value) {
        let /** @type {?} */ callback = option.callback || config.callback;
        callback(this.data, value || option);
    }
}
NovoDropdownCell.decorators = [
    { type: Component, args: [{
                selector: 'novo-dropdown-cell',
                template: `
        <novo-dropdown appendToBody="true" parentScrollSelector=".table-container" containerClass="novo-table-dropdown-cell">
            <button type="button" theme="secondary" icon="collapse" inverse>
                <span data-automation-id="novo-dropdown-cell-value">{{ value }}</span>
            </button>
            <list>
                <ng-container *ngFor="let config of meta.dropdownCellConfig; let i = index">
                    <dropdown-item-header *ngIf="config.category">{{ config.category }}</dropdown-item-header>
                    <item *ngFor="let option of config.options" (action)="onClick(config, option, option.value)" [class.active]="(option || option.value) === value">
                        <span [attr.data-automation-id]="option.label || option">{{ option.label || option }}</span> <i *ngIf="(option || option.value) === value" class="bhi-check"></i>
                    </item>
                    <hr *ngIf="i < meta.dropdownCellConfig.length - 1"/>
                </ng-container>
            </list>
        </novo-dropdown>
    `
            },] },
];
/**
 * @nocollapse
 */
NovoDropdownCell.ctorParameters = () => [];
NovoDropdownCell.propDecorators = {
    'meta': [{ type: Input },],
    'value': [{ type: Input },],
};

// NG2
class NovoTableKeepFilterFocus {
    /**
     * @param {?} element
     */
    constructor(element) {
        this.element = element;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.element.nativeElement.focus();
    }
}
NovoTableKeepFilterFocus.decorators = [
    { type: Directive, args: [{
                selector: '[keepFilterFocused]'
            },] },
];
/**
 * @nocollapse
 */
NovoTableKeepFilterFocus.ctorParameters = () => [
    { type: ElementRef, },
];

// NG2
class NovoTableActionsElement {
}
NovoTableActionsElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-table-actions',
                template: '<ng-content></ng-content>'
            },] },
];
/**
 * @nocollapse
 */
NovoTableActionsElement.ctorParameters = () => [];

// NG2
class NovoTableFooterElement {
}
NovoTableFooterElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-table-footer',
                template: '<ng-content></ng-content>'
            },] },
];
/**
 * @nocollapse
 */
NovoTableFooterElement.ctorParameters = () => [];

// NG2
class NovoTableHeaderElement {
}
NovoTableHeaderElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-table-header',
                template: '<ng-content></ng-content>'
            },] },
];
/**
 * @nocollapse
 */
NovoTableHeaderElement.ctorParameters = () => [];

// NG2
// APP
class NovoTableExtrasModule {
}
NovoTableExtrasModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    NovoSelectModule,
                    NovoDropdownModule,
                    NovoButtonModule
                ],
                declarations: [
                    NovoTableHeaderElement,
                    NovoTableFooterElement,
                    NovoTableActionsElement,
                    NovoTableKeepFilterFocus,
                    Pagination,
                    RowDetails,
                    TableCell,
                    TableFilter,
                    ThOrderable,
                    ThSortable,
                    DateCell,
                    PercentageCell,
                    NovoDropdownCell
                ],
                exports: [
                    NovoTableHeaderElement,
                    NovoTableFooterElement,
                    NovoTableActionsElement,
                    NovoTableKeepFilterFocus,
                    Pagination,
                    RowDetails,
                    TableCell,
                    TableFilter,
                    ThOrderable,
                    ThSortable,
                    DateCell,
                    PercentageCell,
                    NovoDropdownCell
                ],
                entryComponents: [
                    DateCell,
                    PercentageCell,
                    NovoDropdownCell
                ]
            },] },
];
/**
 * @nocollapse
 */
NovoTableExtrasModule.ctorParameters = () => [];

class CollectionEvent {
    /**
     * @param {?=} type
     * @param {?=} data
     */
    constructor(type = 'Collection.REFRESH', data = []) {
        this.type = '';
        this.data = [];
        this.type = type;
        this.data = data;
    }
}
CollectionEvent.REFRESH = 'Collection.REFRESH';
CollectionEvent.ADD = 'Collection.ADD';
CollectionEvent.REMOVE = 'Collection.REMOVE';
CollectionEvent.REMOVE_ALL = 'Collection.REMOVE_ALL';
CollectionEvent.REPLACE = 'Collection.REPLACE';
CollectionEvent.INVALIDATE_ALL = 'Collection.INVALIDATE_ALL';
CollectionEvent.SORT = 'Collection.SORT';
CollectionEvent.FILTER = 'Collection.FILTER';
CollectionEvent.CHANGE = 'Collection.CHANGE';
CollectionEvent.CURRENTPAGE_CHANGE = 'Collection.CURRENTPAGE_CHANGE';
CollectionEvent.PAGESIZE_CHANGE = 'Collection.PAGESIZE_CHANGE';
CollectionEvent.NUMBEROFPAGES_CHANGE = 'Collection.NUMBEROFPAGES_CHANGE';

// Ng
/**
 * Base Class for all Collection based data providers
 *
 * @export
 * \@class DataProvider
 * \@example
 *  var dp:DataProvider = new DataProvider();
 *  dp.addItem({label:"Item 1"});
 *  dp.addItem({label:"Item 2"});
 *  dp.addItem({label:"Item 3"});
 *  dp.addItem({label:"Item 4"});
 *  var myList:List = new List();
 *  myList.dataProvider = dp;
 */
class ArrayCollection {
    /**
     * @param {?=} source
     */
    constructor(source = []) {
        this.dataChange = new EventEmitter();
        this.source = [];
        this.editData = [];
        this.isEditing = false;
        this.filterData = [];
        this._filter = {};
        this._sort = [];
        this.source = source;
        this.editData = this.copy(this.source);
        this.filterData = this.source.slice();
    }
    /**
     * @return {?}
     */
    get length() {
        return this.filterData.length;
    }
    /**
     * @return {?}
     */
    get total() {
        return this.filterData.length;
    }
    /**
     * @return {?}
     */
    get list() {
        return this.filterData;
    }
    /**
     * @return {?}
     */
    isEmpty() {
        return this.length <= 0 && !this.isLoading() && !this.hasErrors();
    }
    /**
     * @return {?}
     */
    hasErrors() {
        return false;
    }
    /**
     * @return {?}
     */
    isLoading() {
        return false;
    }
    /**
     * @return {?}
     */
    isFiltered() {
        return (Object.keys(this._filter).length > 0);
    }
    /**
     * Method to switch the isEditingflag for the data source
     * @return {?}
     */
    edit() {
        this.isEditing = true;
        this.editData = this.copy(this.source);
    }
    /**
     * Method to leave edit mode and reset source
     * @return {?}
     */
    undo() {
        this.isEditing = false;
        this.source = this.copy(this.editData);
        this.refresh();
    }
    /**
     * Method to leave edit mode and save editData
     * @return {?}
     */
    commit() {
        this.isEditing = false;
        this.source = this.filterData.slice();
        this.refresh();
    }
    /**
     * Appends an item to the end of the data provider.
     *
     *
     * \@memberOf ArrayCollection
     * @param {?} item
     * @return {?}
     */
    addItem(item) {
        this.isEditing ? this.editData.push(item) : this.source.push(item);
        this.onDataChange(new CollectionEvent(CollectionEvent.ADD, [item]));
        this.refresh();
    }
    /**
     * Adds a new item to the data provider at the specified index.
     *
     *
     * \@memberOf ArrayCollection
     * @param {?} item
     * @param {?} index
     * @return {?}
     */
    addItemAt(item, index) {
        this.isEditing ? this.editData.splice(index, 0, item) : this.source.splice(index, 0, item);
        this.onDataChange(new CollectionEvent(CollectionEvent.ADD, [item]));
        this.refresh();
    }
    /**
     *  Appends multiple items to the end of the DataProvider and dispatches a CollectionEvent.ADD event.
     *
     *
     * \@memberOf ArrayCollection
     * @param {?} items
     * @return {?}
     */
    addItems(items) {
        this.isEditing ? this.editData.push(...items) : this.source.push(...items);
        this.onDataChange(new CollectionEvent(CollectionEvent.ADD, items));
        this.refresh();
    }
    /**
     * Adds several items to the data provider at the specified index and dispatches a CollectionEvent.ADD event.
     *
     *
     * \@memberOf ArrayCollection
     * @param {?} items
     * @param {?} index
     * @return {?}
     */
    addItemsAt(items, index) {
        this.isEditing ? this.editData.splice(index, 0, ...items) : this.source.splice(index, 0, ...items);
    }
    /**
     * Creates a copy of the current ArrayCollection any.
     *
     *
     * \@memberOf ArrayCollection
     * @return {?}
     */
    clone() {
        return new ArrayCollection(this.isEditing ? this.copy(this.editData) : this.copy(this.source));
    }
    /**
     * Creates a copy of the current ArrayCollection any.
     *
     *
     * \@memberOf ArrayCollection
     * @param {?} array
     * @return {?}
     */
    copy(array) {
        return Helpers.deepClone(array);
    }
    /**
     * Concatenates the specified items to the end of the current data provider.
     *
     *
     * \@memberOf ArrayCollection
     * @param {?} items
     * @return {?}
     */
    concat(items) {
        this.addItems(items);
    }
    /**
     * Returns the item at the specified index.
     *
     *
     * \@memberOf ArrayCollection
     * @param {?} index
     * @return {?}
     */
    getItemAt(index) {
        return this.isEditing ? this.editData[index] : this.source[index];
    }
    /**
     *  Returns the index of the specified item.
     *
     *
     * \@memberOf ArrayCollection
     * @param {?} item
     * @return {?}
     */
    getItemIndex(item) {
        return this.isEditing ? this.editData.indexOf(item) : this.source.indexOf(item);
    }
    /**
     * Invalidates all the data items that the DataProvider contains and dispatches a CollectionEvent.INVALIDATE_ALL event.
     *
     * \@memberOf ArrayCollection
     * @return {?}
     */
    invalidate() {
        this.onDataChange(new CollectionEvent(CollectionEvent.INVALIDATE_ALL));
    }
    /**
     * Appends the specified data into the data that the data provider contains and removes any duplicate items.
     *
     *
     * \@memberOf ArrayCollection
     * @param {?} newData
     * @return {?}
     */
    merge(newData) {
        for (let /** @type {?} */ obj of newData) {
            let /** @type {?} */ existing = ~this.getItemIndex(obj);
            if (existing) {
                this.replaceItem(obj, existing);
            }
            else {
                this.addItem(obj);
            }
        }
    }
    /**
     * Removes all items from the data provider and dispatches a CollectionEvent.REMOVE_ALL event.
     *
     * \@memberOf ArrayCollection
     * @return {?}
     */
    removeAll() {
        this.source = [];
        this.editData = [];
        this.filterData = [];
        this.onDataChange(new CollectionEvent(CollectionEvent.REMOVE_ALL, []));
        this.refresh();
    }
    /**
     * Removes the specified item from the data provider and dispatches a CollectionEvent.REMOVE event.
     *
     *
     * \@memberOf ArrayCollection
     * @param {?} item
     * @return {?}
     */
    removeItem(item) {
        let /** @type {?} */ index = this.getItemIndex(item);
        return this.removeItemAt(index);
    }
    /**
     * Removes the item at the specified index and dispatches a CollectionEvent.REMOVE event.
     *
     *
     * \@memberOf ArrayCollection
     * @param {?} index
     * @return {?}
     */
    removeItemAt(index) {
        let /** @type {?} */ success = !!(this.source.splice(index, 1));
        this.refresh();
        return success;
    }
    /**
     * Replaces an existing item with a new item and dispatches a CollectionEvent.REPLACE event.
     *
     *
     * \@memberOf ArrayCollection
     * @param {?} newItem
     * @param {?} oldItem
     * @return {?}
     */
    replaceItem(newItem, oldItem) {
        let /** @type {?} */ index = this.getItemIndex(oldItem);
        if (index >= 0) {
            this.replaceItemAt(newItem, index);
        }
    }
    /**
     * Replaces the item at the specified index and dispatches a CollectionEvent.REPLACE event.
     *
     *
     * \@memberOf ArrayCollection
     * @param {?} newItem
     * @param {?} index
     * @return {?}
     */
    replaceItemAt(newItem, index) {
        this.filterData.splice(index, 1, newItem);
    }
    /**
     * Sorts the items that the data provider contains and dispatches a CollectionEvent.SORT event.
     *
     * \@memberOf ArrayCollection
     * @return {?} null
     *
     */
    get sort() {
        return this._sort;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set sort(value) {
        this._sort = value;
        this.refresh();
    }
    /**
     * Sorts the items that the data provider contains by the specified field and dispatches a CollectionEvent.SORT event.
     *
     * \@memberOf ArrayCollection
     * @param {?} fieldName
     * @param {?=} reverse
     * @return {?} null
     *
     */
    sortOn(fieldName, reverse = false) {
        this.filterData = this.filterData.sort(Helpers.sortByField(fieldName, reverse));
        this.onDataChange(new CollectionEvent(CollectionEvent.SORT));
        return this.filterData;
    }
    /**
     * @return {?}
     */
    get filter() {
        return this._filter;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set filter(value) {
        this._filter = value;
        this.refresh();
    }
    /**
     * @param {?} fieldName
     * @param {?=} value
     * @return {?}
     */
    filterOn(fieldName, value = null) {
        this.filterData = this.filterData.filter(Helpers.filterByField(fieldName, value));
        return this.filterData;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onDataChange(event) {
        this.dataChange.emit(event);
    }
    /**
     * @return {?}
     */
    refresh() {
        this.filterData = this.isEditing ? this.editData.slice() : this.source.slice();
        for (let /** @type {?} */ item of this._sort.reverse()) {
            this.sortOn(item.field, item.reverse);
        }
        for (let /** @type {?} */ key in this._filter) {
            if (key) {
                this.filterOn(key, this._filter[key]);
            }
        }
        this.onDataChange(new CollectionEvent(CollectionEvent.CHANGE, this.filterData));
    }
    /**
     * Creates an Array any representation of the data that the data provider contains.
     *
     *
     * \@memberOf ArrayCollection
     * @return {?}
     */
    toArray() {
        return this.isEditing ? this.editData : this.source;
    }
    /**
     * @return {?}
     */
    toJSON() {
        return this.isEditing ? this.editData : this.source;
    }
}

class PagedArrayCollection extends ArrayCollection {
    /**
     * @param {?=} source
     */
    constructor(source = []) {
        super(source);
        this._page = 1;
        this._numberOfPages = 1;
        this._pageSize = 10;
    }
    /**
     * @return {?}
     */
    get numberOfPages() {
        let /** @type {?} */ result = this.source.length / this.pageSize;
        result = Math.ceil(result);
        return result;
    }
    /**
     * @return {?}
     */
    get page() {
        return this._page;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set page(value) {
        this._page = value;
        this.refresh();
    }
    /**
     * @return {?}
     */
    get pageSize() {
        return this._pageSize;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set pageSize(value) {
        this._pageSize = value;
        this.refresh();
    }
    /**
     * @return {?}
     */
    next() {
        if (this.page === this.numberOfPages) {
            return this.page;
        }
        this.page++;
        return this.page;
    }
    /**
     * @return {?}
     */
    prev() {
        if (this._page === 1) {
            return this.page;
        }
        this.page--;
        return this.page;
    }
    /**
     * @return {?}
     */
    first() {
        if (this.page === 1) {
            return this.page;
        }
        this.page = 1;
        return this.page;
    }
    /**
     * @return {?}
     */
    last() {
        if (this.page === this.numberOfPages) {
            return this.page;
        }
        this.page = this.numberOfPages;
        return this.page;
    }
    /**
     * @return {?}
     */
    refresh() {
        this.filterData = this.isEditing ? this.editData.slice() : this.source.slice();
        for (let /** @type {?} */ item of this._sort.reverse()) {
            this.sortOn(item.field, item.reverse);
        }
        for (let /** @type {?} */ key in this._filter) {
            if (key) {
                this.filterOn(key, this._filter[key]);
            }
        }
        if (this.page >= 0) {
            let /** @type {?} */ start = (this.page - 1) * this.pageSize;
            let /** @type {?} */ end = start + this.pageSize;
            let /** @type {?} */ result = this.filterData.slice(start, end);
            this.onDataChange(new CollectionEvent(CollectionEvent.CHANGE, result));
        }
        else {
            this.onDataChange(new CollectionEvent(CollectionEvent.CHANGE, this.filterData));
        }
    }
}

// NG2
// Vendor
// APP
let NovoTableMode = {};
NovoTableMode.VIEW = 1;
NovoTableMode.EDIT = 2;
NovoTableMode[NovoTableMode.VIEW] = "VIEW";
NovoTableMode[NovoTableMode.EDIT] = "EDIT";
class NovoTableElement {
    /**
     * @param {?} labels
     * @param {?} formUtils
     * @param {?} builder
     */
    constructor(labels, formUtils, builder) {
        this.labels = labels;
        this.formUtils = formUtils;
        this.builder = builder;
        this.config = {};
        this.skipSortAndFilterClear = false;
        this.mode = NovoTableMode.VIEW;
        this.editable = false;
        this.onRowClick = new EventEmitter();
        this.onRowSelect = new EventEmitter();
        this.onTableChange = new EventEmitter();
        this._rows = [];
        this.selected = [];
        this.activeId = 0;
        this.master = false;
        this.expandAll = false;
        this.indeterminate = false;
        this.lastPage = 0;
        this.selectedPageCount = 0;
        this.showSelectAllMessage = false;
        this.pagedData = [];
        // Map to keep track of what dropdowns are toggled
        // Used to properly *ngIf the <list> so that the keepFilterFocused Directive
        // will properly fire the ngAfterViewInit event
        this.toggledDropdownMap = {};
        this.NovoTableMode = NovoTableMode;
        this.tableForm = new FormGroup({});
        this.footers = [];
        this.grossFlagToAvoidTheTableFromBeingUglyWhenHidingTheToast = false;
        this.loading = false;
    }
    /**
     * @param {?} rows
     * @return {?}
     */
    set rows(rows) {
        this.dataProvider = rows;
        if (rows && rows.length > 0) {
            this.setupColumnDefaults();
        }
        // this is a temporary/hacky fix until async dataloading is handled within the table
        if (!this.skipSortAndFilterClear) {
            this.clearAllSortAndFilters();
        }
    }
    /**
     * @return {?}
     */
    get rows() {
        return this._rows;
    }
    /**
     * @param {?} dp
     * @return {?}
     */
    set dataProvider(dp) {
        this._dataProvider = Array.isArray(dp) ? new PagedArrayCollection(dp) : dp;
        this._dataProvider.dataChange.debounceTime(100).subscribe((event) => {
            switch (event.type) {
                case CollectionEvent.CHANGE:
                    this._rows = event.data;
                    // Setup form
                    this.tableForm = this.builder.group({
                        rows: this.builder.array([])
                    });
                    // Remove all selection on sort change if selection is on
                    if (this.config.rowSelectionStyle === 'checkbox') {
                        this.pagedData = event.data;
                        this.pageSelected = this.pagedData.filter(r => r._selected);
                        this.rowSelectHandler();
                    }
                    // Find that columns we might need to sum up via the footer
                    let /** @type {?} */ columnsToSum = [];
                    let /** @type {?} */ columnSums = {};
                    if (this.config.footers) {
                        this.config.footers.forEach(config => {
                            columnsToSum.push(...config.columns);
                        });
                        // Only have unique columns, filter out duplicates
                        columnsToSum = columnsToSum.filter((item, index, array) => array.indexOf(item) === index);
                    }
                    // Make a form for each row
                    let /** @type {?} */ tableFormRows = (this.tableForm.controls['rows']);
                    this._rows.forEach((row, index) => {
                        let /** @type {?} */ rowControls = [];
                        row.controls = {};
                        row._editing = {};
                        row._expanded = this.config.expandAll;
                        row.rowId = this._rows.length;
                        this.columns.forEach(column => {
                            // Use the control passed or use a ReadOnlyControl so that the form has the values
                            let /** @type {?} */ control = column.editorConfig ? ControlFactory.create(column.editorType, column.editorConfig) : new ReadOnlyControl({ key: column.name });
                            row.controls[column.name] = control;
                            rowControls.push(control);
                        });
                        this.formUtils.setInitialValues(rowControls, row, false);
                        tableFormRows.push(this.formUtils.toFormGroup(rowControls));
                        // Setup the total footer if configured
                        // Array of keys to total
                        if (columnsToSum.length !== 0) {
                            columnsToSum.forEach(column => {
                                if (Helpers.isBlank(columnSums[column])) {
                                    columnSums[column] = 0;
                                }
                                columnSums[column] += row[column];
                            });
                        }
                    });
                    if (this.mode === NovoTableMode.EDIT) {
                        this.setTableEdit();
                    }
                    // Setup the footers (if any)
                    if (this.config.footers) {
                        this.footers = [];
                        this.config.footers.forEach((footerConfig, footerConfigIndex) => {
                            let /** @type {?} */ footer = {};
                            footer[footerConfig.labelColumn] = footerConfig.label;
                            footerConfig.columns.forEach(column => {
                                if (footerConfig.method === 'AVG' && this._rows.length !== 0) {
                                    footer[column] = columnSums[column] / this._rows.length;
                                }
                                else {
                                    footer[column] = columnSums[column];
                                }
                            });
                            this.footers.push(footer);
                        });
                    }
                    break;
                default:
                    break;
            }
        });
        if (this.config.paging) {
            this._dataProvider.page = this.config.paging.current;
            this._dataProvider.pageSize = this.config.paging.itemsPerPage;
        }
        else {
            // Paging turned off, return basically all of the data
            this._dataProvider.page = 1;
            this._dataProvider.pageSize = 500;
        }
        if (dp && dp.length > 0) {
            this.setupColumnDefaults();
        }
        this._dataProvider.refresh();
    }
    /**
     * @return {?}
     */
    get dataProvider() {
        return this._dataProvider;
    }
    /**
     * @return {?}
     */
    get editing() {
        return this.mode === NovoTableMode.EDIT;
    }
    /**
     * @return {?}
     */
    get formValue() {
        return this.tableForm.value;
    }
    /**
     * @param {?} event
     * @param {?} column
     * @return {?}
     */
    onDropdownToggled(event, column) {
        this.toggledDropdownMap[column] = event;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onPageChange(event) {
        //this.dataProvider.page = event.page;
        //this.dataProvider.pageSize = event.itemsPerPage;
    }
    /**
     * @param {?} option
     * @return {?}
     */
    getOptionDataAutomationId(option) {
        if (!Helpers.isBlank(option.value)) {
            return option.value;
        }
        return option;
    }
    /**
     * \@name setupColumnDefaults
     * @return {?}
     */
    setupColumnDefaults() {
        // Check columns for cell option types
        this.columns.forEach(column => {
            if (column && column.type) {
                switch (column.type) {
                    case 'date':
                        // Set options based on dates if there are none
                        column.options = (column.options || this.getDefaultOptions(column));
                        break;
                    default:
                        break;
                }
            }
        });
    }
    /**
     * \@name ngDoCheck
     * @return {?}
     */
    ngDoCheck() {
        if (this.config.paging && this.config.paging.current !== this.lastPage) {
            this.rowSelectHandler();
            this.showSelectAllMessage = false;
        }
        this.lastPage = this.config.paging ? this.config.paging.current : 1;
    }
    /**
     * \@name getPageStart
     * @return {?}
     */
    getPageStart() {
        return this.config.paging ? (this.dataProvider.page - 1) * this.dataProvider.pageSize : 0;
    }
    /**
     * \@name getPageEnd
     * @return {?}
     */
    getPageEnd() {
        return this.config.paging && this.dataProvider.pageSize > -1 ? this.getPageStart() + this.dataProvider.pageSize : this.rows.length;
    }
    /**
     * \@name onFilterClick
     * @param {?} column
     * @param {?} filter
     * @return {?}
     */
    onFilterClick(column, filter$$1) {
        if (filter$$1.range && !column.calendarShow) {
            column.calenderShow = true;
            return;
        }
        if (Array.isArray(column.filter) && column.multiple) {
            if (~column.filter.indexOf(filter$$1)) {
                // Remove filter
                column.filter.splice(column.filter.indexOf(filter$$1), 1);
                if (filter$$1.range) {
                    column.calenderShow = false;
                }
                if (column.filter.length === 0) {
                    column.filter = null;
                }
            }
            else {
                // Add filter
                column.filter.push(filter$$1);
            }
        }
        else {
            column.filter = Helpers.isBlank(filter$$1.value) ? filter$$1 : filter$$1.value;
        }
        this.onFilterChange();
    }
    /**
     * \@name onFilterClear
     * @param {?} column
     * @return {?}
     */
    onFilterClear(column) {
        setTimeout(() => {
            column.filter = null;
            column.freetextFilter = null;
            this.onFilterChange();
            if (column.originalOptions) {
                column.options = column.originalOptions;
            }
        });
    }
    /**
     * @return {?}
     */
    clearAllSortAndFilters() {
        if (this.config.filtering) {
            this.columns.forEach(column => {
                column.filter = null;
                column.sort = null;
            });
        }
    }
    /**
     * \@name onFilterChange
     *
     * \@description This method updates the row data to reflect the active filters.
     * @return {?}
     */
    onFilterChange() {
        if (this.config.filtering) {
            // Array of filters
            const /** @type {?} */ filters = this.columns.filter(col => !Helpers.isEmpty(col.filter));
            if (filters.length) {
                let /** @type {?} */ query = {};
                for (const /** @type {?} */ column of filters) {
                    if (Helpers.isFunction(column.match)) {
                        query[column.name] = (value, record) => {
                            return column.match(record, column.filter);
                        };
                    }
                    else if (column.preFilter && Helpers.isFunction(column.preFilter)) {
                        query = Object.assign({}, query, column.preFilter(this.escapeCharacters(column.filter)));
                    }
                    else if (Array.isArray(column.filter)) {
                        // The filters are an array (multi-select), check value
                        let /** @type {?} */ options = column.filter;
                        // We have an array of {value: '', labels: ''}
                        if (options[0].value || options[0].label) {
                            options = column.filter.map(opt => opt.value);
                        }
                        query[column.name] = { any: options };
                    }
                    else if (column.type && column.type === 'date') {
                        if (column.filter.startDate && column.filter.endDate) {
                            query[column.name] = {
                                min: startOfDay(column.filter.startDate),
                                max: startOfDay(addDays(startOfDay(column.filter.endDate), 1))
                            };
                        }
                        else {
                            query[column.name] = {
                                min: column.filter.min ? addDays(startOfToday(), column.filter.min) : startOfToday(),
                                max: column.filter.max ? addDays(startOfTomorrow(), column.filter.max) : startOfTomorrow()
                            };
                        }
                    }
                    else {
                        query[column.name] = column.filter;
                    }
                }
                if (Helpers.isFunction(this.config.filtering)) {
                    this.config.filtering(query);
                }
                else {
                    this._dataProvider.filter = query;
                }
            }
            else {
                this._dataProvider.filter = {};
            }
            // Trickle down to keep sort
            // this.onSortChange(this.currentSortColumn);
            // If paging, reset page
            if (this.config.paging) {
                this.config.paging.current = 1;
            }
            // Remove all selection on sort change if selection is on
            if (this.config.rowSelectionStyle === 'checkbox') {
                this.selectAll(false);
            }
        }
    }
    /**
     * @param {?} filter
     * @return {?}
     */
    escapeCharacters(filter$$1) {
        if (typeof (filter$$1) === 'string') {
            return filter$$1.replace(/'/g, '\'\'');
        }
        return filter$$1;
    }
    /**
     * \@name isFilterActive
     * \@description
     * @param {?} column
     * @param {?} filter
     *
     * @return {?}
     */
    isFilterActive(column, filter$$1) {
        //TODO: This needs to be refactored
        let /** @type {?} */ isActive = false;
        if (column && !Helpers.isBlank(column.filter) && !Helpers.isBlank(filter$$1)) {
            if (Array.isArray(column.filter)) {
                if (typeof (filter$$1) !== 'string') {
                    isActive = column.filter.some((item) => {
                        return item.label === filter$$1.label;
                    });
                }
                else {
                    isActive = column.filter.includes(filter$$1);
                }
            }
            else {
                if (typeof (column.filter) === typeof (filter$$1)) {
                    isActive = (column.filter === filter$$1);
                }
                else {
                    isActive = (column.filter === filter$$1.value);
                }
            }
        }
        return isActive;
    }
    /**
     * \@name onSortChange
     * @param {?} column
     * @return {?}
     */
    onSortChange(column) {
        this.currentSortColumn = column;
        let /** @type {?} */ sortedColumns = this.columns.filter((thisColumn) => {
            return thisColumn.sort && thisColumn !== this.currentSortColumn;
        });
        for (let /** @type {?} */ sortedColumn of sortedColumns) {
            sortedColumn.sort = null;
        }
        if (column) {
            if (Helpers.isFunction(this.config.sorting)) {
                this.config.sorting();
            }
            else if (Helpers.isFunction(column.preSort)) {
                this._dataProvider.sort = [].concat(column.preSort(column));
            }
            else {
                this._dataProvider.sort = [{ field: (column.compare || column.name), reverse: column.sort === 'desc' }];
            }
        }
        // Fire table change event
        // this.fireTableChangeEvent();
        // If paging, reset page
        if (this.config.paging) {
            this.config.paging.current = 1;
        }
        // Remove all selection on sort change if selection is on
        if (this.config.rowSelectionStyle === 'checkbox') {
            this.selectAll(false);
        }
    }
    /**
     * \@name fireTableChangeEvent
     * @return {?}
     */
    fireTableChangeEvent() {
        // Construct a table change object
        const /** @type {?} */ onTableChange = {};
        const /** @type {?} */ filters = this.columns.filter((col) => col.filter && col.filter.length);
        onTableChange.filter = filters.length ? filters : false;
        onTableChange.sort = this.currentSortColumn ? this.currentSortColumn : false;
        onTableChange.rows = this.rows;
        // Emit event
        this.onTableChange.emit(onTableChange);
    }
    /**
     * \@name findColumnIndex
     * @param {?} value
     * @return {?}
     */
    findColumnIndex(value) {
        for (let /** @type {?} */ i = 0; i < this.columns.length; i += 1) {
            if (this.columns[i].name === value) {
                return i;
            }
        }
        return null;
    }
    /**
     * \@name onOrderChange
     * @param {?} event
     * @return {?}
     */
    onOrderChange(event) {
        const /** @type {?} */ oldIndex = this.findColumnIndex(event.first.name);
        const /** @type {?} */ newIndex = this.findColumnIndex(event.second.name);
        this.columns.splice(newIndex, 0, this.columns.splice(oldIndex, 1)[0]);
        this.onSortChange(this.currentSortColumn);
    }
    /**
     * \@name selectPage
     * @param {?} expanded
     * @return {?}
     */
    expandAllOnPage(expanded) {
        this.config.expandAll = !expanded;
        for (let /** @type {?} */ row of this.dataProvider.list) {
            row._expanded = this.config.expandAll;
        }
    }
    /**
     * \@name selectPage
     * @return {?}
     */
    selectPage() {
        if (!this.master) {
            this.selectAll(false);
            // Only show the select all message when there is only one new page selected at a time
            this.selectedPageCount = this.selectedPageCount > 0 ? this.selectedPageCount - 1 : 0;
            this.showSelectAllMessage = false;
        }
        else {
            this.indeterminate = false;
            //this.pagedData = this.rows.slice(this.getPageStart(), this.getPageEnd());
            for (let /** @type {?} */ row of this.pagedData) {
                row._selected = this.master;
            }
            this.selected = this.dataProvider.list.filter((r) => r._selected);
            this.pageSelected = this.pagedData.filter((r) => r._selected);
            this.emitSelected(this.selected);
            // Only show the select all message when there is only one new page selected at a time
            this.selectedPageCount++;
            this.showSelectAllMessage = this.selectedPageCount === 1 && this.selected.length !== this.dataProvider.total;
        }
    }
    /**
     * \@name selectAll
     * @param {?} value
     * @return {?}
     */
    selectAll(value) {
        this.master = value;
        this.indeterminate = false;
        for (let /** @type {?} */ row of this.dataProvider.list) {
            row._selected = value;
        }
        this.selected = value ? this.dataProvider.list : [];
        this.showSelectAllMessage = false;
        this.selectedPageCount = this.selectedPageCount > 0 ? this.selectedPageCount - 1 : 0;
        this.rowSelectHandler();
    }
    /**
     * \@name rowSelectHandler
     * @return {?}
     */
    rowSelectHandler() {
        // this.pagedData = this.rows.slice(this.getPageStart(), this.getPageEnd());
        this.pageSelected = this.pagedData.filter((r) => r._selected);
        this.selected = this.dataProvider.list.filter((r) => r._selected);
        if (this.pageSelected.length === 0) {
            this.master = false;
            this.indeterminate = false;
        }
        else if (this.pageSelected.length === this.pagedData.length) {
            this.master = true;
            this.indeterminate = false;
        }
        else {
            this.master = false;
            this.indeterminate = true;
            // Breaking the selected page count
            this.showSelectAllMessage = false;
            this.selectedPageCount = this.selectedPageCount > 0 ? this.selectedPageCount - 1 : 0;
        }
        this.emitSelected(this.selected);
    }
    /**
     * \@name emitSelected
     * @param {?} selected
     * @return {?}
     */
    emitSelected(selected) {
        this.onRowSelect.emit({ length: selected.length, selected: selected });
    }
    /**
     * \@name rowClickHandler
     * @param {?} row
     * @return {?}
     */
    rowClickHandler(row) {
        if (this.config.rowSelect) {
            this.activeId = row.id || 0;
            this.onRowClick.emit(row);
        }
    }
    /**
     * \@name setDateOptions
     * @param {?} column
     * @return {?}
     */
    getDefaultOptions(column) {
        // TODO - needs to come from label service - https://github.com/bullhorn/novo-elements/issues/116
        let /** @type {?} */ opts = [
            { label: this.labels.past1Day, min: -1, max: 0 },
            { label: this.labels.past7Days, min: -7, max: 0 },
            { label: this.labels.past30Days, min: -30, max: 0 },
            { label: this.labels.past90Days, min: -90, max: 0 },
            { label: this.labels.past1Year, min: -366, max: 0 },
            { label: this.labels.next1Day, min: 0, max: 1 },
            { label: this.labels.next7Days, min: 0, max: 7 },
            { label: this.labels.next30Days, min: 0, max: 30 },
            { label: this.labels.next90Days, min: 0, max: 90 },
            { label: this.labels.next1Year, min: 0, max: 366 },
        ];
        if (column && column.range) {
            opts.push({
                label: this.labels.customDateRange,
                range: true,
            });
        }
        return opts;
    }
    /**
     * @param {?} column
     * @param {?} event
     * @return {?}
     */
    onCalenderSelect(column, event) {
        setTimeout(() => {
            if (event.startDate && event.endDate) {
                this.onFilterChange();
            }
        }, 10);
    }
    /**
     * @param {?} config
     * @return {?}
     */
    onFilterKeywords(config) {
        if (config && config.filtering && config.filtering.freetextFilter) {
            let /** @type {?} */ filterKeywords = config.filtering.freetextFilter.toLowerCase();
            if (!config.filtering.originalOptions) {
                config.filtering.originalOptions = config.filtering.options;
            }
            let /** @type {?} */ newOptions = config.filtering.originalOptions.filter((option) => {
                let /** @type {?} */ value = option && option.label ? option.label : option;
                value = value.toLowerCase() ? value.toLowerCase() : value;
                if (value === filterKeywords) {
                    return true;
                }
                else if (~value.indexOf(filterKeywords) || ~value.indexOf(filterKeywords)) {
                    return true;
                }
                return false;
            });
            config.filtering.options = newOptions;
            config.filtering.filter = config.filtering.freetextFilter;
        }
        else {
            config.filtering.options = config.filtering.originalOptions;
        }
        this.onFilterChange();
    }
    /**
     * \@name setTableEdit
     * \@description Sets the Table into EDIT mode, based on the row/column passed you can enter in a few states
     * (1) setTableEdit() - don't pass any to put the FULL table into edit mode
     * (2) setTableEdit(1) - pass only row to put that FULL row of the table into edit mode
     * (3) setTableEdit(1, 1) - pass row and column to put that column of the row of the table into edit mode
     * \@memberOf NovoTableElement
     * @param {?=} rowNumber
     * @param {?=} columnNumber
     * @return {?}
     */
    setTableEdit(rowNumber, columnNumber) {
        this.mode = NovoTableMode.EDIT;
        this._dataProvider.edit();
        this._rows.forEach((row, rowIndex) => {
            row._editing = row._editing || {};
            this.columns.forEach((column, columnIndex) => {
                if (column.viewOnly) {
                    row._editing[column.name] = false;
                }
                else if (Helpers.isEmpty(rowNumber) && Helpers.isEmpty(columnNumber)) {
                    row._editing[column.name] = true;
                }
                else if (!Helpers.isEmpty(rowNumber) && rowIndex === Number(rowNumber) && Helpers.isEmpty(columnNumber)) {
                    row._editing[column.name] = true;
                }
                else if (!Helpers.isEmpty(rowNumber) && !Helpers.isEmpty(columnNumber) && rowIndex === Number(rowNumber) && columnIndex === Number(columnNumber)) {
                    row._editing[column.name] = true;
                }
                else {
                    row._editing[column.name] = false;
                }
            });
        });
    }
    /**
     * \@name leaveEditMode
     * \@description Leaves edit mode for the Table and puts everything back to VIEW only
     * \@memberOf NovoTableElement
     * @param {?} cancel
     * @return {?}
     */
    leaveEditMode(cancel) {
        this.mode = NovoTableMode.VIEW;
        this._rows.forEach((row) => {
            row._editing = row._editing || {};
            this.columns.forEach((column) => {
                row._editing[column.name] = false;
            });
        });
        if (cancel) {
            this._dataProvider.undo();
        }
        else {
            this._dataProvider.commit();
        }
        this.hideToastMessage();
    }
    /**
     * \@name addEditableRow
     * \@description Adds a new row into the table to be edited, can be called from a local reference of the table in your template
     * \@memberOf NovoTableElement
     * @param {?=} defaultValue
     * @return {?}
     */
    addEditableRow(defaultValue = {}) {
        let /** @type {?} */ tableFormRows = (this.tableForm.controls['rows']);
        let /** @type {?} */ row = {};
        let /** @type {?} */ rowControls = [];
        row.controls = {};
        row._editing = {};
        row.rowId = this._rows.length + 1;
        this.columns.forEach((column) => {
            // Use the control passed or use a ReadOnlyControl so that the form has the values
            let /** @type {?} */ control = column.editorConfig ? ControlFactory.create(column.editorType, column.editorConfig) : new ReadOnlyControl({ key: column.name });
            control.value = null; // remove copied column value
            row.controls[column.name] = control;
            row._editing[column.name] = !column.viewOnly;
            rowControls.push(control);
        });
        this.formUtils.setInitialValues(rowControls, defaultValue, false);
        tableFormRows.push(this.formUtils.toFormGroup(rowControls));
        this._rows.push(row);
    }
    /**
     * \@name validateAndGetUpdatedData
     * \@description Validates the Form inside of the Table, if there are errors it will display/return the errors for each row.
     * If there are no errors, then it will return ONLY the changed data for each row, the data returned will be in the form:
     * { id: ID_OF_RECORD, key: value } -- data that was updated
     * { id: undefined, key: value } -- data that was added
     * \@memberOf NovoTableElement
     * @return {?}
     */
    validateAndGetUpdatedData() {
        if (this.tableForm && this.tableForm.controls && this.tableForm.controls['rows']) {
            let /** @type {?} */ changedRows = [];
            let /** @type {?} */ errors = [];
            // Go over the FormArray's controls
            ((this.tableForm.controls['rows'])).controls.forEach((formGroup, index) => {
                let /** @type {?} */ changedRow = null;
                let /** @type {?} */ error = null;
                // Go over the form group controls
                Object.keys(formGroup.controls).forEach((key) => {
                    let /** @type {?} */ control = formGroup.controls[key];
                    // Handle value changing
                    if (control && control.dirty && !control.errors) {
                        if (!changedRow) {
                            // Append the ID, so we have some key to save against
                            changedRow = {};
                            if (this._rows[index].id) {
                                changedRow.id = this._rows[index].id;
                            }
                        }
                        // If dirty, grab value off the form
                        changedRow[key] = this.tableForm.value['rows'][index][key];
                        // Set value back to row (should be already done via the server call, but do it anyway)
                        this._rows[index][key] = changedRow[key];
                    }
                    else if (control && control.errors) {
                        // Handle errors
                        if (!error) {
                            error = {};
                        }
                        error[key] = control.errors;
                        control.markAsDirty();
                        control.markAsTouched();
                    }
                });
                if (changedRow) {
                    changedRows.push(changedRow);
                }
                if (error) {
                    errors.push({ errors: error, row: this._rows[index], index: index });
                }
            });
            if (errors.length === 0) {
                return { changed: changedRows };
            }
            return { errors: errors };
        }
    }
    /**
     * \@name cancelEditing
     * \@description Refresh the data provider and leave edit mode
     * \@memberOf NovoTableElement
     * @return {?}
     */
    cancelEditing() {
        this.leaveEditMode(true);
    }
    /**
     * \@name saveChanges
     * \@description Refresh the data provider and leave edit mode
     * \@memberOf NovoTableElement
     * @return {?}
     */
    saveChanges() {
        this.leaveEditMode(false);
    }
    /**
     * \@name displayToastMessage
     * \@description Displays a toast message inside of the table
     * \@memberOf NovoTableElement
     * @param {?} toast
     * @param {?=} hideDelay
     * @return {?}
     */
    displayToastMessage(toast, hideDelay) {
        this.loading = false;
        this.toast = toast;
        if (hideDelay) {
            setTimeout(() => this.hideToastMessage(), hideDelay);
        }
    }
    /**
     * \@name hideToastMessage
     * \@description Force hide the toast message
     * \@memberOf NovoTableElement
     * @return {?}
     */
    hideToastMessage() {
        this.toast = null;
        // Hack to make the table display properly after hiding the toast
        this.grossFlagToAvoidTheTableFromBeingUglyWhenHidingTheToast = true;
        setTimeout(() => {
            this.grossFlagToAvoidTheTableFromBeingUglyWhenHidingTheToast = false;
        });
    }
    /**
     * \@name toggleLoading
     * \@description display the loading overlay on the table
     * \@memberOf NovoTableElement
     * @param {?} show
     * @return {?}
     */
    toggleLoading(show) {
        this.loading = show;
    }
    /**
     * \@name isColumnHidden
     * \@description hide a column in edit or view mode
     * \@memberOf NovoTableElement
     * @param {?} column
     * @return {?}
     */
    isColumnHidden(column) {
        return this.editing ? !!column.hideColumnOnEdit : !!column.hideColumnOnView;
    }
}
NovoTableElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-table',
                host: {
                    '[attr.theme]': 'theme',
                    '[class.editing]': 'mode === NovoTableMode.EDIT',
                    '[class.novo-table-loading]': 'loading'
                },
                // directives: [],
                template: `
        <header *ngIf="columns.length">
            <ng-content select="novo-table-header"></ng-content>
            <div class="header-actions">
                <novo-pagination *ngIf="config.paging && !(dataProvider.isEmpty() && !dataProvider.isFiltered())"
                                 [rowOptions]="config.paging.rowOptions"
                                 [disablePageSelection]="config.paging.disablePageSelection"
                                 [(page)]="dataProvider.page"
                                 [(itemsPerPage)]="dataProvider.pageSize"
                                 [totalItems]="dataProvider.total"
                                 (onPageChange)="onPageChange($event)">
                </novo-pagination>
                <ng-content select="novo-table-actions"></ng-content>
            </div>
        </header>
        <div class="novo-table-loading-overlay" *ngIf="loading || dataProvider.isLoading()">
            <novo-loading></novo-loading>
        </div>
        <novo-toast *ngIf="toast" [theme]="toast?.theme" [icon]="toast?.icon" [message]="toast?.message"></novo-toast>
        <div class="table-container" *ngIf="!grossFlagToAvoidTheTableFromBeingUglyWhenHidingTheToast">
            <novo-form hideHeader="true" [form]="tableForm">
                <table class="table table-striped dataTable" [class.table-details]="config.hasDetails" role="grid">
                <!-- skipSortAndFilterClear is a hack right now, will be removed once Canvas is refactored -->
                <thead *ngIf="columns.length && (!dataProvider.isEmpty() || dataProvider.isFiltered() || skipSortAndFilterClear || editing)">
                    <tr role="row">
                        <!-- DETAILS -->
                        <th class="row-actions" *ngIf="config.hasDetails">
                            <button theme="icon" icon="next" (click)="expandAllOnPage(config.expandAll)" *ngIf="!config.expandAll" data-automation-id="expand-all"></button>
                            <button theme="icon" icon="sort-desc" (click)="expandAllOnPage(config.expandAll)" *ngIf="config.expandAll" data-automation-id="collapse-all"></button>
                        </th>
                        <!-- CHECKBOX -->
                        <th class="row-actions checkbox mass-action" *ngIf="config.rowSelectionStyle === 'checkbox'">
                            <novo-checkbox [(ngModel)]="master" [indeterminate]="pageSelected.length > 0 && pageSelected.length < pagedData.length" (ngModelChange)="selectPage($event)" data-automation-id="select-all-checkbox" [tooltip]="master ? labels.deselectAll : labels.selectAllOnPage" tooltipPosition="right"></novo-checkbox>
                        </th>
                        <!-- TABLE HEADERS -->
                        <th *ngFor="let column of columns" [ngClass]="{ 'mass-action': config?.rowSelectionStyle === 'checkbox', 'actions': column?.actions?.items?.length > 0, 'preview': column?.name === 'preview' }" [novoThOrderable]="column" (onOrderChange)="onOrderChange($event)" [hidden]="isColumnHidden(column)">
                            <div class="th-group" [attr.data-automation-id]="column.id || column.name" *ngIf="!column.hideHeader">
                                <!-- LABEL & SORT ARROWS -->
                                <div class="th-title" [ngClass]="(config.sorting !== false && column.sorting !== false) ? 'sortable' : ''" [novoThSortable]="config" [column]="column" (onSortChange)="onSortChange($event)">
                                    <label>{{ column.title || column.label }}</label>
                                    <div class="table-sort-icons" tooltipPosition="bottom" [tooltip]="labels.sort" [ngClass]="column.sort || ''" *ngIf="config.sorting !== false && column.sorting !== false">
                                        <i class="bhi-arrow-up"></i>
                                        <i class="bhi-arrow-down"></i>
                                    </div>
                                </div>
                                <!-- FILTER DROP-DOWN -->
                                <novo-dropdown side="right" *ngIf="config.filtering !== false && column.filtering !== false" class="column-filters" (toggled)="onDropdownToggled($event, column.name)" appendToBody="true" parentScrollSelector=".table-container" containerClass="table-dropdown">
                                    <button type="button" theme="icon" icon="filter" tooltipPosition="bottom" [tooltip]="labels.filters" [class.filtered]="column.filter || column.filter===false"></button>
                                    <!-- FILTER OPTIONS LIST -->
                                    <list *ngIf="(column?.options?.length || column?.originalOptions?.length) && column?.type !== 'date' && toggledDropdownMap[column.name]">
                                        <item class="filter-search">
                                            <div class="header">
                                                <span>{{ labels.filters }}</span>
                                                <button theme="dialogue" color="negative" icon="times" (click)="onFilterClear(column)" *ngIf="column.filter || column.filter===false">{{ labels.clear }}</button>
                                            </div>
                                            <input type="text" *ngIf="!!column.allowCustomTextOption" [attr.id]="column.name + '-input'" [novoTableFilter]="column" (onFilterChange)="onFilterKeywords($event)" [(ngModel)]="column.freetextFilter" keepFilterFocused/>
                                        </item>
                                        <item [ngClass]="{ active: isFilterActive(column, option) }" *ngFor="let option of column.options" (click)="onFilterClick(column, option)" [attr.data-automation-id]="getOptionDataAutomationId(option)">
                                            <span>{{ option?.label || option }}</span> <i class="bhi-check" *ngIf="isFilterActive(column, option)"></i>
                                        </item>
                                    </list>
                                    <!-- FILTER SEARCH INPUT -->
                                    <list *ngIf="!(column?.options?.length || column?.originalOptions?.length) && toggledDropdownMap[column.name]">
                                        <item class="filter-search">
                                            <div class="header">
                                                <span>{{ labels.filters }}</span>
                                                <button theme="dialogue" color="negative" icon="times" (click)="onFilterClear(column)" *ngIf="column.filter">{{ labels.clear }}</button>
                                            </div>
                                            <input type="text" [attr.id]="column.name + '-input'" [novoTableFilter]="column" (onFilterChange)="onFilterChange($event)" [(ngModel)]="column.filter" keepFilterFocused/>
                                        </item>
                                    </list>
                                    <!-- FILTER DATE OPTIONS -->
                                    <list *ngIf="column?.options?.length && column?.type === 'date' && toggledDropdownMap[column.name]">
                                        <item class="filter-search" *ngIf="!column.calenderShow">
                                            <div class="header">
                                                <span>{{ labels.filters }}</span>
                                                <button theme="dialogue" color="negative" icon="times" (click)="onFilterClear(column)" *ngIf="column.filter">{{ labels.clear }}</button>
                                            </div>
                                        </item>
                                        <item [ngClass]="{ active: isFilterActive(column, option) }" *ngFor="let option of column.options" (click)="onFilterClick(column, option)" [keepOpen]="option.range" [hidden]="column.calenderShow" [attr.data-automation-id]="(option?.label || option)">
                                            {{ option?.label || option }} <i class="bhi-check" *ngIf="isFilterActive(column, option)"></i>
                                        </item>
                                        <div class="calender-container" [hidden]="!column.calenderShow">
                                            <div (click)="column.calenderShow=false"><i class="bhi-previous"></i>{{ labels.backToPresetFilters }}</div>
                                            <novo-date-picker #rangePicker (onSelect)="onCalenderSelect(column, $event)" [(ngModel)]="column.filter" range="true"></novo-date-picker>
                                        </div>
                                    </list>
                                </novo-dropdown>
                            </div>
                        </th>
                    </tr>
                </thead>
                <!-- TABLE DATA -->
                <tbody *ngIf="!dataProvider.isEmpty() || editing">
                    <tr class="table-selection-row" *ngIf="config.rowSelectionStyle === 'checkbox' && showSelectAllMessage && config.selectAllEnabled" data-automation-id="table-selection-row">
                        <td colspan="100%">
                            {{labels.selectedRecords(selected.length)}} <a (click)="selectAll(true)" data-automation-id="all-matching-records">{{labels.totalRecords(dataProvider.total)}}</a>
                        </td>
                    </tr>
                    <ng-template ngFor let-row="$implicit" let-i="index" [ngForOf]="rows">
                        <tr class="table-row" [ngClass]="row.customClass || ''" [attr.data-automation-id]="row.id" (click)="rowClickHandler(row)" [class.active]="row.id === activeId">
                            <td class="row-actions" *ngIf="config.hasDetails">
                                <button theme="icon" icon="next" (click)="row._expanded=!row._expanded" *ngIf="!row._expanded"></button>
                                <button theme="icon" icon="sort-desc" (click)="row._expanded=!row._expanded" *ngIf="row._expanded"></button>
                            </td>
                            <td class="row-actions checkbox" *ngIf="config.rowSelectionStyle === 'checkbox'">
                                <novo-checkbox [(ngModel)]="row._selected" (ngModelChange)="rowSelectHandler(row)" data-automation-id="select-row-checkbox"></novo-checkbox>
                            </td>
                            <td *ngFor="let column of columns" [attr.data-automation-id]="column.id || column.name" [class.novo-form-row]="editable" [hidden]="isColumnHidden(column)">
                                <novo-table-cell *ngIf="row._editing && !row._editing[column.name]" [hasEditor]="editable" [column]="column" [row]="row" [form]="tableForm.controls.rows.controls[i]"></novo-table-cell>
                                <novo-control *ngIf="row._editing && row._editing[column.name]" condensed="true" [form]="tableForm.controls.rows.controls[i]" [control]="row.controls[column.name]"></novo-control>
                            </td>
                        </tr>
                        <tr class="details-row" *ngIf="config.hasDetails" [hidden]="!row._expanded" [attr.data-automation-id]="'details-row-'+row.id">
                            <td class="row-actions"></td>
                            <td [attr.colspan]="columns.length">
                                <novo-row-details [data]="row" [renderer]="config.detailsRenderer"></novo-row-details>
                            </td>
                        </tr>
                    </ng-template>
                </tbody>
                <!-- NO TABLE DATA PLACEHOLDER -->
                <tbody class="table-message" *ngIf="dataProvider.isEmpty() && !dataProvider.isFiltered() && !editing" data-automation-id="empty-table">
                    <tr>
                        <td colspan="100%">
                            <div #emptymessage><ng-content select="[table-empty-message]"></ng-content></div>
                            <div class="table-empty-message" *ngIf="emptymessage.childNodes.length == 0">
                                <h4><i class="bhi-search-question"></i> {{ labels.emptyTableMessage }}</h4>
                            </div>
                        </td>
                    </tr>
                </tbody>
                <!-- NO MATCHING RECORDS -->
                <tbody class="table-message" *ngIf="dataProvider.isEmpty() && dataProvider.isFiltered()" data-automation-id="empty-table">
                    <tr>
                        <td colspan="100%">
                            <div #nomatchmessage><ng-content select="[table-no-matching-records-message]"></ng-content></div>
                            <div class="no-matching-records" *ngIf="nomatchmessage.childNodes.length == 0">
                                <h4><i class="bhi-search-question"></i> {{ labels.noMatchingRecordsMessage }}</h4>
                            </div>
                        </td>
                    </tr>
                </tbody>
                <!-- TABLE DATA ERROR PLACEHOLDER -->
                <tbody class="table-message" *ngIf="dataProvider.hasErrors()" data-automation-id="table-errors">
                    <tr>
                        <td colspan="100%">
                            <div #errormessage><ng-content select="[table-error-message]"></ng-content></div>
                            <div class="table-error-message" *ngIf="errormessage.childNodes.length == 0">
                                <h4><i class="bhi-caution"></i> {{ labels.erroredTableMessage }}</h4>
                            </div>
                        </td>
                    </tr>
                </tbody>
                <tfoot *ngIf="!config.footers" [ngClass]="dataProvider.length % 2 == 0 ? 'odd' : 'even'">
                    <tr>
                        <td colspan="100%">
                            <ng-content select="novo-table-footer"></ng-content>
                        </td>
                    </tr>
                </tfoot>
                <tfoot *ngFor="let footer of footers;let i = index;" class="novo-table-total-footer">
                    <tr>
                        <td *ngFor="let column of columns" [attr.data-automation-id]="(column.id || column.name) + '-total-' + i">{{ footer[column.name] }}</td>
                    </tr>
                </tfoot>
            </table>
        </novo-form>
    </div>
    `
            },] },
];
/**
 * @nocollapse
 */
NovoTableElement.ctorParameters = () => [
    { type: NovoLabelService, },
    { type: FormUtils, },
    { type: FormBuilder, },
];
NovoTableElement.propDecorators = {
    'config': [{ type: Input },],
    'columns': [{ type: Input },],
    'theme': [{ type: Input },],
    'skipSortAndFilterClear': [{ type: Input },],
    'mode': [{ type: Input },],
    'editable': [{ type: Input },],
    'onRowClick': [{ type: Output },],
    'onRowSelect': [{ type: Output },],
    'onTableChange': [{ type: Output },],
    'rows': [{ type: Input },],
    'dataProvider': [{ type: Input },],
};

// NG2
// Vendor
// APP
class NovoTableModule {
}
NovoTableModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    NovoFormModule,
                    NovoTableExtrasModule,
                    NovoToastModule,
                    NovoButtonModule,
                    NovoTooltipModule,
                    NovoDropdownModule,
                    NovoLoadingModule,
                    NovoDatePickerModule,
                    NovoFormExtrasModule,
                    TextMaskModule
                ],
                declarations: [NovoTableElement],
                exports: [NovoTableElement]
            },] },
];
/**
 * @nocollapse
 */
NovoTableModule.ctorParameters = () => [];

// NG2
//APP
let NOVO_VALUE_TYPE = {};
NOVO_VALUE_TYPE.DEFAULT = 0;
NOVO_VALUE_TYPE.EMAIL = 1;
NOVO_VALUE_TYPE.PHONE = 2;
NOVO_VALUE_TYPE.ENTITY_LIST = 3;
NOVO_VALUE_TYPE.LINK = 4;
NOVO_VALUE_TYPE.INTERNAL_LINK = 5;
NOVO_VALUE_TYPE[NOVO_VALUE_TYPE.DEFAULT] = "DEFAULT";
NOVO_VALUE_TYPE[NOVO_VALUE_TYPE.EMAIL] = "EMAIL";
NOVO_VALUE_TYPE[NOVO_VALUE_TYPE.PHONE] = "PHONE";
NOVO_VALUE_TYPE[NOVO_VALUE_TYPE.ENTITY_LIST] = "ENTITY_LIST";
NOVO_VALUE_TYPE[NOVO_VALUE_TYPE.LINK] = "LINK";
NOVO_VALUE_TYPE[NOVO_VALUE_TYPE.INTERNAL_LINK] = "INTERNAL_LINK";

let NOVO_VALUE_THEME = {};
NOVO_VALUE_THEME.DEFAULT = 0;
NOVO_VALUE_THEME.MOBILE = 1;
NOVO_VALUE_THEME[NOVO_VALUE_THEME.DEFAULT] = "DEFAULT";
NOVO_VALUE_THEME[NOVO_VALUE_THEME.MOBILE] = "MOBILE";

class NovoValuePhone {
    /**
     * @return {?}
     */
    get isMobile() {
        return this.theme === NOVO_VALUE_THEME.MOBILE;
    }
    /**
     * @return {?}
     */
    get showIcon() {
        return !Helpers.isEmpty(this.data);
    }
}
NovoValuePhone.decorators = [
    { type: Component, args: [{
                selector: 'novo-value-phone',
                template: `
        <div class="value-outer">
            <label>{{ meta.label }}</label>
            <a *ngIf="!isMobile" class="value" href="tel:{{data}}" target="_parent">
                {{ data }}
            </a>
            <div *ngIf="isMobile" class="value">{{ data }}</div>
        </div>
        <div class="actions" *ngIf="showIcon">
            <a href="tel:{{data}}"><i class="bhi-phone"></i></a>
            <a href="sms:{{data}}"><i class="bhi-sms"></i></a>
        </div>
    `
            },] },
];
/**
 * @nocollapse
 */
NovoValuePhone.ctorParameters = () => [];
NovoValuePhone.propDecorators = {
    'data': [{ type: Input },],
    'meta': [{ type: Input },],
    'theme': [{ type: Input },],
    'isMobile': [{ type: HostBinding, args: ['class.mobile',] },],
};
class NovoValueEmail {
    /**
     * @return {?}
     */
    get isMobile() {
        return this.theme === NOVO_VALUE_THEME.MOBILE;
    }
    /**
     * @param {?} data
     * @return {?}
     */
    openEmail(data) {
        if (this.meta && this.meta.openEmail && typeof this.meta.openEmail === 'function') {
            this.meta.openEmail(data);
        }
        else {
            let /** @type {?} */ newTab = window.open('', '_blank', '', true);
            if (newTab) {
                newTab.location.replace(`mailto:${encodeURIComponent(data)}`);
                // Self close for desktop clients
                setTimeout(() => {
                    try {
                        if (newTab.location.href === 'about:blank') {
                            newTab.close();
                        }
                    }
                    catch (error) {
                        // No op, browser handled the mailto link
                    }
                });
            }
        }
        if (Helpers.isEmpty(this.theme)) {
            this.theme = NOVO_VALUE_THEME.DEFAULT;
        }
    }
    /**
     * @return {?}
     */
    get showIcon() {
        return !Helpers.isEmpty(this.data);
    }
}
NovoValueEmail.decorators = [
    { type: Component, args: [{
                selector: 'novo-value-email',
                template: `
        <div class="value-outer">
            <label>{{ meta.label }}</label>
            <a *ngIf="!isMobile"  class="value" (click)="openEmail(data)"> {{ data }}</a>
            <div *ngIf="isMobile" class="value">{{ data }}</div>
        </div>
        <i class="bhi-email actions" *ngIf="showIcon" (click)="openEmail(data)"></i>
    `
            },] },
];
/**
 * @nocollapse
 */
NovoValueEmail.ctorParameters = () => [];
NovoValueEmail.propDecorators = {
    'data': [{ type: Input },],
    'meta': [{ type: Input },],
    'theme': [{ type: Input },],
    'isMobile': [{ type: HostBinding, args: ['class.mobile',] },],
};
class NovoValueElement {
    constructor() {
        this.theme = NOVO_VALUE_THEME.DEFAULT;
        this.NOVO_VALUE_TYPE = NOVO_VALUE_TYPE;
        this.NOVO_VALUE_THEME = NOVO_VALUE_THEME;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (Helpers.isEmpty(this.meta)) {
            this.meta = {
                label: ''
            };
        }
    }
    /**
     * @return {?}
     */
    get isMobile() {
        return this.theme === NOVO_VALUE_THEME.MOBILE;
    }
    /**
     * @return {?}
     */
    get iconClass() {
        if (this.meta && this.meta.icon) {
            return `bhi-${this.meta.icon} actions`;
        }
        return '';
    }
    /**
     * @return {?}
     */
    get isDefault() {
        return true;
    }
    /**
     * @return {?}
     */
    get showLabel() {
        return this.type === NOVO_VALUE_TYPE.INTERNAL_LINK || this.type === NOVO_VALUE_TYPE.LINK;
    }
    /**
     * @return {?}
     */
    get showIcon() {
        return this.meta && this.meta.icon && !Helpers.isEmpty(this.data);
    }
    /**
     * @return {?}
     */
    onValueClick() {
        if (this.meta && this.meta.onIconClick && typeof this.meta.onIconClick === 'function') {
            this.meta.onIconClick(this.data, this.meta);
        }
    }
    /**
     * @return {?}
     */
    openLink() {
        if (this.meta && this.meta.openLink && typeof this.meta.openLink === 'function') {
            this.meta.openLink(this.data, this.meta);
        }
    }
    /**
     * @param {?=} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (this.meta && this.isEmailField(this.meta)) {
            this.type = NOVO_VALUE_TYPE.EMAIL;
        }
        else if (this.meta && this.isPhoneField(this.meta)) {
            this.type = NOVO_VALUE_TYPE.PHONE;
        }
        else if (this.meta && this.isLinkField(this.meta, this.data)) {
            this.type = NOVO_VALUE_TYPE.LINK;
            // Make sure the value has a protocol, otherwise the URL will be relative
            let /** @type {?} */ hasProtocol = new RegExp('^(http|https)://', 'i');
            if (!hasProtocol.test(this.data)) {
                this.url = `http://${this.data}`;
            }
            else {
                this.url = this.data;
            }
        }
        else if (this.meta && this.meta.associatedEntity) {
            switch (this.meta.associatedEntity.entity) {
                case 'ClientCorporation':
                case 'ClientContact':
                case 'Candidate':
                case 'JobOrder':
                case 'Placement':
                    this.type = NOVO_VALUE_TYPE.INTERNAL_LINK;
                    break;
                default:
                    break;
            }
        }
    }
    /**
     * @param {?} field
     * @return {?}
     */
    isEmailField(field) {
        const /** @type {?} */ emailFields = ['email', 'email2', 'email3'];
        return emailFields.indexOf(field.name) > -1 || field.type === NOVO_VALUE_TYPE.EMAIL;
    }
    /**
     * @param {?} field
     * @return {?}
     */
    isPhoneField(field) {
        let /** @type {?} */ phoneFields = ['phone', 'phone2', 'phone3', 'pager', 'mobile', 'workPhone', 'billingPhone'];
        return phoneFields.indexOf(field.name) > -1 || field.type === NOVO_VALUE_TYPE.PHONE;
    }
    /**
     * @param {?} field
     * @param {?} data
     * @return {?}
     */
    isLinkField(field, data) {
        let /** @type {?} */ linkFields = ['companyURL', 'clientCorporationCompanyURL'];
        let /** @type {?} */ regex = new RegExp('^(https?:\/\/(?:www\.|(?!www))[^\s\.]+\.[^\s]{2,}|www\.[^\s]+\.[^\s]{2,})$', 'gi');
        let /** @type {?} */ isURL = Helpers.isString(data) && regex.exec(data.trim());
        return (linkFields.indexOf(field.name) > -1) || !!isURL || field.type === NOVO_VALUE_TYPE.LINK;
    }
}
NovoValueElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-value',
                template: `
        <ng-container [ngSwitch]="type">
            <div class="value-outer" *ngIf="showLabel">
                <label>{{ meta.label }}</label>
                <a *ngSwitchCase="NOVO_VALUE_TYPE.INTERNAL_LINK" class="value" (click)="openLink()" [innerHTML]="data | render : meta"></a>
                <a *ngSwitchCase="NOVO_VALUE_TYPE.LINK" class="value" [href]="url" target="_blank" [innerHTML]="data | render : meta"></a>
            </div>

            <novo-value-phone *ngSwitchCase="NOVO_VALUE_TYPE.PHONE" [data]="data" [theme]="theme" [meta]="meta"></novo-value-phone>
            <novo-value-email *ngSwitchCase="NOVO_VALUE_TYPE.EMAIL" [data]="data" [theme]="theme" [meta]="meta"></novo-value-email>

            <div *ngSwitchDefault class="value-outer">
                <label>{{ meta.label }}</label>
                <div *ngIf="isDefault" class="value" [innerHTML]="data | render : meta"></div>
            </div>
            <i *ngIf="showIcon" [class]="iconClass" (click)="onValueClick()"></i>
        </ng-container>
    `
            },] },
];
/**
 * @nocollapse
 */
NovoValueElement.ctorParameters = () => [];
NovoValueElement.propDecorators = {
    'data': [{ type: Input },],
    'meta': [{ type: Input },],
    'theme': [{ type: Input },],
    'isMobile': [{ type: HostBinding, args: ['class.mobile',] },],
};

/**
 * Basic Utility for common Entity functions
 */
class EntityUtils {
    /**
     * @return {?}
     */
    static get ENTITY_TYPES() {
        return [
            'Lead',
            'ClientContact',
            'ClientCorporation',
            'Opportunity',
            'Note',
            'Task',
            'DistributionList',
        ];
    }
    /**
     * @return {?}
     */
    static get PERSON_SUBTYPES() {
        return [
            'Lead',
            'ClientContact',
            'Candidate',
            'CorporateUser',
        ];
    }
    /**
     * @return {?}
     */
    static get ENTITY_SHORT_NAMES() {
        return {
            Lead: 'lead',
            ClientContact: 'contact',
            ClientCorporation: 'company',
            Opportunity: 'opportunity',
            Task: 'task',
            Note: 'note',
            CorporateUser: 'user',
            Candidate: 'candidate',
            JobOrder: 'job',
            Placement: 'placement',
            JobSubmission: 'submission',
            DistributionList: 'distributionList',
        };
    }
    /**
     * @return {?}
     */
    static get ENTITY_LONG_NAMES() {
        return {
            lead: 'Lead',
            contact: 'ClientContact',
            company: 'ClientCorporation',
            opportunity: 'Opportunity',
            user: 'CorporateUser',
            task: 'Task',
            note: 'Note',
            distributionList: 'DistributionList',
            candidate: 'Candidate',
            job: 'JobOrder',
            placement: 'Placement',
            submission: 'JobSubmission',
            references: 'CandidateReference',
            appointment: 'Appointment',
        };
    }
    /**
     * @return {?}
     */
    static get ENTITY_LUCENE_QUERY_NAMES() {
        return {
            Lead: 'lead',
            ClientContact: 'clientContact',
            ClientCorporation: 'clientCorporation',
            Opportunity: 'opportunity',
            Task: 'task',
            Note: 'note',
            DistributionList: 'distributionList',
            Candidate: 'candidate',
            JobOrder: 'jobOrder',
            Placement: 'placement',
            JobSubmission: 'jobSubmission',
            CandidateReference: 'candidateReference',
        };
    }
    /**
     * @return {?}
     */
    static get ENTITY_LUCENE_QUERY_NAMES_PLURAL() {
        return {
            Lead: 'leads',
            ClientContact: 'clientContacts',
            ClientCorporation: 'clientCorporations',
            Opportunity: 'opportunities',
            Task: 'tasks',
            Note: 'notes',
            DistributionList: 'distributionLists',
            Candidate: 'candidates',
            JobOrder: 'jobOrders',
            Placement: 'placements',
            JobSubmission: 'jobSubmissions',
            CandidateReference: 'candidateReferences',
        };
    }
    /**
     * @return {?}
     */
    static get NOTE_LUCENE_QUERY_NAMES() {
        return {
            ClientContact: 'clientContactUser',
            Candidate: 'candidateUser',
            Lead: 'leadUser',
            JobOrder: 'jobOrder',
            Placement: 'placement',
            Opportunity: 'opportunity',
        };
    }
    /**
     * @return {?}
     */
    static get ENTITY_ICONS() {
        return {
            Appointment: 'appointment',
            Candidate: 'candidate',
            CandidateEducation: 'education',
            CandidateReference: 'users',
            CandidateWorkHistory: 'job',
            ClientContact: 'person',
            ClientCorporation: 'company',
            CustomObject: 'custom-objects',
            DistributionList: 'users',
            JobOrder: 'job',
            Lead: 'lead',
            Note: 'note',
            Opportunity: 'opportunity',
            Placement: 'star',
            Task: 'check-o',
            JobSubmission: 'star-o',
            Sendout: 'sendout',
            PlacementChangeRequest: 'republish',
        };
    }
    /**
     * @return {?}
     */
    static get ENTITY_ICONS_FROM_PATH() {
        return {
            'activity': 'activity',
            'email': 'email',
            'work-history': 'clock-arrow',
            'education': 'education',
            'references': 'users',
            'notes': 'note',
            'files': 'file',
            'linkedin': 'linkedin-f',
        };
    }
    /**
     * @param {?} name
     * @return {?}
     */
    static getShortName(name) {
        return this.ENTITY_SHORT_NAMES[name];
    }
    /**
     * @param {?} name
     * @return {?}
     */
    static getLuceneName(name) {
        return this.ENTITY_LUCENE_QUERY_NAMES[name];
    }
    /**
     * @param {?} name
     * @return {?}
     */
    static getNoteLuceneName(name) {
        return this.NOTE_LUCENE_QUERY_NAMES[name];
    }
    /**
     * @param {?} name
     * @return {?}
     */
    static getLongName(name) {
        return this.ENTITY_LONG_NAMES[name];
    }
    /**
     * @param {?} longName
     * @return {?}
     */
    static getIcon(longName) {
        return this.ENTITY_ICONS[longName];
    }
    /**
     * @param {?} result
     * @return {?}
     */
    static getNameForResult(result) {
        return this.getEntityLabel(result, result.searchEntity);
    }
    /**
     * @param {?} item
     * @param {?} entity
     * @return {?}
     */
    static getEntityLabel(item, entity) {
        switch (entity) {
            case 'CorporateUser':
            case 'ClientContact':
            case 'Lead':
            case 'Candidate':
            case 'Person':
                return `${item.firstName || ''} ${item.lastName || ''}`.trim();
            case 'ClientCorporation':
                return `${item.name || ''}`.trim();
            case 'JobOrder':
            case 'Opportunity':
                return `${item.title || ''}`.trim();
            case 'Placement':
                let /** @type {?} */ label = '';
                if (item.candidate) {
                    label = `${item.candidate.firstName} ${item.candidate.lastName}`.trim();
                }
                if (item.jobOrder) {
                    label = `${label} - ${item.jobOrder.title}`.trim();
                }
                return label;
            default:
                return '';
        }
    }
    /**
     * @param {?} entity
     * @return {?}
     */
    static getEntityThemeColor(entity) {
        switch (entity) {
            case 'PlacementChangeRequest':
                return 'neutral';
            default:
                return this.getShortName(entity) || entity.toLowerCase();
        }
    }
    /**
     * @param {?} entityType
     * @return {?}
     */
    static getAssociationName(entityType) {
        return entityType.charAt(0).toLowerCase() + entityType.slice(1);
    }
    /**
     * @param {?} entity
     * @param {?} id
     * @param {?} title
     * @return {?}
     */
    static formatSubject(entity, id, title) {
        return `${entity} #${id}: ${title}`;
    }
}

// NG2
// APP
/**
 * \@class RenderPipe
 * \@classdesc
 * Renders data appropriately based on the data type found in Meta
 * All data types defined by bullhorn should be supported:
 *
 * - **String**: trims value and returns
 * - **Integer**: return value
 * - **Double**: return value fixed to 2 decimals
 * - **BigDecimal**: return value fixed to 2 decimals
 * - **Address**: only city and/or state returned
 * - **Address1**: only city and/or state returned
 * - **AddressWithoutCountry**: only city and/or state returned
 * - **Currency**: put a $ in front
 * - **Percentage**: divide by 100 fix to 2 decimals place and return
 * - **Options**: returns the appropriate 'label' for the 'value' from 'options'
 * - **Array**: returns list comma separated
 * - **DateTime**: formats the date
 * - **TimeStamp**: formats the date
 * - **ToOne**: return the entity specific name (ie. name, firstName lastName, title, ...)
 * - **ToMany**: return an array of the entity specific names (ie. name, firstName lastName, title, ...)
 *
 * \@example
 * ```
 * {{ expression | render:field }}
 * ```
 */
class RenderPipe {
    /**
     * @param {?} changeDetector
     * @param {?} sanitizationService
     * @param {?} labels
     */
    constructor(changeDetector, sanitizationService, labels) {
        this.changeDetector = changeDetector;
        this.sanitizationService = sanitizationService;
        this.labels = labels;
    }
    /**
     * @param {?} objectOne
     * @param {?} objectTwo
     * @return {?}
     */
    equals(objectOne, objectTwo) {
        if (objectOne === objectTwo) {
            return true;
        }
        if (objectOne === null || objectTwo === null) {
            return false;
        }
        if (objectOne !== objectOne && objectTwo !== objectTwo) {
            return true;
        }
        let /** @type {?} */ t1 = typeof objectOne;
        let /** @type {?} */ t2 = typeof objectTwo;
        let /** @type {?} */ length;
        let /** @type {?} */ key;
        let /** @type {?} */ keySet;
        if (t1 === t2 && t1 === 'object') {
            if (Array.isArray(objectOne)) {
                if (!Array.isArray(objectTwo)) {
                    return false;
                }
                length = objectOne.length;
                if (length === objectTwo.length) {
                    for (key = 0; key < length; key++) {
                        if (!this.equals(objectOne[key], objectTwo[key])) {
                            return false;
                        }
                    }
                    return true;
                }
            }
            else {
                if (Array.isArray(objectTwo)) {
                    return false;
                }
                keySet = Object.create(null);
                for (key in objectOne) {
                    if (objectOne[key]) {
                        if (!this.equals(objectOne[key], objectTwo[key])) {
                            return false;
                        }
                        keySet[key] = true;
                    }
                }
                for (key in objectTwo) {
                    if (!(key in keySet) && typeof objectTwo[key] !== 'undefined') {
                        return false;
                    }
                }
                return true;
            }
        }
        return false;
    }
    /**
     * Define the fields to set or retrieve for the given entity. Getter and Setter methods will automagically
     * be set up on the entity once the fields are defined.
     * \@name fields
     * \@memberOf Entity#
     * @param {?} value
     * @param {?} args
     * @return {?} text
     */
    render(value, args) {
        let /** @type {?} */ type = null;
        let /** @type {?} */ text = value;
        if (value && value._subtype && !args) {
            return EntityUtils.getEntityLabel(value, value._subtype);
        }
        // Stop logic for nulls
        if (value === undefined || value === null || !args) {
            return text;
        }
        if (args.formatter && (typeof args.formatter === 'function')) {
            return args.formatter(value, args);
        }
        // TODO move this to a service
        // Determine TYPE because its not just 1 value that determines this.
        if (args.type === 'TO_MANY') {
            type = 'ToMany';
        }
        else if (args.type === 'TO_ONE') {
            type = args.associatedEntity.entity;
        }
        else if (args.dataSpecialization === 'DATETIME') {
            type = 'DateTime';
        }
        else if (args.dataSpecialization === 'YEAR') {
            type = 'Year';
        }
        else if (args.dataType === 'Timestamp') {
            type = 'Timestamp';
        }
        else if (['mobile', 'phone', 'phone1', 'phone2', 'phone3', 'workPhone'].indexOf(args.name) > -1) {
            type = 'Phone';
        }
        else if (args.name && args.name.substring(0, 5) === 'email') {
            type = 'Email';
        }
        else if (args.name && args.name === 'address.countryID' || args.optionsType === 'Country') {
            type = 'Country';
        }
        else if (args.optionsType === 'SkillText') {
            type = 'SkillText';
        }
        else if (args.options || args.inputType === 'SELECT') {
            type = 'Options';
        }
        else if (['MONEY', 'PERCENTAGE', 'HTML', 'SSN'].indexOf(args.dataSpecialization) > -1) {
            type = this.capitalize(args.dataSpecialization.toLowerCase());
        }
        else {
            type = args.dataType || 'default';
        }
        // Transform data here
        switch (type) {
            case 'Address':
            case 'Address1':
            case 'AddressWithoutCountry':
                let /** @type {?} */ country = findByCountryId(Number(value.countryName));
                text = `
                    ${value.address1 || ''}
                    ${value.address2 || ''}<br />
                `.trim();
                text += `
                    ${value.city || ''} ${value.state || ''} ${value.zip || ''}${value.city || value.state || value.zip ? '<br />' : ''}
                    ${country ? country.name : (value.countryName || '')}${country || value.countryName ? '<br />' : ''}
                `;
                text = this.sanitizationService.bypassSecurityTrustHtml(text.trim());
                break;
            case 'DateTime':
            case 'Timestamp':
                text = this.labels.formatDateShort(value);
                break;
            case 'Year':
                text = new Date(value).getFullYear();
                break;
            case 'Phone':
            case 'Email':
                text = value;
                break;
            case 'Money':
                text = this.labels.formatCurrency(value);
                break;
            case 'Percentage':
                text = this.labels.formatNumber((parseFloat(value)).toString(), { style: 'percent', minimumFractionDigits: 2 });
                break;
            case 'Double':
            case 'BigDecimal':
                text = this.labels.formatNumber(value, { minimumFractionDigits: this.getNumberDecimalPlaces(value) });
                break;
            case 'Integer':
                text = value;
                break;
            case 'BusinessSector':
            case 'Category':
            case 'Certification':
            case 'ClientCorporation':
            case 'CorporationDepartment':
            case 'DistributionList':
            case 'Skill':
            case 'Tearsheet':
            case 'Specialty':
                text = value.label || value.name || '';
                break;
            case 'SkillText':
                text = Array.isArray(value) ? value.join(', ') : value;
                break;
            case 'Lead':
            case 'Candidate':
            case 'ClientContact':
            case 'CorporateUser':
            case 'Person':
                text = value.label || `${value.firstName || ''} ${value.lastName || ''}`;
                break;
            case 'Opportunity':
            case 'JobOrder':
            case 'Placement':
                text = value.label || value.title || '';
                break;
            case 'JobSubmission':
                text = value.label || `${value.jobOrder ? `${value.jobOrder.title} - ` : ''} ${value.candidate ? value.candidate.firstName : ''} ${value.candidate ? value.candidate.lastName : ''}`;
                break;
            case 'WorkersCompensationRate':
                text = `${value.compensation ? `${value.compensation.code} - ` : ''} ${value.compensation ? value.compensation.name : ''}`;
                break;
            case 'Options':
                text = this.options(value, args.options);
                break;
            case 'ToMany':
                if (['Candidate', 'CorporateUser', 'Person'].indexOf(args.associatedEntity.entity) > -1) {
                    text = this.concat(value.data, 'firstName', 'lastName');
                    if (value.data.length < value.total) {
                        text = text + ', ' + this.labels.getToManyPlusMore({ quantity: value.total - value.data.length });
                    }
                }
                else if (['Category', 'BusinessSector', 'Skill', 'Specialty', 'ClientCorporation', 'CorporationDepartment'].indexOf(args.associatedEntity.entity) > -1) {
                    text = this.concat(value.data, 'name');
                    if (value.data.length < value.total) {
                        text = text + ', ' + this.labels.getToManyPlusMore({ quantity: value.total - value.data.length });
                    }
                }
                else if (args.associatedEntity.entity === 'MailListPushHistoryDetail') {
                    text = this.concat(value.data, 'externalListName');
                }
                else {
                    text = `${value.total || ''}`;
                }
                break;
            case 'Country':
                let /** @type {?} */ countryObj = findByCountryId(Number(value));
                text = countryObj ? countryObj.name : value;
                break;
            case 'Html':
                if (Array.isArray(value)) {
                    value = value.join(' ');
                }
                text = this.sanitizationService.bypassSecurityTrustHtml(value.replace(/\<a/gi, '<a target="_blank"'));
                break;
            case 'CandidateComment':
                text = value.comments ? `${this.labels.formatDateShort(value.dateLastModified)} (${value.name}) - ${value.comments}` : '';
                break;
            default:
                text = value.trim ? value.trim() : value;
                break;
        }
        return text;
    }
    /**
     * @param {?} value
     * @param {?} args
     * @return {?}
     */
    updateValue(value, args) {
        this.value = this.render(value, args);
        this.changeDetector.markForCheck();
    }
    /**
     * @param {?=} value
     * @param {?=} args
     * @return {?}
     */
    transform(value, args) {
        if (value === undefined || value === null) {
            return '';
        }
        if (this.equals(value, this.lastValue) && this.equals(args, this.lastArgs)) {
            return this.value;
        }
        this.lastValue = value;
        this.lastArgs = args;
        this.updateValue(this.lastValue, this.lastArgs);
        return this.value;
    }
    /**
     * Simple function concat a list of fields from a list of objects
     * \@name options
     * @param {?} list
     * @param {...?} fields
     * @return {?}
     */
    concat(list, ...fields) {
        let /** @type {?} */ data = [];
        for (let /** @type {?} */ item of list) {
            let /** @type {?} */ label = [];
            for (let /** @type {?} */ field of fields) {
                label.push(`${item[field]}`);
            }
            data.push(label.join(' '));
        }
        return data.join(', ');
    }
    /**
     * Simple function to look up the **label** to display from options
     * \@name options
     * @param {?} value
     * @param {?} list
     * @return {?}
     */
    options(value, list) {
        try {
            for (const /** @type {?} */ item of list) {
                if (item.value === value) {
                    return item.label;
                }
            }
        }
        catch (e) {
            // do nothing
        }
        return value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    getNumberDecimalPlaces(value) {
        let /** @type {?} */ decimalPlaces;
        if (value) {
            let /** @type {?} */ numberString = parseFloat(value).toString();
            let /** @type {?} */ decimalPlace = (numberString || '').split('.')[1] || '';
            decimalPlaces = decimalPlace.length;
        }
        return decimalPlaces || 1;
    }
    /**
     * Capitalizes the first letter
     * @param {?} value
     * @return {?}
     */
    capitalize(value) {
        return value.charAt(0).toUpperCase() + value.slice(1);
    }
}
RenderPipe.decorators = [
    { type: Pipe, args: [{
                name: 'render',
                pure: false,
            },] },
    { type: Injectable },
];
/**
 * @nocollapse
 */
RenderPipe.ctorParameters = () => [
    { type: ChangeDetectorRef, },
    { type: DomSanitizer, },
    { type: NovoLabelService, },
];

// NG2
// APP
class NovoValueModule {
}
NovoValueModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                declarations: [NovoValueElement, NovoValueEmail, NovoValuePhone, RenderPipe],
                exports: [NovoValueElement, NovoValueEmail, NovoValuePhone, RenderPipe]
            },] },
];
/**
 * @nocollapse
 */
NovoValueModule.ctorParameters = () => [];

// NG2
// APP
class NovoCategoryDropdownElement extends OutsideClick {
    /**
     * @param {?} element
     * @param {?} labels
     */
    constructor(element, labels) {
        super(element);
        this.labels = labels;
        this._query = '';
        this._categoryMap = {};
        this._categories = [];
        // Boolean to keep the selection persist when closing the dropdown
        this.persistSelection = false;
        // Boolean to close the dropdown on selection
        this.closeOnSelect = false;
        // Event that is emitted whenever an item is selected
        this._select = new EventEmitter();
        // Event that is emitted whenever a category is selected
        this.categorySelected = new EventEmitter();
        this.clickHandler = this.toggleActive.bind(this);
    }
    /**
     * @param {?} categories
     * @return {?}
     */
    set categories(categories) {
        this._masterCategoryMap = Object.assign({}, categories);
        this._categoryMap = Object.assign({}, categories);
        this._categories = Object.keys(categories);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        let /** @type {?} */ button = this.element.nativeElement.querySelector('button');
        button.addEventListener('click', this.clickHandler);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        let /** @type {?} */ button = this.element.nativeElement.querySelector('button');
        if (button) {
            button.removeEventListener('click', this.clickHandler);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onKeyDown(event) {
        if (this.active && (event.keyCode === KeyCodes.ESC || event.keyCode === KeyCodes.ENTER)) {
            this.toggleActive();
        }
    }
    /**
     * @return {?}
     */
    clearSelection() {
        this._categories.forEach(category => {
            this._categoryMap[category].forEach(item => {
                item.selected = false;
            });
        });
    }
    /**
     * @param {?} event
     * @param {?} item
     * @return {?}
     */
    select(event, item) {
        Helpers.swallowEvent(event);
        // If we persist the selection, clear and show a check
        if (this.persistSelection) {
            this.clearSelection();
            item.selected = true;
        }
        // Emit the item
        this._select.emit(item);
        // Close, if input is set
        if (this.closeOnSelect) {
            this.toggleActive();
        }
    }
    /**
     * @param {?} category
     * @return {?}
     */
    onCategorySelected(category) {
        this.categorySelected.emit(category);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    clearQuery(event) {
        Helpers.swallowEvent(event);
        this._query = '';
        // Reset the categories
        this._categories.forEach(category => {
            this._categoryMap[category] = this._masterCategoryMap[category];
        });
    }
    /**
     * @param {?} query
     * @return {?}
     */
    queryCategories(query) {
        // Save the query
        this._query = query;
        // Check timeout
        if (this._queryTimeout) {
            clearTimeout(this._queryTimeout);
        }
        // Store a timeout, to debounce user input
        this._queryTimeout = setTimeout(() => {
            this._categories.forEach(category => {
                if (this.search.compare) {
                    this._categoryMap[category] = this._masterCategoryMap[category].filter(item => this.search.compare(query, item));
                }
                else {
                    this._categoryMap[category] = this._masterCategoryMap[category].filter(item => ~item.label.toLowerCase().indexOf(query.toLowerCase()));
                }
            });
        }, this.search.debounce || 300);
    }
    /**
     * @param {?} event
     * @param {?} link
     * @return {?}
     */
    executeClickCallback(event, link) {
        link.callback(event);
        // Close, if input is set
        if (this.closeOnSelect) {
            this.toggleActive();
        }
    }
}
NovoCategoryDropdownElement.decorators = [
    { type: Component, args: [{
                selector: 'novo-category-dropdown',
                template: `
        <ng-content select="button"></ng-content>
        <div class="dropdown-container" *ngIf="active">
            <div class="novo-category-dropdown-search" *ngIf="search" data-automation-id="novo-category-dropdown-search">
                <input type="text" [placeholder]="search.placeholder || labels.search" [value]="_query" (input)="queryCategories($event.target.value)"/>
                <i class="bhi-search" *ngIf="!_query"></i>
                <i class="bhi-times" *ngIf="_query" (click)="clearQuery($event)"></i>
            </div>
            <novo-nav theme="white" [outlet]="novoCategoryDropdownOutlet" direction="vertical">
                <novo-tab *ngFor="let category of _categories" [attr.data-automation-id]="category" (activeChange)="onCategorySelected(category)">
                    <span>{{ category }} ({{ _categoryMap[category].length }})</span>
                </novo-tab>
            </novo-nav>
            <novo-nav-outlet #novoCategoryDropdownOutlet>
                <novo-nav-content *ngFor="let category of _categories">
                    <novo-list direction="vertical">
                        <novo-list-item *ngFor="let item of _categoryMap[category]" (click)="select($event, item)" [attr.data-automation-id]="item.label">
                            <item-content>{{ item.label }}</item-content>
                            <item-end class="novo-category-dropdown-hover" *ngIf="item.hoverText && !item.selected">{{ item.hoverText }}</item-end>
                            <item-end class="novo-category-dropdown-hover" *ngIf="item.hoverIcon && !item.selected"><i class="bhi-{{ item.hoverIcon }}"></i></item-end>
                            <item-end *ngIf="item.selected"><i class="bhi-check"></i></item-end>
                        </novo-list-item>
                        <novo-list-item *ngIf="_categoryMap[category].length === 0 && search" class="novo-category-dropdown-empty-item">
                            <item-content>{{ search.emptyMessage || labels.noItems }}</item-content>
                        </novo-list-item>
                    </novo-list>
                </novo-nav-content>
            </novo-nav-outlet>
            <footer *ngIf="footer" class="novo-category-dropdown-footer-align-{{ footer.align || 'right' }}">
                <a *ngFor="let link of footer.links" (click)="executeClickCallback($event, link)">{{ link.label }}</a>
            </footer>
        </div>
    `,
                host: {
                    '(keydown)': 'onKeyDown($event)',
                    '[class.active]': 'active'
                }
            },] },
];
/**
 * @nocollapse
 */
NovoCategoryDropdownElement.ctorParameters = () => [
    { type: ElementRef, },
    { type: NovoLabelService, },
];
NovoCategoryDropdownElement.propDecorators = {
    'persistSelection': [{ type: Input },],
    'closeOnSelect': [{ type: Input },],
    'search': [{ type: Input },],
    'footer': [{ type: Input },],
    '_select': [{ type: Output, args: ['itemSelected',] },],
    'categorySelected': [{ type: Output },],
    'categories': [{ type: Input },],
};

// NG2
// APP
class NovoCategoryDropdownModule {
}
NovoCategoryDropdownModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, NovoTabModule, NovoListModule],
                declarations: [NovoCategoryDropdownElement],
                exports: [NovoCategoryDropdownElement]
            },] },
];
/**
 * @nocollapse
 */
NovoCategoryDropdownModule.ctorParameters = () => [];

// NG2
// Vendor
// Value accessor for the component (supports ngModel)
const CHIPS_VALUE_ACCESSOR$1 = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => NovoMultiPickerElement),
    multi: true
};
class NovoMultiPickerElement {
    /**
     * @param {?} element
     * @param {?} labels
     */
    constructor(element, labels) {
        this.element = element;
        this.labels = labels;
        this.placeholder = '';
        this.changed = new EventEmitter();
        this.focus = new EventEmitter();
        this.blur = new EventEmitter();
        this.items = [];
        this._items = new ReplaySubject$1(1);
        this.selected = null;
        this.config = {};
        // private data model
        this._value = {};
        this.notShown = {};
        this.onModelChange = () => {
        };
        this.onModelTouched = () => {
        };
        this.chipsCount = 4;
    }
    /**
     * @return {?}
     */
    get value() {
        return this._value;
    }
    /**
     * @param {?} selectedItems
     * @return {?}
     */
    set value(selectedItems) {
        if (selectedItems) {
            this.types.forEach(x => this._value[x.value] = selectedItems[x.value]);
        }
        else {
            this._value = {};
            this.types.forEach(x => this._value[x.value] = []);
        }
        this.changed.emit(selectedItems);
        this.onModelChange(selectedItems);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.selectAllOption = this.source.selectAllOption || false;
        this.chipsCount = this.source.chipsCount || 4;
        this.strictRelationship = this.source.strictRelationship || false;
        this.setupOptions();
    }
    /**
     * @return {?}
     */
    clearValue() {
        this.types.forEach(type => this.modifyAllOfType(type.value, 'unselect'));
        this.items = [];
        this._items.next(this.items);
        this.value = this.setInitialValue(null);
        this.onModelChange(this.value);
    }
    /**
     * @param {?} event
     * @param {?} item
     * @return {?}
     */
    removeFromDisplay(event, item) {
        this.remove(true, item);
        this.modifyAffectedParentsOrChildren(false, item);
    }
    /**
     * @return {?}
     */
    setupOptions() {
        this.options = this.source.options || [];
        this._options = [];
        if (this.options) {
            this.options.forEach(option => {
                let /** @type {?} */ formattedOption = this.setupOptionsByType(option);
                this._options.push(formattedOption);
            });
        }
        this.source.options = this._options;
    }
    /**
     * @param {?} section
     * @return {?}
     */
    setupOptionsByType(section) {
        let /** @type {?} */ formattedSection = {
            type: section.type,
            label: section.label || section.type
        };
        formattedSection.data = section.data.map(item => {
            return this.formatOption(section, item);
        });
        if (this.selectAllOption) {
            let /** @type {?} */ selectAll = this.createSelectAllOption(section);
            formattedSection.data.splice(0, 0, selectAll);
        }
        formattedSection.originalData = formattedSection.data.slice();
        return formattedSection;
    }
    /**
     * @param {?} section
     * @param {?} item
     * @return {?}
     */
    formatOption(section, item) {
        let /** @type {?} */ obj = {
            value: section.field ? item[section.field] : (item.value || item),
            label: section.format ? Helpers.interpolate(section.format, item) : item.label || String(item.value || item),
            type: section.type,
            checked: undefined,
            isParentOf: section.isParentOf,
            isChildOf: section.isChildOf
        };
        if (obj.isChildOf) {
            obj[section.isChildOf] = item[section.isChildOf];
        }
        return obj;
    }
    /**
     * @param {?} section
     * @return {?}
     */
    createSelectAllOption(section) {
        let /** @type {?} */ selectAll = {
            value: 'ALL',
            label: `All ${section.type}`,
            type: section.type,
            checked: (this.model && this.model.length && (this.model.indexOf('ALL') !== -1)),
            isParentOf: section.isParentOf,
            isChildOf: section.isChildOf
        };
        if (section.isChildOf) {
            let /** @type {?} */ allParents = section.data.reduce((accum, next) => {
                return accum.concat(next[section.isChildOf]);
            }, []);
            selectAll[section.isChildOf] = allParents;
        }
        return selectAll;
    }
    /**
     * @return {?}
     */
    deselectAll() {
        this.selected = null;
    }
    /**
     * @param {?} event
     * @param {?} item
     * @return {?}
     */
    select(event, item) {
        this.blur.emit(event);
        this.deselectAll();
        this.selected = item;
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onFocus(e) {
        this.element.nativeElement.classList.add('selected');
        this.focus.emit(e);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    clickOption(event) {
        if (event && !(event instanceof Event)) {
            if (event.checked === false) {
                this.remove(null, event);
            }
            else {
                this.add(event);
            }
            this.modifyAffectedParentsOrChildren(event.checked, event);
            // Set focus on the picker
            let /** @type {?} */ input = this.element.nativeElement.querySelector('novo-picker > input');
            if (input) {
                input.focus();
            }
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    add(event) {
        if (event.value === 'ALL') {
            this.modifyAllOfType(event.type, 'select');
        }
        else {
            this.updateDisplayItems(event, 'add');
            this.value[event.type].push(event.value);
            this.updateAllItemState(event.type);
            this.triggerValueUpdate();
        }
        this.updateParentOrChildren(event, 'select');
        this.select(null, event);
    }
    /**
     * @param {?} type
     * @return {?}
     */
    updateAllItemState(type) {
        let /** @type {?} */ allOfType = this.getAllOfType(type);
        let /** @type {?} */ allOfTypeSelected = this.allItemsSelected(allOfType, type);
        if (allOfTypeSelected) {
            this.selectAll(allOfType, type);
        }
        return { allOfType, allOfTypeSelected };
    }
    /**
     * @param {?} allOfType
     * @param {?} status
     * @return {?}
     */
    setIndeterminateState(allOfType, status) {
        if (!this.selectAllOption) {
            return;
        }
        let /** @type {?} */ allItem = allOfType[0];
        allItem.indeterminate = status;
    }
    /**
     * @param {?} item
     * @param {?} action
     * @return {?}
     */
    updateDisplayItems(item, action) {
        let /** @type {?} */ adding = action === 'add';
        if (adding) {
            this.items.push(item);
        }
        else {
            if (this.items.indexOf(item) > -1) {
                this.items.splice(this.items.indexOf(item), 1);
            }
        }
        this.updateDisplayText(this.items);
        this._items.next(this.items);
    }
    /**
     * @param {?} items
     * @return {?}
     */
    updateDisplayText(items) {
        this.notShown = [];
        let /** @type {?} */ notShown = items.slice(this.chipsCount);
        if (notShown.length > 0) {
            this.types.forEach(type => {
                let /** @type {?} */ count;
                let /** @type {?} */ selectedOfType = notShown.filter(x => x.type === type.value);
                if (selectedOfType.length === 1 && selectedOfType[0].value === 'ALL') {
                    count = this.getAllOfType(type.value).length - 1;
                }
                else {
                    count = selectedOfType.length;
                }
                let /** @type {?} */ displayType = count === 1 ? type.singular : type.plural || type.value;
                if (count > 0) {
                    this.notShown.push({ type: displayType, count: count });
                }
            });
        }
    }
    /**
     * @param {?} event
     * @param {?} item
     * @return {?}
     */
    remove(event, item) {
        let /** @type {?} */ triggeredByEvent;
        if (event) {
            triggeredByEvent = true;
        }
        let /** @type {?} */ itemToRemove = item;
        if (itemToRemove.value === 'ALL') {
            triggeredByEvent = false;
            this.modifyAllOfType(itemToRemove.type, 'unselect');
        }
        else if (this.allOfTypeSelected(itemToRemove.type)) {
            this.handleRemoveItemIfAllSelected(itemToRemove);
        }
        this.removeItem(item, triggeredByEvent);
    }
    /**
     * @param {?} item
     * @param {?=} triggeredByEvent
     * @return {?}
     */
    removeItem(item, triggeredByEvent) {
        item.checked = false;
        this.deselectAll();
        this.removeValue(item);
        if (item.value !== 'ALL') {
            this.updateParentOrChildren(item, 'unselect');
        }
        if (triggeredByEvent) {
            this.modifyAffectedParentsOrChildren(false, item);
        }
    }
    /**
     * @param {?} item
     * @return {?}
     */
    removeValue(item) {
        let /** @type {?} */ updatedValues = this.value[item.type].filter(x => x !== item.value);
        this.value[item.type] = updatedValues;
        this.triggerValueUpdate();
        this.updateDisplayItems(item, 'remove');
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onKeyDown(event) {
        if (event.keyCode === KeyCodes.BACKSPACE) {
            if (event.target && event.target.value.length === 0 && this.items.length) {
                if (event) {
                    event.stopPropagation();
                    event.preventDefault();
                }
                if (this.selected) {
                    this.remove(null, this.selected);
                }
                else {
                    this.select(event, this.items[this.items.length - 1]);
                }
            }
        }
    }
    /**
     * @param {?} type
     * @return {?}
     */
    allOfTypeSelected(type) {
        return this.items.filter(x => x.type === type && x.value === 'ALL').length > 0;
    }
    /**
     * @param {?} type
     * @param {?} action
     * @return {?}
     */
    modifyAllOfType(type, action) {
        let /** @type {?} */ selecting = action === 'select';
        let /** @type {?} */ allOfType = this.getAllOfType(type);
        allOfType.forEach(item => {
            item.checked = selecting;
            item.indeterminate = false;
        });
        if (selecting) {
            this.selectAll(allOfType, type);
        }
        else {
            this.items = [...this.items.filter(x => x.type !== type)];
            this._items.next(this.items);
            this.value[type] = [];
        }
        if (this.selectAllOption) {
            this.updateAllParentsOrChildren(allOfType[0], action);
        }
        this.triggerValueUpdate();
    }
    /**
     * @return {?}
     */
    triggerValueUpdate() {
        let /** @type {?} */ updatedObject = {};
        this.types.forEach(x => updatedObject[x.value] = this.value[x.value]);
        this.value = updatedObject;
    }
    /**
     * @param {?} allOfType
     * @param {?} type
     * @return {?}
     */
    selectAll(allOfType, type) {
        if (!this.selectAllOption) {
            return;
        }
        allOfType[0].checked = true;
        let /** @type {?} */ values = allOfType.map(i => {
            return i.value;
        });
        //remove 'ALL' value
        values.splice(0, 1);
        this.value[type] = values;
        let /** @type {?} */ updatedItems = this.items.filter(x => x.type !== type);
        this.items = updatedItems;
        this.updateDisplayItems(allOfType[0], 'add');
    }
    /**
     * @param {?} item
     * @return {?}
     */
    handleRemoveItemIfAllSelected(item) {
        if (!this.selectAllOption) {
            return;
        }
        let /** @type {?} */ type = item.type;
        let /** @type {?} */ allOfType = this.getAllOfType(type);
        let /** @type {?} */ allItem = allOfType[0];
        this.removeItem(allItem);
        allItem.indeterminate = true;
        let /** @type {?} */ selectedItems = allOfType.filter(i => i.checked === true);
        this.items = [...this.items, ...selectedItems];
        let /** @type {?} */ values = selectedItems.map(i => {
            return i.value;
        });
        this.value[type] = [...values];
    }
    /**
     * @param {?} event
     * @return {?}
     */
    handleOutsideClick(event) {
        // If the elements doesn't contain the target element, it is an outside click
        if (!this.element.nativeElement.contains(event.target)) {
            this.blur.emit(event);
            this.deselectAll();
        }
    }
    /**
     * @param {?} type
     * @return {?}
     */
    getAllOfType(type) {
        return this._options.filter(x => x.type === type)[0].originalData;
    }
    /**
     * @param {?} item
     * @param {?} action
     * @return {?}
     */
    updateParentOrChildren(item, action) {
        if (this.strictRelationship && item.isParentOf) {
            this.updateChildrenValue(item, action);
        }
        else if (item.isChildOf && this.selectAllOption) {
            this.updateParentValue(item, action);
        }
    }
    /**
     * @param {?} selecting
     * @param {?} itemChanged
     * @return {?}
     */
    modifyAffectedParentsOrChildren(selecting, itemChanged) {
        if (!itemChanged.isChildOf && !itemChanged.isParentOf) {
            return;
        }
        let /** @type {?} */ parent = this.types.filter(x => !!x.isParentOf)[0];
        let /** @type {?} */ parentType = parent.value;
        let /** @type {?} */ allParentType = this.getAllOfType(parentType);
        let /** @type {?} */ childType = allParentType[0].isParentOf;
        let /** @type {?} */ allChildren = this.getAllOfType(childType);
        let /** @type {?} */ allCheckedChildren = allChildren.filter(x => !!x.checked);
        allParentType.forEach(obj => {
            if (obj.value === 'ALL') {
                return;
            }
            let /** @type {?} */ selectedChildrenOfParent = allCheckedChildren.filter(x => {
                return x[parentType].filter(y => y === obj.value).length > 0;
            });
            if (selecting) {
                if (obj.checked) {
                    return;
                }
                obj.indeterminate = selectedChildrenOfParent.length > 0;
            }
            else {
                let /** @type {?} */ allChildrenOfParent = allChildren.filter(x => {
                    return x.value !== 'ALL' && x[parentType].filter(y => y === obj.value).length > 0;
                });
                if (selectedChildrenOfParent.length > 0) {
                    if (obj.checked) {
                        if (this.strictRelationship && (allChildrenOfParent.length !== selectedChildrenOfParent.length)) {
                            obj.indeterminate = true;
                            obj.checked = false;
                            this.removeValue(obj);
                            this.addIndividualChildren(selectedChildrenOfParent);
                        }
                    }
                    else {
                        obj.indeterminate = true;
                    }
                    if (this.strictRelationship && itemChanged.type !== parentType) {
                        if (obj.checked) {
                            obj.checked = false;
                            this.removeValue(obj);
                            this.addIndividualChildren(selectedChildrenOfParent);
                        }
                    }
                }
                else {
                    obj.indeterminate = false;
                    if (allChildrenOfParent.length === 0) {
                        //if it has no children and is checked, it should stay checked
                        return;
                    }
                    else if (this.strictRelationship && itemChanged.type !== parentType) {
                        this.remove(null, obj);
                    }
                }
            }
        });
        if (this.selectAllOption) {
            this.updateIndeterminateStates(allParentType, allChildren, allCheckedChildren);
        }
    }
    /**
     * @param {?} allItem
     * @param {?} action
     * @return {?}
     */
    updateAllParentsOrChildren(allItem, action) {
        if (allItem.isParentOf) {
            this.updateAllChildrenValue(allItem, action);
        }
        else if (allItem.isChildOf) {
            this.updateAllParentValue(allItem, action);
        }
    }
    /**
     * @param {?} item
     * @param {?} action
     * @return {?}
     */
    updateAllChildrenValue(item, action) {
        let /** @type {?} */ selecting = action === 'select';
        let /** @type {?} */ childType = item.isParentOf;
        let /** @type {?} */ potentialChildren = this.getAllOfType(childType);
        if (this.selectAllOption && this.allOfTypeSelected(childType) && !selecting) {
            this.remove(null, potentialChildren[0]);
            return;
        }
        potentialChildren.forEach(x => {
            if (x.value === 'ALL' && !x.checked) {
                if (selecting) {
                    x.checked = true;
                }
                x.indeterminate = selecting;
            }
            else {
                if (x.checked && !selecting) {
                    this.remove(null, x);
                }
                x.checked = selecting;
            }
        });
    }
    /**
     * @param {?} item
     * @param {?} action
     * @return {?}
     */
    updateAllParentValue(item, action) {
        let /** @type {?} */ selecting = action === 'select';
        let /** @type {?} */ parentType = item.isChildOf;
        let /** @type {?} */ potentialParents = this.getAllOfType(parentType);
        potentialParents.forEach(x => {
            if (!x.checked) {
                x.indeterminate = selecting;
            }
        });
    }
    /**
     * @param {?} allParentType
     * @param {?} allChildren
     * @param {?} allCheckedChildren
     * @return {?}
     */
    updateIndeterminateStates(allParentType, allChildren, allCheckedChildren) {
        let /** @type {?} */ allCheckedOrIndeterminateParents = allParentType.filter(x => (!!x.checked || !!x.indeterminate) && x.value !== 'ALL');
        let /** @type {?} */ isParentIndeterminate = !!allParentType[0].checked ? false : allCheckedOrIndeterminateParents.length > 0;
        let /** @type {?} */ isChildIndeterminate = !!allChildren[0].checked ? false : allCheckedChildren.length > 0;
        this.setIndeterminateState(allParentType, isParentIndeterminate);
        this.setIndeterminateState(allChildren, isChildIndeterminate);
    }
    /**
     * @param {?} parent
     * @param {?} action
     * @return {?}
     */
    updateChildrenValue(parent, action) {
        let /** @type {?} */ selecting = action === 'select';
        let /** @type {?} */ childType = parent.isParentOf;
        let /** @type {?} */ potentialChildren = this.getAllOfType(childType);
        potentialChildren.forEach(x => {
            if (x.value === 'ALL') {
                return;
            }
            if (x[parent.type].filter(y => y === parent.value).length > 0) {
                if (x.checked && !selecting) {
                    x.checked = false;
                    if (this.allOfTypeSelected(childType)) {
                        this.handleRemoveItemIfAllSelected(x);
                    }
                    else {
                        this.removeValue(x);
                    }
                }
                x.checked = selecting;
            }
        });
    }
    /**
     * @param {?} child
     * @param {?} action
     * @return {?}
     */
    updateParentValue(child, action) {
        let /** @type {?} */ allParentType = this.getAllOfType(child.isChildOf);
        if (allParentType[0].checked && action !== 'select') {
            this.handleRemoveItemIfAllSelected(allParentType[0]);
        }
    }
    /**
     * @param {?} children
     * @return {?}
     */
    addIndividualChildren(children) {
        let /** @type {?} */ parentAlreadySelected = false;
        children.forEach(x => {
            if (x.isChildOf) {
                x[x.isChildOf].forEach(parent => {
                    if (this.value[x.isChildOf].filter(p => p === parent).length > 0) {
                        parentAlreadySelected = true;
                    }
                });
            }
            if (this.value[x.type].filter(item => item === x.value).length === 0 && !parentAlreadySelected) {
                this.add(x);
            }
        });
    }
    /**
     * @param {?} model
     * @return {?}
     */
    setInitialValue(model) {
        this.items = [];
        this.value = model || {};
        if (!this.types) {
            return;
        }
        this.types.forEach(typeObj => {
            let /** @type {?} */ type = typeObj.value;
            if (this.value[type]) {
                let /** @type {?} */ indeterminateIsSet = false;
                let /** @type {?} */ options = this.updateAllItemState(type);
                let /** @type {?} */ optionsByType = options.allOfType;
                let /** @type {?} */ allSelected = options.allOfTypeSelected;
                this.value[type].forEach(item => {
                    if (!allSelected && !indeterminateIsSet) {
                        indeterminateIsSet = true;
                        this.setIndeterminateState(optionsByType, true);
                    }
                    let /** @type {?} */ value = optionsByType.filter(x => x.value === item)[0];
                    value.checked = true;
                    if (!allSelected) {
                        this.updateDisplayItems(value, 'add');
                    }
                    if (this.strictRelationship && value.isParentOf) {
                        this.updateChildrenValue(value, 'select');
                    }
                });
                if (typeObj.isChildOf) {
                    this.modifyAffectedParentsOrChildren(true, { value: type, isChildOf: true });
                }
            }
            else {
                this.value[type] = [];
            }
        });
    }
    /**
     * @param {?} optionsByType
     * @param {?} type
     * @return {?}
     */
    allItemsSelected(optionsByType, type) {
        return this.value[type].length === optionsByType.length - 1;
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onTouched(e) {
        this.element.nativeElement.classList.remove('selected');
        this.onModelTouched();
        this.blur.emit(e);
    }
    /**
     * @param {?} model
     * @return {?}
     */
    writeValue(model) {
        this.model = model;
        this.setInitialValue(model);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onModelChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onModelTouched = fn;
    }
}
NovoMultiPickerElement.decorators = [
    { type: Component, args: [{
                selector: 'multi-picker',
                providers: [CHIPS_VALUE_ACCESSOR$1],
                template: `
        <chip
            *ngFor="let item of _items | async | slice:0:chipsCount"
            [type]="type"
            [class.selected]="item == selected"
            (remove)="removeFromDisplay($event, item)"
            (select)="select($event, item)">
            {{ item.label }}
        </chip>
        <div *ngIf="items.length > chipsCount">
            <ul class="summary">
                <li *ngFor="let type of notShown">+ {{type.count}} {{ labels.more }} {{type.type}}</li>
            </ul>
        </div>
        <div class="chip-input-container">
            <novo-picker
                clearValueOnSelect="true"
                [config]="source"
                [placeholder]="placeholder"
                (select)="clickOption($event)"
                (keydown)="onKeyDown($event)"
                (focus)="onFocus($event)"
                (blur)="onTouched($event)"
                [overrideElement]="element">
            </novo-picker>
        </div>
        <i class="bhi-search" [class.has-value]="items.length"></i>
        <label class="clear-all" *ngIf="items.length" (click)="clearValue()">{{ labels.clearAll }} <i class="bhi-times"></i></label>
   `,
                host: {
                    '[class.with-value]': 'items.length > 0'
                }
            },] },
];
/**
 * @nocollapse
 */
NovoMultiPickerElement.ctorParameters = () => [
    { type: ElementRef, },
    { type: NovoLabelService, },
];
NovoMultiPickerElement.propDecorators = {
    'source': [{ type: Input },],
    'placeholder': [{ type: Input },],
    'types': [{ type: Input },],
    'changed': [{ type: Output },],
    'focus': [{ type: Output },],
    'blur': [{ type: Output },],
    'value': [{ type: Input },],
};

// NG2
// APP
class NovoMultiPickerModule {
}
NovoMultiPickerModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, FormsModule, NovoPickerModule, NovoChipsModule],
                declarations: [NovoMultiPickerElement],
                exports: [NovoMultiPickerElement]
            },] },
];
/**
 * @nocollapse
 */
NovoMultiPickerModule.ctorParameters = () => [];

/**
 * @abstract
 */
class RemoteActivityTableService {
    /**
     * @abstract
     * @param {?} sort
     * @param {?} filter
     * @param {?} page
     * @param {?} pageSize
     * @param {?=} globalSearch
     * @param {?=} outsideFilter
     * @return {?}
     */
    getTableResults(sort, filter$$1, page, pageSize, globalSearch, outsideFilter) { }
}
class StaticActivityTableService {
    /**
     * @param {?=} data
     */
    constructor(data = []) {
        this.data = data;
    }
    /**
     * @param {?} sort
     * @param {?} filter
     * @param {?=} page
     * @param {?=} pageSize
     * @param {?=} globalSearch
     * @param {?=} outsideFilter
     * @return {?}
     */
    getTableResults(sort, filter$$1, page = 0, pageSize, globalSearch, outsideFilter) {
        let /** @type {?} */ ret = Helpers.deepClone(this.data);
        if (ret.length !== 0) {
            if (globalSearch) {
                ret = ret.filter(item => Object.keys(item).some(key => `${item[key]}`.toLowerCase().includes(globalSearch.toLowerCase())));
            }
            if (filter$$1) {
                let /** @type {?} */ value = Helpers.isString(filter$$1.value) ? filter$$1.value.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') : filter$$1.value;
                ret = ret.filter(Helpers.filterByField(filter$$1.id, value));
            }
            if (sort) {
                ret = ret.sort(Helpers.sortByField(sort.id, sort.value === 'desc'));
            }
            if (!Helpers.isBlank(page) && !Helpers.isBlank(pageSize)) {
                ret = ret.slice(page * pageSize, (page + 1) * pageSize);
            }
        }
        return Observable$1.of({ results: ret, total: this.data.length });
    }
}
class ActivityTableDataSource extends DataSource {
    /**
     * @param {?} tableService
     * @param {?} state
     * @param {?} ref
     */
    constructor(tableService, state$$1, ref) {
        super();
        this.tableService = tableService;
        this.state = state$$1;
        this.ref = ref;
        this.total = 0;
        this.current = 0;
        this.loading = false;
        this.pristine = true;
    }
    /**
     * @return {?}
     */
    get totallyEmpty() {
        return this.total === 0;
    }
    /**
     * @return {?}
     */
    get currentlyEmpty() {
        return this.current === 0;
    }
    /**
     * @return {?}
     */
    connect() {
        const /** @type {?} */ displayDataChanges = [
            this.state.updates
        ];
        return Observable$1.merge(...displayDataChanges)
            .startWith(null)
            .switchMap(() => {
            this.pristine = false;
            this.loading = true;
            return this.tableService.getTableResults(this.state.sort, this.state.filter, this.state.page, this.state.pageSize, this.state.globalSearch, this.state.outsideFilter);
        })
            .map((data) => {
            this.loading = false;
            this.total = data.total;
            this.current = data.results.length;
            setTimeout(() => {
                this.ref.markForCheck();
            });
            return data.results;
        })
            .catch((error) => {
            console.error(error); // tslint: disable-line
            this.loading = false;
            return Observable$1.of(null);
        });
    }
    /**
     * @return {?}
     */
    disconnect() { }
}

class NovoActivityTableState {
    constructor() {
        this.id = Math.random();
        this.sort = undefined;
        this.filter = undefined;
        this.page = 0;
        this.pageSize = undefined;
        this.globalSearch = undefined;
        this.selectedRows = new Map();
        this.updates = new EventEmitter();
        this.onReset = new EventEmitter();
    }
    /**
     * @return {?}
     */
    get userFiltered() {
        return !!(this.filter || this.sort || this.globalSearch || this.outsideFilter);
    }
    /**
     * @param {?=} fireUpdate
     * @param {?=} persistUserFilters
     * @return {?}
     */
    reset(fireUpdate = true, persistUserFilters) {
        if (!persistUserFilters) {
            this.sort = undefined;
            this.globalSearch = undefined;
            this.filter = undefined;
        }
        this.page = 0;
        this.selectedRows.clear();
        this.onReset.emit(true);
        if (fireUpdate) {
            this.updates.emit({
                sort: this.sort,
                filter: this.filter,
                globalSearch: this.globalSearch
            });
        }
    }
}

/**
 * Workaround for https://github.com/angular/angular/issues/17849
 */
const _NovoTable = CdkTable;
class NovoTable extends _NovoTable {
}
NovoTable.decorators = [
    { type: Component, args: [{
                selector: 'novo-simple-table',
                template: CDK_TABLE_TEMPLATE,
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
            },] },
];
/**
 * @nocollapse
 */
NovoTable.ctorParameters = () => [];
class NovoActivityTableActions {
}
NovoActivityTableActions.decorators = [
    { type: Directive, args: [{
                selector: 'novo-activity-table-actions'
            },] },
];
/**
 * @nocollapse
 */
NovoActivityTableActions.ctorParameters = () => [];
class NovoActivityTableCustomHeader {
}
NovoActivityTableCustomHeader.decorators = [
    { type: Directive, args: [{
                selector: 'novo-activity-table-custom-header'
            },] },
];
/**
 * @nocollapse
 */
NovoActivityTableCustomHeader.ctorParameters = () => [];
class NovoActivityTableCustomFilter {
}
NovoActivityTableCustomFilter.decorators = [
    { type: Directive, args: [{
                selector: 'novo-activity-table-custom-filter'
            },] },
];
/**
 * @nocollapse
 */
NovoActivityTableCustomFilter.ctorParameters = () => [];
class NovoActivityTableEmptyMessage {
}
NovoActivityTableEmptyMessage.decorators = [
    { type: Directive, args: [{
                selector: 'novo-activity-table-empty-message'
            },] },
];
/**
 * @nocollapse
 */
NovoActivityTableEmptyMessage.ctorParameters = () => [];
class NovoActivityTableNoResultsMessage {
}
NovoActivityTableNoResultsMessage.decorators = [
    { type: Directive, args: [{
                selector: 'novo-activity-table-no-results-message'
            },] },
];
/**
 * @nocollapse
 */
NovoActivityTableNoResultsMessage.ctorParameters = () => [];
class NovoActivityTable {
    /**
     * @param {?} labels
     * @param {?} ref
     * @param {?} state
     */
    constructor(labels, ref, state$$1) {
        this.labels = labels;
        this.ref = ref;
        this.state = state$$1;
        this.globalSearchHiddenClassToggle = false;
        this.loading = true;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set customFilter(v) {
        this._customFilter = coerceBooleanProperty(v);
    }
    /**
     * @return {?}
     */
    get customFilter() {
        return this._customFilter;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set forceShowHeader(v) {
        this._forceShowHeader = coerceBooleanProperty(v);
    }
    /**
     * @return {?}
     */
    get forceShowHeader() {
        return this._forceShowHeader;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set hideGlobalSearch(v) {
        this._hideGlobalSearch = coerceBooleanProperty(v);
        this.globalSearchHiddenClassToggle = this._hideGlobalSearch;
    }
    /**
     * @return {?}
     */
    get hideGlobalSearch() {
        return this._hideGlobalSearch;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set debug(v) {
        this._debug = coerceBooleanProperty(v);
    }
    /**
     * @return {?}
     */
    get debug() {
        return this._debug;
    }
    /**
     * @return {?}
     */
    get empty() {
        return this.dataSource && this.dataSource.totallyEmpty;
    }
    /**
     * @return {?}
     */
    get loadingClass() {
        return this.loading || (this.dataSource && this.dataSource.loading);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this.loading = changes['activityService'] && !changes['activityService'].currentValue;
        this.ref.detectChanges();
        if (changes['activityService'] && changes['activityService'].currentValue) {
            this.loading = false;
            this.dataSource = new ActivityTableDataSource(this.activityService, this.state, this.ref);
            this.ref.detectChanges();
        }
        if (changes['outsideFilter'] && changes['outsideFilter'].currentValue) {
            if (!this.outsideFilterSubscription) {
                this.outsideFilterSubscription = this.outsideFilter.subscribe((filter$$1) => {
                    this.state.outsideFilter = filter$$1;
                    this.state.updates.next({ globalSearch: this.state.globalSearch, filter: this.state.filter, sort: this.state.sort });
                    this.ref.markForCheck();
                });
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.outsideFilterSubscription) {
            this.outsideFilterSubscription.unsubscribe();
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.paginationOptions && !this.paginationOptions.page) {
            this.paginationOptions.page = 0;
        }
        if (this.paginationOptions && !this.paginationOptions.pageSize) {
            this.paginationOptions.pageSize = 50;
        }
        if (this.paginationOptions && !this.paginationOptions.pageSizeOptions) {
            this.paginationOptions.pageSizeOptions = [10, 25, 50, 100];
        }
        this.state.page = this.paginationOptions ? this.paginationOptions.page : undefined;
        this.state.pageSize = this.paginationOptions ? this.paginationOptions.pageSize : undefined;
        this.ref.markForCheck();
    }
    /**
     * @param {?} term
     * @return {?}
     */
    onSearchChange(term) {
        this.state.globalSearch = term;
        this.state.reset(false, true);
        this.state.updates.next({ globalSearch: term, filter: this.state.filter, sort: this.state.sort });
    }
}
NovoActivityTable.decorators = [
    { type: Component, args: [{
                selector: 'novo-activity-table',
                template: `
        <div *ngIf="debug">
            <p>Total: {{ dataSource?.total }}</p>
            <p>Current: {{ dataSource?.current }}</p>
            <p>Totally Empty: {{ dataSource?.totallyEmpty }}</p>
            <p>Currently Empty: {{ dataSource?.currentlyEmpty }}</p>
            <p>Loading (DataSource): {{ dataSource?.loading }}</p>
            <p>User Filtered: {{ state.userFiltered }}</p>
            <p>Loading (Table): {{ loading }}</p>
        </div>
        <header *ngIf="(!(dataSource?.totallyEmpty && !state.userFiltered) && !loading) || forceShowHeader">
            <ng-content select="[novo-activity-table-custom-header]"></ng-content>
            <novo-search
                alwaysOpen="true"
                (searchChanged)="onSearchChange($event)"
                [(ngModel)]="state.globalSearch"
                *ngIf="!hideGlobalSearch"
                [placeholder]="searchOptions?.placeholder"
                [hint]="searchOptions?.tooltip">
            </novo-search>
            <novo-simple-table-pagination
                *ngIf="paginationOptions"
                [length]="dataSource?.total"
                [page]="paginationOptions.page"
                [pageSize]="paginationOptions.pageSize"
                [pageSizeOptions]="paginationOptions.pageSizeOptions">
            </novo-simple-table-pagination>
            <div class="novo-activity-table-actions">
                <ng-content select="[novo-activity-table-actions]"></ng-content>
            </div>
        </header>
        <div class="novo-activity-table-loading-mask" *ngIf="dataSource?.loading || loading" data-automation-id="novo-activity-table-loading">
            <novo-loading></novo-loading>
        </div>
        <div class="novo-activity-table-filter-container">
            <div class="novo-activity-table-custom-filter" *ngIf="customFilter">
                <ng-content select="[novo-activity-table-custom-filter]"></ng-content>
            </div>
            <div class="novo-activity-table-container">
                <novo-simple-table *ngIf="(columns?.length > 0)" [dataSource]="dataSource" novoSortFilter novoSelection [class.empty]="dataSource?.currentlyEmpty && state.userFiltered" [hidden]="dataSource?.totallyEmpty && !userFiltered">
                    <ng-content></ng-content>
                    <ng-container novoSimpleColumnDef="selection">
                        <novo-simple-checkbox-header-cell *novoSimpleHeaderCellDef></novo-simple-checkbox-header-cell>
                        <novo-simple-checkbox-cell *novoSimpleCellDef="let row; let i = index" [row]="row" [index]="i"></novo-simple-checkbox-cell>
                    </ng-container>
                    <ng-container *ngFor="let column of actionColumns" [novoSimpleColumnDef]="column.id">
                        <novo-simple-empty-header-cell [class.button-header-cell]="!column.options" [class.dropdown-header-cell]="column.options" *novoSimpleHeaderCellDef></novo-simple-empty-header-cell>
                        <novo-simple-action-cell *novoSimpleCellDef="let row; let i = index" [row]="row" [column]="column"></novo-simple-action-cell>
                    </ng-container>
                    <ng-container *ngFor="let column of columns" [novoSimpleColumnDef]="column.id">
                        <novo-simple-header-cell *novoSimpleHeaderCellDef [column]="column" [novo-simple-cell-config]="column.config" [defaultSort]="defaultSort">{{ column.label }}</novo-simple-header-cell>
                        <novo-simple-cell *novoSimpleCellDef="let row" [column]="column" [row]="row"></novo-simple-cell>
                    </ng-container>
                    <novo-simple-header-row *novoSimpleHeaderRowDef="displayedColumns"></novo-simple-header-row>
                    <novo-simple-row *novoSimpleRowDef="let row; columns: displayedColumns;"></novo-simple-row>
                </novo-simple-table>
                <div class="novo-activity-table-no-results-container" *ngIf="dataSource?.currentlyEmpty && state.userFiltered && !dataSource?.loading && !loading && !dataSource.pristine">
                    <div #filtered><ng-content select="[novo-activity-table-no-results-message]"></ng-content></div>
                    <div class="novo-activity-table-empty-message" *ngIf="filtered.childNodes.length == 0">
                        <h4><i class="bhi-search-question"></i> {{ labels.noMatchingRecordsMessage }}</h4>
                    </div>
                </div>
                <div class="novo-activity-table-empty-container" *ngIf="dataSource?.totallyEmpty && !dataSource?.loading && !loading && !state.userFiltered && !dataSource.pristine">
                    <div #empty><ng-content select="[novo-activity-table-empty-message]"></ng-content></div>
                    <div class="novo-activity-table-empty-message" *ngIf="empty.childNodes.length == 0">
                        <h4><i class="bhi-search-question"></i> {{ labels.emptyTableMessage }}</h4>
                    </div>
                </div>
            </div>
        </div>
    `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [NovoActivityTableState]
            },] },
];
/**
 * @nocollapse
 */
NovoActivityTable.ctorParameters = () => [
    { type: NovoLabelService, },
    { type: ChangeDetectorRef, },
    { type: NovoActivityTableState, },
];
NovoActivityTable.propDecorators = {
    'globalSearchHiddenClassToggle': [{ type: HostBinding, args: ['class.global-search-hidden',] },],
    'activityService': [{ type: Input },],
    'columns': [{ type: Input },],
    'displayedColumns': [{ type: Input },],
    'actionColumns': [{ type: Input },],
    'paginationOptions': [{ type: Input },],
    'searchOptions': [{ type: Input },],
    'defaultSort': [{ type: Input },],
    'outsideFilter': [{ type: Input },],
    'customFilter': [{ type: Input },],
    'forceShowHeader': [{ type: Input },],
    'hideGlobalSearch': [{ type: Input },],
    'debug': [{ type: Input },],
    'empty': [{ type: HostBinding, args: ['class.empty',] },],
    'loadingClass': [{ type: HostBinding, args: ['class.loading',] },],
};

class NovoSortFilter {
    /**
     * @param {?} state
     */
    constructor(state$$1) {
        this.state = state$$1;
    }
    /**
     * @param {?} id
     * @param {?} value
     * @param {?} transform
     * @return {?}
     */
    filter(id, value, transform) {
        let /** @type {?} */ filter$$1;
        if (value) {
            filter$$1 = { id, value, transform };
        }
        else {
            filter$$1 = undefined;
        }
        this.state.filter = filter$$1;
        this.state.reset(false, true);
        this.state.updates.next({ filter: filter$$1, sort: this.state.sort });
    }
    /**
     * @param {?} id
     * @param {?} value
     * @param {?} transform
     * @return {?}
     */
    sort(id, value, transform) {
        let /** @type {?} */ sort = { id, value, transform };
        this.state.sort = sort;
        this.state.reset(false, true);
        this.state.updates.next({ sort: sort, filter: this.state.filter });
    }
}
NovoSortFilter.decorators = [
    { type: Directive, args: [{
                selector: '[novoSortFilter]',
            },] },
];
/**
 * @nocollapse
 */
NovoSortFilter.ctorParameters = () => [
    { type: NovoActivityTableState, },
];
class NovoSelection {
    /**
     * @param {?} state
     */
    constructor(state$$1) {
        this.state = state$$1;
        this.novoSelectAllToggle = new EventEmitter();
        this.allRows = new Map();
    }
    /**
     * @param {?} id
     * @param {?} row
     * @return {?}
     */
    register(id, row) {
        this.allRows.set(id, row);
    }
    /**
     * @param {?} id
     * @return {?}
     */
    deregister(id) {
        this.allRows.delete(id);
        this.state.selectedRows.delete(id);
        clearTimeout(this.throttleTimeout);
        this.throttleTimeout = setTimeout(() => {
            if (this.state.selectedRows.size === 0) {
                this.novoSelectAllToggle.emit(false);
            }
        });
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.allRows.clear();
        this.state.selectedRows.clear();
    }
    /**
     * @param {?} id
     * @param {?} selected
     * @param {?} row
     * @return {?}
     */
    toggle(id, selected, row) {
        if (selected) {
            this.state.selectedRows.set(id, row);
        }
        else {
            this.state.selectedRows.delete(id);
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    selectAll(value) {
        if (value) {
            this.state.selectedRows = new Map(this.allRows);
        }
        else {
            this.state.selectedRows.clear();
        }
        this.novoSelectAllToggle.emit(value);
    }
}
NovoSelection.decorators = [
    { type: Directive, args: [{
                selector: '[novoSelection]',
            },] },
];
/**
 * @nocollapse
 */
NovoSelection.ctorParameters = () => [
    { type: NovoActivityTableState, },
];
NovoSelection.propDecorators = {
    'novoSelectAllToggle': [{ type: Output },],
};

/**
 * Workaround for https://github.com/angular/angular/issues/17849
 */
const _NovoCellDef = CdkCellDef;
const _NovoHeaderCellDef = CdkHeaderCellDef;
const _NovoColumnDef = CdkColumnDef;
const _NovoHeaderCell = CdkHeaderCell;
const _NovoCell = CdkCell;
class NovoSimpleCellDef extends _NovoCellDef {
}
NovoSimpleCellDef.decorators = [
    { type: Directive, args: [{
                selector: '[novoSimpleCellDef]',
                providers: [{ provide: CdkCellDef, useExisting: NovoSimpleCellDef }]
            },] },
];
/**
 * @nocollapse
 */
NovoSimpleCellDef.ctorParameters = () => [];
class NovoSimpleHeaderCellDef extends _NovoHeaderCellDef {
}
NovoSimpleHeaderCellDef.decorators = [
    { type: Directive, args: [{
                selector: '[novoSimpleHeaderCellDef]',
                providers: [{ provide: CdkHeaderCellDef, useExisting: NovoSimpleHeaderCellDef }]
            },] },
];
/**
 * @nocollapse
 */
NovoSimpleHeaderCellDef.ctorParameters = () => [];
class NovoSimpleColumnDef extends _NovoColumnDef {
}
NovoSimpleColumnDef.decorators = [
    { type: Directive, args: [{
                selector: '[novoSimpleColumnDef]',
                providers: [{ provide: CdkColumnDef, useExisting: NovoSimpleColumnDef }],
            },] },
];
/**
 * @nocollapse
 */
NovoSimpleColumnDef.ctorParameters = () => [];
NovoSimpleColumnDef.propDecorators = {
    'name': [{ type: Input, args: ['novoSimpleColumnDef',] },],
};
class NovoSimpleHeaderCell extends _NovoHeaderCell {
    /**
     * @param {?} columnDef
     * @param {?} elementRef
     * @param {?} renderer
     */
    constructor(columnDef, elementRef, renderer) {
        super(columnDef, elementRef, renderer);
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.role = 'columnheader';
        renderer.setAttribute(elementRef.nativeElement, 'data-automation-id', `novo-column-header-${columnDef.cssClassFriendlyName}`);
        renderer.addClass(elementRef.nativeElement, `novo-column-${columnDef.cssClassFriendlyName}`);
        renderer.addClass(elementRef.nativeElement, 'novo-simple-header-cell');
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.column.width) {
            this.renderer.setStyle(this.elementRef.nativeElement, 'min-width', `${this.column.width}px`);
            this.renderer.setStyle(this.elementRef.nativeElement, 'max-width', `${this.column.width}px`);
            this.renderer.setStyle(this.elementRef.nativeElement, 'width', `${this.column.width}px`);
        }
    }
}
NovoSimpleHeaderCell.decorators = [
    { type: Directive, args: [{
                selector: 'novo-simple-header-cell'
            },] },
];
/**
 * @nocollapse
 */
NovoSimpleHeaderCell.ctorParameters = () => [
    { type: CdkColumnDef, },
    { type: ElementRef, },
    { type: Renderer2, },
];
NovoSimpleHeaderCell.propDecorators = {
    'role': [{ type: HostBinding, args: ['attr.role',] },],
    'column': [{ type: Input },],
};
class NovoSimpleEmptyHeaderCell extends _NovoHeaderCell {
    /**
     * @param {?} columnDef
     * @param {?} elementRef
     * @param {?} renderer
     */
    constructor(columnDef, elementRef, renderer) {
        super(columnDef, elementRef, renderer);
        this.role = 'columnheader';
        renderer.setAttribute(elementRef.nativeElement, 'data-automation-id', `novo-column-header-${columnDef.cssClassFriendlyName}`);
        renderer.addClass(elementRef.nativeElement, `novo-column-${columnDef.cssClassFriendlyName}`);
        renderer.addClass(elementRef.nativeElement, 'novo-simple-empty-header-cell');
    }
}
NovoSimpleEmptyHeaderCell.decorators = [
    { type: Directive, args: [{
                selector: 'novo-simple-empty-header-cell'
            },] },
];
/**
 * @nocollapse
 */
NovoSimpleEmptyHeaderCell.ctorParameters = () => [
    { type: CdkColumnDef, },
    { type: ElementRef, },
    { type: Renderer2, },
];
NovoSimpleEmptyHeaderCell.propDecorators = {
    'role': [{ type: HostBinding, args: ['attr.role',] },],
};
class NovoSimpleCheckboxHeaderCell extends _NovoHeaderCell {
    /**
     * @param {?} columnDef
     * @param {?} elementRef
     * @param {?} renderer
     * @param {?} ref
     * @param {?} _selection
     */
    constructor(columnDef, elementRef, renderer, ref, _selection) {
        super(columnDef, elementRef, renderer);
        this._selection = _selection;
        this.role = 'columnheader';
        this.selectAll = false;
        renderer.setAttribute(elementRef.nativeElement, 'data-automation-id', `novo-checkbox-column-header-${columnDef.cssClassFriendlyName}`);
        renderer.addClass(elementRef.nativeElement, `novo-checkbox-column-${columnDef.cssClassFriendlyName}`);
        renderer.addClass(elementRef.nativeElement, 'novo-simple-checkbox-header-cell');
        this.selectAllSubscription = _selection.novoSelectAllToggle.subscribe((value) => {
            this.selectAll = value;
            ref.markForCheck();
        });
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.selectAllSubscription.unsubscribe();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    toggle(value) {
        this._selection.selectAll(value);
    }
}
NovoSimpleCheckboxHeaderCell.decorators = [
    { type: Component, args: [{
                selector: 'novo-simple-checkbox-header-cell',
                template: `<novo-checkbox [(ngModel)]="selectAll" (ngModelChange)="toggle($event)"></novo-checkbox>`
            },] },
];
/**
 * @nocollapse
 */
NovoSimpleCheckboxHeaderCell.ctorParameters = () => [
    { type: CdkColumnDef, },
    { type: ElementRef, },
    { type: Renderer2, },
    { type: ChangeDetectorRef, },
    { type: NovoSelection, decorators: [{ type: Optional },] },
];
NovoSimpleCheckboxHeaderCell.propDecorators = {
    'role': [{ type: HostBinding, args: ['attr.role',] },],
};
class NovoSimpleCell extends _NovoCell {
    /**
     * @param {?} columnDef
     * @param {?} elementRef
     * @param {?} renderer
     */
    constructor(columnDef, elementRef, renderer) {
        super(columnDef, elementRef, renderer);
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.role = 'gridcell';
        renderer.setAttribute(elementRef.nativeElement, 'data-automation-id', `novo-column-${columnDef.cssClassFriendlyName}`);
        renderer.addClass(elementRef.nativeElement, `novo-column-${columnDef.cssClassFriendlyName}`);
        renderer.addClass(elementRef.nativeElement, 'novo-simple-cell');
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.column.customClass) {
            this.renderer.addClass(this.elementRef.nativeElement, this.column.customClass(this.row));
        }
        if (this.column.width) {
            this.renderer.setStyle(this.elementRef.nativeElement, 'min-width', `${this.column.width}px`);
            this.renderer.setStyle(this.elementRef.nativeElement, 'max-width', `${this.column.width}px`);
            this.renderer.setStyle(this.elementRef.nativeElement, 'width', `${this.column.width}px`);
            // TODO - this inhibits resizing the page after the initial load -- but do we care?!?!
            // this.renderer.setStyle(this.spanElement.nativeElement, 'min-width', `${this.column.width - 20}px`);
            // this.renderer.setStyle(this.spanElement.nativeElement, 'max-width', `${this.column.width - 20}px`);
            // this.renderer.setStyle(this.spanElement.nativeElement, 'width', `${this.column.width - 20}px`);
        }
        // else {
        //     // TODO - this inhibits resizing the page after the initial load -- but do we care?!?!
        //     this.renderer.setStyle(this.spanElement.nativeElement, 'min-width', `${this.elementRef.nativeElement.offsetWidth - 20}px`);
        //     this.renderer.setStyle(this.spanElement.nativeElement, 'max-width', `${this.elementRef.nativeElement.offsetWidth - 20}px`);
        //     this.renderer.setStyle(this.spanElement.nativeElement, 'width', `${this.elementRef.nativeElement.offsetWidth - 20}px`);
        // }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onClick(event) {
        Helpers.swallowEvent(event);
        if (this.column.onClick) {
            this.column.onClick(this.row);
        }
        return;
    }
}
NovoSimpleCell.decorators = [
    { type: Component, args: [{
                selector: 'novo-simple-cell',
                template: `
        <span [class.clickable]="!!column.onClick" (click)="onClick($event)" #span>{{ column.renderer(row) }}</span>
    `,
                changeDetection: ChangeDetectionStrategy.OnPush
            },] },
];
/**
 * @nocollapse
 */
NovoSimpleCell.ctorParameters = () => [
    { type: CdkColumnDef, },
    { type: ElementRef, },
    { type: Renderer2, },
];
NovoSimpleCell.propDecorators = {
    'role': [{ type: HostBinding, args: ['attr.role',] },],
    'row': [{ type: Input },],
    'column': [{ type: Input },],
    'spanElement': [{ type: ViewChild, args: ['span',] },],
};
class NovoSimpleCheckboxCell extends _NovoCell {
    /**
     * @param {?} columnDef
     * @param {?} elementRef
     * @param {?} renderer
     * @param {?} _selection
     */
    constructor(columnDef, elementRef, renderer, _selection) {
        super(columnDef, elementRef, renderer);
        this.columnDef = columnDef;
        this._selection = _selection;
        this.role = 'gridcell';
        this.selected = false;
        renderer.setAttribute(elementRef.nativeElement, 'data-automation-id', `novo-checkbox-column-${columnDef.cssClassFriendlyName}`);
        renderer.addClass(elementRef.nativeElement, `novo-checkbox-column-${columnDef.cssClassFriendlyName}`);
        renderer.addClass(elementRef.nativeElement, 'novo-simple-checkbox-cell');
        this.selectAllSubscription = _selection.novoSelectAllToggle.subscribe((value) => {
            this.selected = value;
        });
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._selection.register(this.row.id || this.index, this.row);
        this.selected = this._selection.state.selectedRows.has(this.row.id || this.index);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._selection.deregister(this.row.id || this.index);
        this.selectAllSubscription.unsubscribe();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    toggle(value) {
        this._selection.toggle(this.row.id || this.index, value, this.row);
    }
}
NovoSimpleCheckboxCell.decorators = [
    { type: Component, args: [{
                selector: 'novo-simple-checkbox-cell',
                template: `
        <novo-checkbox [ngModel]="selected" (ngModelChange)="toggle($event)"></novo-checkbox>
    `
            },] },
];
/**
 * @nocollapse
 */
NovoSimpleCheckboxCell.ctorParameters = () => [
    { type: CdkColumnDef, },
    { type: ElementRef, },
    { type: Renderer2, },
    { type: NovoSelection, decorators: [{ type: Optional },] },
];
NovoSimpleCheckboxCell.propDecorators = {
    'role': [{ type: HostBinding, args: ['attr.role',] },],
    'row': [{ type: Input },],
    'index': [{ type: Input },],
};
class NovoSimpleActionCell extends _NovoCell {
    /**
     * @param {?} columnDef
     * @param {?} elementRef
     * @param {?} renderer
     * @param {?} labels
     */
    constructor(columnDef, elementRef, renderer, labels) {
        super(columnDef, elementRef, renderer);
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.labels = labels;
        this.role = 'gridcell';
        renderer.setAttribute(elementRef.nativeElement, 'data-automation-id', `novo-action-column-${columnDef.cssClassFriendlyName}`);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.column.options) {
            this.renderer.addClass(this.elementRef.nativeElement, 'novo-simple-dropdown-cell');
        }
        else {
            this.renderer.addClass(this.elementRef.nativeElement, 'novo-simple-button-cell');
        }
    }
    /**
     * @param {?} check
     * @param {?} row
     * @return {?}
     */
    isDisabled(check, row) {
        if (check.disabled === true) {
            return true;
        }
        if (check.disabledCheck) {
            return check.disabledCheck(row);
        }
        return false;
    }
}
NovoSimpleActionCell.decorators = [
    { type: Component, args: [{
                selector: 'novo-simple-action-cell',
                template: `
        <ng-container *ngIf="!column.options">
            <button theme="icon" [icon]="column.icon" (click)="column.onClick(row)" [disabled]="isDisabled(column, row)"></button>
        </ng-container>
        <ng-container *ngIf="column.options">
            <novo-dropdown appendToBody="true" parentScrollSelector=".novo-simple-table" containerClass="novo-table-dropdown-cell">
                <button type="button" theme="dialogue" icon="collapse" inverse>{{ column.label || labels.actions }}</button>
                <list>
                    <item *ngFor="let option of column.options" (action)="option.onClick(row)" [disabled]="isDisabled(option, row)">
                        <span [attr.data-automation-id]="option.label">{{ option.label }}</span>
                    </item>
                </list>
            </novo-dropdown>
        </ng-container>
    `,
                changeDetection: ChangeDetectionStrategy.OnPush
            },] },
];
/**
 * @nocollapse
 */
NovoSimpleActionCell.ctorParameters = () => [
    { type: CdkColumnDef, },
    { type: ElementRef, },
    { type: Renderer2, },
    { type: NovoLabelService, },
];
NovoSimpleActionCell.propDecorators = {
    'role': [{ type: HostBinding, args: ['attr.role',] },],
    'row': [{ type: Input },],
    'column': [{ type: Input },],
};

/**
 * Workaround for https://github.com/angular/angular/issues/17849
 */
const _NovoHeaderRowDef = CdkHeaderRowDef;
const _NovoCdkRowDef = CdkRowDef;
const _NovoHeaderRow = CdkHeaderRow;
const _NovoRow = CdkRow;
class NovoSimpleHeaderRowDef extends _NovoHeaderRowDef {
}
NovoSimpleHeaderRowDef.decorators = [
    { type: Directive, args: [{
                selector: '[novoSimpleHeaderRowDef]',
                providers: [{ provide: CdkHeaderRowDef, useExisting: NovoSimpleHeaderRowDef }],
            },] },
];
/**
 * @nocollapse
 */
NovoSimpleHeaderRowDef.ctorParameters = () => [];
NovoSimpleHeaderRowDef.propDecorators = {
    'columns': [{ type: Input, args: ['novoSimpleHeaderRowDef',] },],
};
class NovoSimpleRowDef extends _NovoCdkRowDef {
}
NovoSimpleRowDef.decorators = [
    { type: Directive, args: [{
                selector: '[novoSimpleRowDef]',
                providers: [{ provide: CdkRowDef, useExisting: NovoSimpleRowDef }]
            },] },
];
/**
 * @nocollapse
 */
NovoSimpleRowDef.ctorParameters = () => [];
NovoSimpleRowDef.propDecorators = {
    'columns': [{ type: Input, args: ['novoSimpleRowDefColumns',] },],
};
class NovoSimpleHeaderRow extends _NovoHeaderRow {
    constructor() {
        super(...arguments);
        this.rowClass = 'novo-simple-header-row';
        this.role = 'row';
    }
}
NovoSimpleHeaderRow.decorators = [
    { type: Component, args: [{
                selector: 'novo-simple-header-row',
                template: CDK_ROW_TEMPLATE,
                changeDetection: ChangeDetectionStrategy.OnPush
            },] },
];
/**
 * @nocollapse
 */
NovoSimpleHeaderRow.ctorParameters = () => [];
NovoSimpleHeaderRow.propDecorators = {
    'rowClass': [{ type: HostBinding, args: ['class',] },],
    'role': [{ type: HostBinding, args: ['attr.role',] },],
};
class NovoSimpleRow extends _NovoRow {
    constructor() {
        super(...arguments);
        this.rowClass = 'novo-simple-row';
        this.role = 'row';
    }
}
NovoSimpleRow.decorators = [
    { type: Component, args: [{
                selector: 'novo-simple-row',
                template: CDK_ROW_TEMPLATE,
                changeDetection: ChangeDetectionStrategy.OnPush,
            },] },
];
/**
 * @nocollapse
 */
NovoSimpleRow.ctorParameters = () => [];
NovoSimpleRow.propDecorators = {
    'rowClass': [{ type: HostBinding, args: ['class',] },],
    'role': [{ type: HostBinding, args: ['attr.role',] },],
};

class NovoSimpleFilterFocus {
    /**
     * @param {?} element
     */
    constructor(element) {
        this.element = element;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.element.nativeElement.focus();
    }
}
NovoSimpleFilterFocus.decorators = [
    { type: Directive, args: [{
                selector: '[novoSimpleFilterFocus]'
            },] },
];
/**
 * @nocollapse
 */
NovoSimpleFilterFocus.ctorParameters = () => [
    { type: ElementRef, },
];
class NovoSimpleCellHeader {
    /**
     * @param {?} changeDetectorRef
     * @param {?} labels
     * @param {?} state
     * @param {?} _sort
     * @param {?} _cdkColumnDef
     */
    constructor(changeDetectorRef, labels, state$$1, _sort, _cdkColumnDef) {
        this.changeDetectorRef = changeDetectorRef;
        this.labels = labels;
        this.state = state$$1;
        this._sort = _sort;
        this._cdkColumnDef = _cdkColumnDef;
        this.icon = 'sortable';
        this.filterActive = false;
        this.sortActive = false;
        this.showCustomRange = false;
        this._rerenderSubscription = state$$1.updates.subscribe((change) => {
            if (change.sort && change.sort.id === this.id) {
                this.icon = `sort-${change.sort.value}`;
                this.sortActive = true;
            }
            else {
                this.icon = 'sortable';
                this.sortActive = false;
            }
            if (change.filter && change.filter.id === this.id) {
                this.filterActive = true;
                this.filter = change.filter.value;
            }
            else {
                this.filterActive = false;
                this.filter = undefined;
            }
            changeDetectorRef.markForCheck();
        });
    }
    /**
     * @return {?}
     */
    get config() { return this._config; }
    /**
     * @param {?} v
     * @return {?}
     */
    set config(v) {
        if (!v) {
            this._config = {
                sortable: false,
                filterable: false,
                filterConfig: {
                    type: 'text'
                }
            };
        }
        else {
            this._config = {
                sortable: coerceBooleanProperty(v.sortable),
                filterable: coerceBooleanProperty(v.filterable),
                transforms: v.transforms || {},
                filterConfig: v.filterConfig || {
                    type: 'text'
                }
            };
            if (this._config.filterConfig.type === 'date' && !this._config.filterConfig.options) {
                this._config.filterConfig.options = this.getDefaultDateFilterOptions();
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this._cdkColumnDef) {
            this.id = this._cdkColumnDef.name;
        }
        if (this.defaultSort && this.id === this.defaultSort.id) {
            this.icon = `sort-${this.defaultSort.value}`;
            this.sortActive = true;
            this.changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._rerenderSubscription.unsubscribe();
    }
    /**
     * @return {?}
     */
    sort() {
        if (this.changeTimeout) {
            clearTimeout(this.changeTimeout);
        }
        this.changeTimeout = setTimeout(() => {
            this.direction = this.getNextSortDirection(this.direction);
            this._sort.sort(this.id, this.direction, this._config.transforms.sort);
            this.changeDetectorRef.markForCheck();
        }, 300);
    }
    /**
     * @param {?=} filter
     * @return {?}
     */
    filterData(filter$$1) {
        if (this.config.filterConfig.type === 'date' && filter$$1) {
            this.activeDateFilter = filter$$1.label || this.labels.customDateRange;
            if (filter$$1.startDate && filter$$1.endDate) {
                filter$$1 = {
                    min: startOfDay(filter$$1.startDate),
                    max: endOfDay(filter$$1.endDate),
                };
            }
            else {
                filter$$1 = {
                    min: startOfDay(addDays(startOfToday(), filter$$1.min)),
                    max: endOfDay(addDays(startOfToday(), filter$$1.max)),
                };
            }
        }
        if (filter$$1) {
            this.filter = filter$$1;
        }
        if (this.changeTimeout) {
            clearTimeout(this.changeTimeout);
        }
        this.changeTimeout = setTimeout(() => {
            if (this.filter === '') {
                this.filter = undefined;
            }
            this._sort.filter(this.id, this.filter, this._config.transforms.filter);
            this.changeDetectorRef.markForCheck();
        }, 300);
    }
    /**
     * @return {?}
     */
    clearFilter() {
        this.filter = undefined;
        this.activeDateFilter = undefined;
        this.filterData();
    }
    /**
     * @param {?} direction
     * @return {?}
     */
    getNextSortDirection(direction) {
        if (!direction) {
            return 'asc';
        }
        if (direction === 'asc') {
            return 'desc';
        }
        return 'asc';
    }
    /**
     * @return {?}
     */
    getDefaultDateFilterOptions() {
        let /** @type {?} */ opts = [
            { label: this.labels.past1Day, min: -1, max: 0 },
            { label: this.labels.past7Days, min: -7, max: 0 },
            { label: this.labels.past30Days, min: -30, max: 0 },
            { label: this.labels.past90Days, min: -90, max: 0 },
            { label: this.labels.past1Year, min: -366, max: 0 },
            { label: this.labels.next1Day, min: 0, max: 1 },
            { label: this.labels.next7Days, min: 0, max: 7 },
            { label: this.labels.next30Days, min: 0, max: 30 },
            { label: this.labels.next90Days, min: 0, max: 90 },
            { label: this.labels.next1Year, min: 0, max: 366 }
        ];
        return opts;
    }
}
NovoSimpleCellHeader.decorators = [
    { type: Component, args: [{
                selector: '[novo-simple-cell-config]',
                template: `
        <label (click)="sort()" data-automation-id="novo-activity-table-label" [class.sort-disabled]="!config.sortable"><ng-content></ng-content></label>
        <div>
            <button *ngIf="config.sortable" theme="icon" [icon]="icon" (click)="sort()" [class.active]="sortActive" data-automation-id="novo-activity-table-sort"></button>
            <novo-dropdown *ngIf="config.filterable" side="right" appendToBody="true" parentScrollSelector=".novo-simple-table" containerClass="simple-table-dropdown" data-automation-id="novo-activity-table-filter">
                <button type="button" theme="icon" icon="filter" [class.active]="filterActive"></button>
                <div class="header">
                    <span>{{ labels.filters }}</span>
                    <button theme="dialogue" color="negative" icon="times" (click)="clearFilter()" *ngIf="filter" data-automation-id="novo-activity-table-filter-clear">{{ labels.clear }}</button>
                </div>
                <ng-container [ngSwitch]="config.filterConfig.type">
                    <list *ngSwitchCase="'date'">
                        <ng-container *ngIf="!showCustomRange">
                            <item [class.active]="activeDateFilter === option.label" *ngFor="let option of config.filterConfig.options" (click)="filterData(option)" [attr.data-automation-id]="'novo-activity-table-filter-' + option.label">
                                {{ option.label }} <i class="bhi-check" *ngIf="activeDateFilter === option.label"></i>
                            </item>
                        </ng-container>
                        <item [class.active]="labels.customDateRange === activeDateFilter" (click)="showCustomRange = true" *ngIf="config.filterConfig.allowCustomRange && !showCustomRange" [keepOpen]="true">
                            {{ labels.customDateRange }} <i class="bhi-check" *ngIf="labels.customDateRange === activeDateFilter"></i>
                        </item>
                        <div class="calender-container" *ngIf="showCustomRange">
                            <div (click)="showCustomRange = false"><i class="bhi-previous"></i>{{ labels.backToPresetFilters }}</div>
                            <novo-date-picker (onSelect)="filterData($event)" [(ngModel)]="filter" range="true"></novo-date-picker>
                        </div>
                    </list>
                    <list *ngSwitchCase="'select'">
                        <item [class.active]="filter === option" *ngFor="let option of config.filterConfig.options" (click)="filterData(option.value || option)" [attr.data-automation-id]="'novo-activity-table-filter-' + (option?.label || option)">
                            <span>{{ option?.label || option }}</span> <i class="bhi-check" *ngIf="filter === (option.value || option)"></i>
                        </item>
                    </list>
                    <list *ngSwitchDefault>
                        <item class="filter-search" keepOpen="true">
                            <input type="text" [(ngModel)]="filter" (ngModelChange)="filterData()" novoSimpleFilterFocus data-automation-id="novo-activity-table-filter-input"/>
                        </item>
                    </list>
                </ng-container>
            </novo-dropdown>
        </div>
    `,
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            },] },
];
/**
 * @nocollapse
 */
NovoSimpleCellHeader.ctorParameters = () => [
    { type: ChangeDetectorRef, },
    { type: NovoLabelService, },
    { type: NovoActivityTableState, },
    { type: NovoSortFilter, decorators: [{ type: Optional },] },
    { type: CdkColumnDef, decorators: [{ type: Optional },] },
];
NovoSimpleCellHeader.propDecorators = {
    'defaultSort': [{ type: Input },],
    'config': [{ type: Input, args: ['novo-simple-cell-config',] },],
};

const DEFAULT_PAGE_SIZE = 50;
class NovoSimpleTablePagination {
    /**
     * @param {?} changeDetectorRef
     * @param {?} labels
     * @param {?} state
     */
    constructor(changeDetectorRef, labels, state$$1) {
        this.changeDetectorRef = changeDetectorRef;
        this.labels = labels;
        this.state = state$$1;
        this._page = 0;
        this._length = 0;
        this._pageSizeOptions = [];
        this.pageChange = new EventEmitter();
        if (state$$1 && state$$1.onReset) {
            this.resetSubscription = this.state.onReset.subscribe((clear) => {
                if (clear) {
                    this.page = 0;
                    this.changeDetectorRef.markForCheck();
                }
            });
        }
    }
    /**
     * @return {?}
     */
    get page() { return this._page; }
    /**
     * @param {?} page
     * @return {?}
     */
    set page(page) {
        this._page = page;
        this.changeDetectorRef.markForCheck();
        this.longRangeLabel = this.labels.getRangeText(this.page, this.pageSize, this.length, false);
        this.shortRangeLabel = this.labels.getRangeText(this.page, this.pageSize, this.length, true);
        this.state.page = this._page;
    }
    /**
     * @return {?}
     */
    get length() { return this._length; }
    /**
     * @param {?} length
     * @return {?}
     */
    set length(length) {
        this._length = length;
        this.changeDetectorRef.markForCheck();
        this.longRangeLabel = this.labels.getRangeText(this.page, this.pageSize, this.length, false);
        this.shortRangeLabel = this.labels.getRangeText(this.page, this.pageSize, this.length, true);
    }
    /**
     * @return {?}
     */
    get pageSize() { return this._pageSize; }
    /**
     * @param {?} pageSize
     * @return {?}
     */
    set pageSize(pageSize) {
        this._pageSize = pageSize;
        this.updateDisplayedPageSizeOptions();
        this.state.pageSize = this._pageSize;
    }
    /**
     * @return {?}
     */
    get pageSizeOptions() { return this._pageSizeOptions; }
    /**
     * @param {?} pageSizeOptions
     * @return {?}
     */
    set pageSizeOptions(pageSizeOptions) {
        this._pageSizeOptions = pageSizeOptions;
        this.updateDisplayedPageSizeOptions();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._initialized = true;
        this.updateDisplayedPageSizeOptions();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.resetSubscription.unsubscribe();
    }
    /**
     * @return {?}
     */
    nextPage() {
        if (!this.hasNextPage()) {
            return;
        }
        this.page++;
        this.emitPageEvent();
    }
    /**
     * @return {?}
     */
    previousPage() {
        if (!this.hasPreviousPage()) {
            return;
        }
        this.page--;
        this.emitPageEvent();
    }
    /**
     * @return {?}
     */
    hasPreviousPage() {
        return this.page >= 1 && this.pageSize !== 0;
    }
    /**
     * @return {?}
     */
    hasNextPage() {
        const /** @type {?} */ numberOfPages = Math.ceil(this.length / this.pageSize) - 1;
        return this.page < numberOfPages && this.pageSize !== 0;
    }
    /**
     * @param {?} pageSize
     * @return {?}
     */
    changePageSize(pageSize) {
        this.page = 0;
        this.pageSize = pageSize;
        this.emitPageEvent();
    }
    /**
     * @return {?}
     */
    updateDisplayedPageSizeOptions() {
        if (!this._initialized) {
            return;
        }
        if (!this.pageSize) {
            this._pageSize = this.pageSizeOptions.length !== 0 ?
                this.pageSizeOptions[0] :
                DEFAULT_PAGE_SIZE;
        }
        this.displayedPageSizeOptions = this.pageSizeOptions.slice();
        if (this.displayedPageSizeOptions.indexOf(this.pageSize) === -1) {
            this.displayedPageSizeOptions.push(this.pageSize);
        }
        this.displayedPageSizeOptions.sort((a, b) => a - b);
        this.changeDetectorRef.markForCheck();
        this.longRangeLabel = this.labels.getRangeText(this.page, this.pageSize, this.length, false);
        this.shortRangeLabel = this.labels.getRangeText(this.page, this.pageSize, this.length, true);
    }
    /**
     * @return {?}
     */
    emitPageEvent() {
        let /** @type {?} */ event = {
            page: this.page,
            pageSize: this.pageSize,
            length: this.length
        };
        this.pageChange.next(event);
        this.state.page = this.page;
        this.state.pageSize = this.pageSize;
        this.longRangeLabel = this.labels.getRangeText(this.page, this.pageSize, this.length, false);
        this.shortRangeLabel = this.labels.getRangeText(this.page, this.pageSize, this.length, true);
        this.state.updates.next(event);
    }
}
NovoSimpleTablePagination.decorators = [
    { type: Component, args: [{
                selector: 'novo-simple-table-pagination',
                template: `
        <div class="novo-simple-table-pagination-size">
            <novo-tiles *ngIf="displayedPageSizeOptions.length > 1"
                        [(ngModel)]="pageSize"
                        [options]="displayedPageSizeOptions"
                        (onChange)="changePageSize($event)"
                        data-automation-id="novo-simple-table-pagination-tiles">
            </novo-tiles>
            <div *ngIf="displayedPageSizeOptions.length <= 1">{{ pageSize }}</div>
        </div>

        <div class="novo-simple-table-range-label-long"data-automation-id="novo-simple-table-pagination-range-label-long">
            {{ longRangeLabel }}
        </div>
        <div class="novo-simple-table-range-label-short"data-automation-id="novo-simple-table-pagination-range-label-short">
            {{ shortRangeLabel }}
        </div>

        <button theme="dialogue" type="button"
                class="novo-simple-table-pagination-navigation-previous"
                (click)="previousPage()"
                icon="previous"
                side="left"
                [disabled]="!hasPreviousPage()"
                data-automation-id="novo-simple-table-pagination-previous">
            <span>{{ labels.previous }}</span>
        </button>
        <button theme="dialogue" type="button"
                class="novo-simple-table-pagination-navigation-next"
                (click)="nextPage()"
                icon="next"
                side="right"
                [disabled]="!hasNextPage()"
                data-automation-id="novo-simple-table-pagination-next">
            <span>{{ labels.next }}</span>
        </button>
    `,
                changeDetection: ChangeDetectionStrategy.OnPush,
            },] },
];
/**
 * @nocollapse
 */
NovoSimpleTablePagination.ctorParameters = () => [
    { type: ChangeDetectorRef, },
    { type: NovoLabelService, },
    { type: NovoActivityTableState, },
];
NovoSimpleTablePagination.propDecorators = {
    'page': [{ type: Input },],
    'length': [{ type: Input },],
    'pageSize': [{ type: Input },],
    'pageSizeOptions': [{ type: Input },],
    'pageChange': [{ type: Output },],
};

class ActivityTableRenderers {
    /**
     * @template T
     * @param {?} prop
     * @return {?}
     */
    static propertyRenderer(prop) {
        return (data) => {
            // TODO - allow for dots and sub props
            return data[prop];
        };
    }
    /**
     * @template T
     * @param {?} prop
     * @return {?}
     */
    static dateRenderer(prop) {
        return (data) => {
            return data[prop] ? new Date(data[prop]).toLocaleDateString() : '';
        };
    }
}

class NovoSimpleTableModule {
}
NovoSimpleTableModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    NovoDatePickerModule, CdkTableModule, CommonModule, FormsModule, NovoButtonModule,
                    NovoDropdownModule, NovoFormExtrasModule, NovoLoadingModule, NovoTilesModule, NovoSearchBoxModule
                ],
                exports: [
                    NovoTable, NovoSimpleCellDef, NovoSimpleHeaderCellDef, NovoSimpleColumnDef, NovoActivityTableEmptyMessage, NovoActivityTableNoResultsMessage,
                    NovoSimpleHeaderRowDef, NovoSimpleRowDef, NovoSimpleCellHeader, NovoSortFilter, NovoSimpleActionCell, NovoSimpleEmptyHeaderCell,
                    NovoSimpleHeaderCell, NovoSimpleCell, NovoSimpleHeaderRow, NovoSimpleRow, NovoSimpleFilterFocus, NovoSimpleTablePagination, NovoActivityTableCustomHeader,
                    NovoSimpleCheckboxCell, NovoSimpleCheckboxHeaderCell, NovoSelection, NovoActivityTable, NovoActivityTableActions, NovoActivityTableCustomFilter
                ],
                declarations: [
                    NovoTable, NovoSimpleCellDef, NovoSimpleHeaderCellDef, NovoSimpleColumnDef, NovoActivityTableEmptyMessage, NovoActivityTableNoResultsMessage,
                    NovoSimpleHeaderRowDef, NovoSimpleRowDef, NovoSimpleCellHeader, NovoSortFilter, NovoSimpleActionCell, NovoSimpleEmptyHeaderCell,
                    NovoSimpleHeaderCell, NovoSimpleCell, NovoSimpleHeaderRow, NovoSimpleRow, NovoSimpleFilterFocus, NovoSimpleTablePagination, NovoActivityTableCustomHeader,
                    NovoSimpleCheckboxCell, NovoSimpleCheckboxHeaderCell, NovoSelection, NovoActivityTable, NovoActivityTableActions, NovoActivityTableCustomFilter
                ],
                providers: [
                    NovoActivityTableState
                ]
            },] },
];
/**
 * @nocollapse
 */
NovoSimpleTableModule.ctorParameters = () => [];

/**
 * @abstract
 */
class GlobalRef {
    /**
     * @abstract
     * @return {?}
     */
    nativeGlobal() { }
}
class BrowserGlobalRef extends GlobalRef {
    /**
     * @return {?}
     */
    get nativeGlobal() {
        return (window);
    }
}

class LocalStorageService {
    /**
     * @param {?} key
     * @param {?} value
     * @return {?}
     */
    setItem(key, value) {
        localStorage.setItem(key, value);
    }
    /**
     * @param {?} key
     * @return {?}
     */
    getItem(key) {
        return localStorage.getItem(key);
    }
    /**
     * @param {?} key
     * @return {?}
     */
    removeItem(key) {
        localStorage.removeItem(key);
    }
}
LocalStorageService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
LocalStorageService.ctorParameters = () => [];

class GooglePlacesService {
    /**
     * @param {?} _http
     * @param {?} platformId
     * @param {?} _global
     * @param {?} _localStorageService
     */
    constructor(_http, platformId, _global, _localStorageService) {
        this._http = _http;
        this.platformId = platformId;
        this._global = _global;
        this._localStorageService = _localStorageService;
    }
    /**
     * @param {?} url
     * @param {?} query
     * @return {?}
     */
    getPredictions(url, query) {
        return new Promise(resolve => {
            this._http.get(url + '?query=' + query).map(res => res.json())
                .subscribe((data) => {
                if (data) {
                    resolve(data);
                }
                else {
                    resolve(false);
                }
            });
        });
    }
    /**
     * @param {?} url
     * @param {?} lat
     * @param {?} lng
     * @return {?}
     */
    getLatLngDetail(url, lat, lng) {
        return new Promise(resolve => {
            this._http.get(url + '?lat=' + lat + '&lng=' + lng).map(res => res.json())
                .subscribe((data) => {
                if (data) {
                    resolve(data);
                }
                else {
                    resolve(false);
                }
            });
        });
    }
    /**
     * @param {?} url
     * @param {?} placeId
     * @return {?}
     */
    getPlaceDetails(url, placeId) {
        return new Promise(resolve => {
            this._http.get(url + '?query=' + placeId).map(res => res.json())
                .subscribe((data) => {
                if (data) {
                    resolve(data);
                }
                else {
                    resolve(false);
                }
            });
        });
    }
    /**
     * @return {?}
     */
    getGeoCurrentLocation() {
        return new Promise(resolve => {
            if (isPlatformBrowser(this.platformId)) {
                let /** @type {?} */ _window = this._global.nativeGlobal;
                if (_window.navigator.geolocation) {
                    _window.navigator.geolocation.getCurrentPosition((pos) => {
                        let /** @type {?} */ latlng = { lat: parseFloat(pos.coords.latitude + ''), lng: parseFloat(pos.coords.longitude + '') };
                        resolve(latlng);
                    });
                }
                else {
                    resolve(false);
                }
            }
            else {
                resolve(false);
            }
        });
    }
    /**
     * @param {?} latlng
     * @return {?}
     */
    getGeoLatLngDetail(latlng) {
        return new Promise(resolve => {
            if (isPlatformBrowser(this.platformId)) {
                let /** @type {?} */ _window = this._global.nativeGlobal;
                let /** @type {?} */ geocoder = new _window.google.maps.Geocoder();
                geocoder.geocode({ 'location': latlng }, (results, status) => {
                    if (status === 'OK') {
                        this.getGeoPlaceDetail(results[0].place_id).then((result) => {
                            if (result) {
                                resolve(result);
                            }
                            else {
                                resolve(false);
                            }
                        });
                    }
                    else {
                        resolve(false);
                    }
                });
            }
            else {
                resolve(false);
            }
        });
    }
    /**
     * @param {?} params
     * @return {?}
     */
    getGeoPrediction(params) {
        return new Promise(resolve => {
            if (isPlatformBrowser(this.platformId)) {
                let /** @type {?} */ _window = this._global.nativeGlobal;
                let /** @type {?} */ placesService = new _window.google.maps.places.AutocompleteService();
                let /** @type {?} */ queryInput = {};
                let /** @type {?} */ promiseArr = [];
                if (params.countryRestriction.length) {
                    queryInput = {
                        input: params.query,
                        componentRestrictions: { country: params.countryRestriction },
                    };
                }
                else {
                    queryInput = {
                        input: params.query
                    };
                }
                if (params.geoLocation) {
                    queryInput.location = new _window.google.maps.LatLng(parseFloat(params.geoLocation[0]), parseFloat(params.geoLocation[1]));
                    queryInput.radius = params.radius;
                }
                if (params.geoTypes.length) {
                    for (let /** @type {?} */ i = 0; i < params.geoTypes.length; i++) {
                        let /** @type {?} */ _tempQuery = queryInput;
                        _tempQuery['types'] = new Array(params.geoTypes[i]);
                        promiseArr.push(this.geoPredictionCall(placesService, _tempQuery));
                    }
                }
                else {
                    promiseArr.push(this.geoPredictionCall(placesService, queryInput));
                }
                Promise.all(promiseArr).then(values => {
                    let /** @type {?} */ val = values;
                    if (val.length > 1) {
                        let /** @type {?} */ _tempArr = [];
                        for (let /** @type {?} */ j = 0; j < val.length; j++) {
                            if (val[j] && val[j].length) {
                                _tempArr = _tempArr.concat(val[j]);
                            }
                        }
                        _tempArr = this.getUniqueResults(_tempArr);
                        resolve(_tempArr);
                    }
                    else {
                        resolve(values[0]);
                    }
                });
            }
            else {
                resolve(false);
            }
        });
    }
    /**
     * @param {?} placeId
     * @return {?}
     */
    getGeoPlaceDetail(placeId) {
        return new Promise(resolve => {
            if (isPlatformBrowser(this.platformId)) {
                let /** @type {?} */ _window = this._global.nativeGlobal;
                let /** @type {?} */ placesService = new _window.google.maps.places.PlacesService(document.createElement('div'));
                placesService.getDetails({ 'placeId': placeId }, (result, status) => {
                    if (result === null || result.length === 0) {
                        this.getGeoPaceDetailByReferance(result.referance).then((referanceData) => {
                            if (!referanceData) {
                                resolve(false);
                            }
                            else {
                                resolve(referanceData);
                            }
                        });
                    }
                    else {
                        resolve(result);
                    }
                });
            }
            else {
                resolve(false);
            }
        });
    }
    /**
     * @param {?} referance
     * @return {?}
     */
    getGeoPaceDetailByReferance(referance) {
        return new Promise(resolve => {
            if (isPlatformBrowser(this.platformId)) {
                let /** @type {?} */ _window = this._global.nativeGlobal;
                let /** @type {?} */ placesService = new _window.google.maps.places.PlacesService();
                placesService.getDetails({ 'reference': referance }, (result, status) => {
                    if (status === _window.google.maps.places.PlacesServiceStatus.OK) {
                        resolve(result);
                    }
                    else {
                        resolve(false);
                    }
                });
            }
            else {
                resolve(false);
            }
        });
    }
    /**
     * @param {?} localStorageName
     * @param {?} result
     * @param {?} itemSavedLength
     * @return {?}
     */
    addRecentList(localStorageName, result, itemSavedLength) {
        this.getRecentList(localStorageName).then((data) => {
            if (data) {
                for (let /** @type {?} */ i = 0; i < data.length; i++) {
                    if (data[i].description === result.description) {
                        data.splice(i, 1);
                        break;
                    }
                }
                data.unshift(result);
                if (data.length > itemSavedLength) {
                    data.pop();
                }
                this._localStorageService.setItem(localStorageName, JSON.stringify(data));
            }
        });
    }
    ;
    /**
     * @param {?} localStorageName
     * @return {?}
     */
    getRecentList(localStorageName) {
        return new Promise(resolve => {
            let /** @type {?} */ value = this._localStorageService.getItem(localStorageName);
            if (value) {
                value = JSON.parse(value);
            }
            else {
                value = [];
            }
            resolve(value);
        });
    }
    /**
     * @param {?} arr
     * @return {?}
     */
    getUniqueResults(arr) {
        return Array.from(arr.reduce((m, t) => m.set(t.place_id, t), new Map()).values());
    }
    /**
     * @param {?} placesService
     * @param {?} queryInput
     * @return {?}
     */
    geoPredictionCall(placesService, queryInput) {
        let /** @type {?} */ _window = this._global.nativeGlobal;
        return new Promise(resolve => {
            placesService.getPlacePredictions(queryInput, (result, status) => {
                if (status === _window.google.maps.places.PlacesServiceStatus.OK) {
                    resolve(result);
                }
                else {
                    resolve(false);
                }
            });
        });
    }
}
GooglePlacesService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
GooglePlacesService.ctorParameters = () => [
    { type: Http, },
    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] },] },
    { type: GlobalRef, },
    { type: LocalStorageService, },
];

// NG2
let AppBridgeHandler = {};
AppBridgeHandler.HTTP = 0;
AppBridgeHandler.OPEN = 1;
AppBridgeHandler.OPEN_LIST = 2;
AppBridgeHandler.CLOSE = 3;
AppBridgeHandler.REFRESH = 4;
AppBridgeHandler.PIN = 5;
AppBridgeHandler.REGISTER = 6;
AppBridgeHandler.UPDATE = 7;
AppBridgeHandler.REQUEST_DATA = 8;
AppBridgeHandler.CALLBACK = 9;
AppBridgeHandler[AppBridgeHandler.HTTP] = "HTTP";
AppBridgeHandler[AppBridgeHandler.OPEN] = "OPEN";
AppBridgeHandler[AppBridgeHandler.OPEN_LIST] = "OPEN_LIST";
AppBridgeHandler[AppBridgeHandler.CLOSE] = "CLOSE";
AppBridgeHandler[AppBridgeHandler.REFRESH] = "REFRESH";
AppBridgeHandler[AppBridgeHandler.PIN] = "PIN";
AppBridgeHandler[AppBridgeHandler.REGISTER] = "REGISTER";
AppBridgeHandler[AppBridgeHandler.UPDATE] = "UPDATE";
AppBridgeHandler[AppBridgeHandler.REQUEST_DATA] = "REQUEST_DATA";
AppBridgeHandler[AppBridgeHandler.CALLBACK] = "CALLBACK";
const HTTP_VERBS = {
    GET: 'get',
    POST: 'post',
    PUT: 'put',
    DELETE: 'delete'
};
const MESSAGE_TYPES = {
    REGISTER: 'register',
    OPEN: 'open',
    OPEN_LIST: 'openList',
    CLOSE: 'close',
    REFRESH: 'refresh',
    PIN: 'pin',
    UPDATE: 'update',
    HTTP_GET: 'httpGET',
    HTTP_POST: 'httpPOST',
    HTTP_PUT: 'httpPUT',
    HTTP_DELETE: 'httpDELETE',
    CUSTOM_EVENT: 'customEvent',
    REQUEST_DATA: 'requestData',
    CALLBACK: 'callback'
};
class AppBridgeService {
    /**
     * @param {?} name
     * @return {?}
     */
    create(name) {
        return new AppBridge(name);
    }
}
class DevAppBridgeService {
    /**
     * @param {?} http
     */
    constructor(http$$1) {
        this.http = http$$1;
    }
    /**
     * @param {?} name
     * @return {?}
     */
    create(name) {
        return new DevAppBridge(name, this.http);
    }
}
class AppBridge {
    /**
     * @param {?=} traceName
     */
    constructor(traceName = 'AppBridge') {
        this.id = `${Date.now()}`;
        this._registeredFrames = [];
        this._handlers = {};
        this._tracing = false;
        this._eventListeners = {};
        this.traceName = traceName;
        if (postRobot) {
            postRobot.CONFIG.LOG_LEVEL = 'error';
            try {
                this._setupHandlers();
            }
            catch (error) {
                // No op
            }
        }
    }
    /**
     * @param {?} tracing
     * @return {?}
     */
    set tracing(tracing) {
        this._tracing = tracing;
    }
    /**
     * @param {?} type
     * @param {?} handler
     * @return {?}
     */
    handle(type, handler) {
        this._handlers[type] = handler;
    }
    /**
     * @param {?} eventType
     * @param {?} event
     * @return {?}
     */
    _trace(eventType, event) {
        if (this._tracing) {
            console.log(`[${this.traceName || this.id}] "${eventType}"`, event); // tslint:disable-line
        }
    }
    /**
     * @return {?}
     */
    _setupHandlers() {
        // Register
        postRobot.on(MESSAGE_TYPES.REGISTER, (event) => {
            this._trace(MESSAGE_TYPES.REGISTER, event);
            this._registeredFrames.push(event);
            return this.register(event.data).then(windowName => {
                this.windowName = windowName;
                return { windowName };
            });
        });
        // Update
        postRobot.on(MESSAGE_TYPES.UPDATE, (event) => {
            this._trace(MESSAGE_TYPES.UPDATE, event);
            return this.update(event.data).then(success => {
                return { success };
            });
        });
        // Open
        postRobot.on(MESSAGE_TYPES.OPEN, (event) => {
            this._trace(MESSAGE_TYPES.OPEN, event);
            return this.open(event.data).then(success => {
                return { success };
            });
        });
        postRobot.on(MESSAGE_TYPES.OPEN_LIST, (event) => {
            this._trace(MESSAGE_TYPES.OPEN_LIST, event);
            return this.openList(event.data).then(success => {
                return { success };
            });
        });
        // Close
        postRobot.on(MESSAGE_TYPES.CLOSE, (event) => {
            this._trace(MESSAGE_TYPES.CLOSE, event);
            const /** @type {?} */ index = this._registeredFrames.findIndex(frame => frame.data.id === event.data.id);
            if (index !== -1) {
                this._registeredFrames.splice(index, 1);
            }
            return this.close(event.data).then(success => {
                return { success };
            });
        });
        // Refresh
        postRobot.on(MESSAGE_TYPES.REFRESH, (event) => {
            this._trace(MESSAGE_TYPES.REFRESH, event);
            return this.refresh(event.data).then(success => {
                return { success };
            });
        });
        // PIN
        postRobot.on(MESSAGE_TYPES.PIN, (event) => {
            this._trace(MESSAGE_TYPES.PIN, event);
            return this.pin(event.data).then(success => {
                return { success };
            });
        });
        // REQUEST_DATA
        postRobot.on(MESSAGE_TYPES.REQUEST_DATA, (event) => {
            this._trace(MESSAGE_TYPES.REQUEST_DATA, event);
            return this.requestData(event.data).then(result => {
                return { data: result.data, error: result.error };
            });
        });
        // CALLBACKS
        postRobot.on(MESSAGE_TYPES.CALLBACK, (event) => {
            this._trace(MESSAGE_TYPES.CALLBACK, event);
            return this.callback(event.data).then(success => {
                return { success };
            });
        });
        // HTTP-GET
        postRobot.on(MESSAGE_TYPES.HTTP_GET, (event) => {
            this._trace(MESSAGE_TYPES.HTTP_GET, event);
            return this.httpGET(event.data.relativeURL).then(result => {
                return { data: result.data, error: result.error };
            });
        });
        // HTTP-POST
        postRobot.on(MESSAGE_TYPES.HTTP_POST, (event) => {
            this._trace(MESSAGE_TYPES.HTTP_POST, event);
            return this.httpPOST(event.data.relativeURL, event.data.data).then(result => {
                return { data: result.data, error: result.error };
            });
        });
        // HTTP-PUT
        postRobot.on(MESSAGE_TYPES.HTTP_PUT, (event) => {
            this._trace(MESSAGE_TYPES.HTTP_PUT, event);
            return this.httpPUT(event.data.relativeURL, event.data.data).then((result) => {
                return { data: result.data, error: result.error };
            });
        });
        // HTTP-DELETE
        postRobot.on(MESSAGE_TYPES.HTTP_DELETE, (event) => {
            this._trace(MESSAGE_TYPES.HTTP_DELETE, event);
            return this.httpDELETE(event.data.relativeURL).then(result => {
                return { data: result.data, error: result.error };
            });
        });
        // Custom Events
        postRobot.on(MESSAGE_TYPES.CUSTOM_EVENT, (event) => {
            this._trace(MESSAGE_TYPES.CUSTOM_EVENT, event);
            if (this._eventListeners[event.data.event]) {
                this._eventListeners[event.data.event].forEach((listener) => {
                    listener(event.data.data);
                });
            }
            if (this._registeredFrames.length > 0) {
                this._registeredFrames.forEach(frame => {
                    postRobot.send(frame.source, MESSAGE_TYPES.CUSTOM_EVENT, event.data);
                });
            }
        });
    }
    /**
     * Fires or responds to an open event
     * @param {?} packet any - packet of data to send with the open event
     * @return {?}
     */
    open(packet) {
        Object.assign(packet, { id: this.id, windowName: this.windowName });
        return new Promise((resolve, reject) => {
            if (this._handlers[AppBridgeHandler.OPEN]) {
                this._handlers[AppBridgeHandler.OPEN](packet, (success) => {
                    if (success) {
                        resolve(true);
                    }
                    else {
                        reject(false);
                    }
                });
            }
            else {
                postRobot.sendToParent(MESSAGE_TYPES.OPEN, packet).then((event) => {
                    this._trace(`${MESSAGE_TYPES.OPEN} (callback)`, event);
                    if (event.data) {
                        resolve(true);
                    }
                    else {
                        reject(false);
                    }
                }).catch((err) => {
                    reject(false);
                });
            }
        });
    }
    /**
     * Fires or responds to an openList event
     * @param {?} packet any - packet of data to send with the open event
     * @return {?}
     */
    openList(packet) {
        let /** @type {?} */ openListPacket = {};
        Object.assign(openListPacket, { type: 'List', entityType: packet.type, keywords: packet.keywords, criteria: packet.criteria });
        return new Promise((resolve, reject) => {
            if (this._handlers[AppBridgeHandler.OPEN_LIST]) {
                this._handlers[AppBridgeHandler.OPEN_LIST](packet, (success) => {
                    if (success) {
                        resolve(true);
                    }
                    else {
                        reject(false);
                    }
                });
            }
            else {
                postRobot.sendToParent(MESSAGE_TYPES.OPEN_LIST, packet).then((event) => {
                    this._trace(`${MESSAGE_TYPES.OPEN_LIST} (callback)`, event);
                    if (event.data) {
                        resolve(true);
                    }
                    else {
                        reject(false);
                    }
                }).catch((err) => {
                    reject(false);
                });
            }
        });
    }
    /**
     * Fires or responds to an close event
     * @param {?} packet any - packet of data to send with the close event
     * @return {?}
     */
    update(packet) {
        Object.assign(packet, { id: this.id, windowName: this.windowName });
        return new Promise((resolve, reject) => {
            if (this._handlers[AppBridgeHandler.UPDATE]) {
                this._handlers[AppBridgeHandler.UPDATE](packet, (success) => {
                    if (success) {
                        resolve(true);
                    }
                    else {
                        reject(false);
                    }
                });
            }
            else {
                postRobot.sendToParent(MESSAGE_TYPES.UPDATE, packet).then((event) => {
                    this._trace(`${MESSAGE_TYPES.UPDATE} (callback)`, event);
                    if (event.data) {
                        resolve(true);
                    }
                    else {
                        reject(false);
                    }
                }).catch((err) => {
                    reject(false);
                });
            }
        });
    }
    /**
     * Fires or responds to an close event
     * @param {?=} packet
     * @return {?}
     */
    close(packet) {
        if (packet) {
            console.info('[AppBridge] - close(packet) is deprecated! Please just use close()!'); // tslint:disable-line
        }
        let /** @type {?} */ realPacket = { id: this.id, windowName: this.windowName };
        return new Promise((resolve, reject) => {
            if (this._handlers[AppBridgeHandler.CLOSE]) {
                this._handlers[AppBridgeHandler.CLOSE](realPacket, (success) => {
                    if (success) {
                        resolve(true);
                    }
                    else {
                        reject(false);
                    }
                });
            }
            else {
                postRobot.sendToParent(MESSAGE_TYPES.CLOSE, realPacket).then((event) => {
                    this._trace(`${MESSAGE_TYPES.CLOSE} (callback)`, event);
                    if (event.data) {
                        resolve(true);
                    }
                    else {
                        reject(false);
                    }
                }).catch((err) => {
                    reject(false);
                });
            }
        });
    }
    /**
     * Fires or responds to an close event
     * @param {?=} packet
     * @return {?}
     */
    refresh(packet) {
        if (packet) {
            console.info('[AppBridge] - refresh(packet) is deprecated! Please just use refresh()!'); // tslint:disable-line
        }
        let /** @type {?} */ realPacket = { id: this.id, windowName: this.windowName };
        return new Promise((resolve, reject) => {
            if (this._handlers[AppBridgeHandler.REFRESH]) {
                this._handlers[AppBridgeHandler.REFRESH](realPacket, (success) => {
                    if (success) {
                        resolve(true);
                    }
                    else {
                        reject(false);
                    }
                });
            }
            else {
                postRobot.sendToParent(MESSAGE_TYPES.REFRESH, realPacket).then((event) => {
                    this._trace(`${MESSAGE_TYPES.REFRESH} (callback)`, event);
                    if (event.data) {
                        resolve(true);
                    }
                    else {
                        reject(false);
                    }
                }).catch((err) => {
                    reject(false);
                });
            }
        });
    }
    /**
     * Fires or responds to a pin event
     * @param {?=} packet
     * @return {?}
     */
    pin(packet) {
        if (packet) {
            console.info('[AppBridge] - pin(packet) is deprecated! Please just use pin()!'); // tslint:disable-line
        }
        let /** @type {?} */ realPacket = { id: this.id, windowName: this.windowName };
        return new Promise((resolve, reject) => {
            if (this._handlers[AppBridgeHandler.PIN]) {
                this._handlers[AppBridgeHandler.PIN](realPacket, (success) => {
                    if (success) {
                        resolve(true);
                    }
                    else {
                        reject(false);
                    }
                });
            }
            else {
                postRobot.sendToParent(MESSAGE_TYPES.PIN, realPacket).then((event) => {
                    this._trace(`${MESSAGE_TYPES.PIN} (callback)`, event);
                    if (event.data) {
                        resolve(true);
                    }
                    else {
                        reject(false);
                    }
                }).catch((err) => {
                    reject(false);
                });
            }
        });
    }
    /**
     * Fires or responds to a requestData event
     * @param {?} packet any - packet of data to send with the requestData event
     * @return {?}
     */
    requestData(packet) {
        Object.assign(packet, { id: this.id, windowName: this.windowName });
        return new Promise((resolve, reject) => {
            if (this._handlers[AppBridgeHandler.REQUEST_DATA]) {
                this._handlers[AppBridgeHandler.REQUEST_DATA](packet, (data) => {
                    if (data) {
                        resolve({ data });
                    }
                    else {
                        reject(false);
                    }
                });
            }
            else {
                postRobot.sendToParent(MESSAGE_TYPES.REQUEST_DATA, packet).then((event) => {
                    this._trace(`${MESSAGE_TYPES.REQUEST_DATA} (callback)`, event);
                    if (event.data) {
                        resolve({ data: event.data.data });
                    }
                    else {
                        reject(false);
                    }
                }).catch((err) => {
                    reject(false);
                });
            }
        });
    }
    /**
     * Fires a generic callback command
     * @param {?} packet string - key: string, generic: boolean
     * @return {?}
     */
    callback(packet) {
        Object.assign(packet, { id: this.id, windowName: this.windowName });
        return new Promise((resolve, reject) => {
            if (this._handlers[AppBridgeHandler.CALLBACK]) {
                this._handlers[AppBridgeHandler.CALLBACK](packet, (success) => {
                    if (success) {
                        resolve(true);
                    }
                    else {
                        reject(false);
                    }
                });
            }
            else {
                postRobot.sendToParent(MESSAGE_TYPES.CALLBACK, packet).then((event) => {
                    this._trace(`${MESSAGE_TYPES.CALLBACK} (callback)`, event);
                    if (event.data) {
                        resolve(true);
                    }
                    else {
                        reject(false);
                    }
                }).catch((err) => {
                    reject(false);
                });
            }
        });
    }
    /**
     * Fires or responds to an register event
     * @param {?=} packet any - packet of data to send with the event
     * @return {?}
     */
    register(packet = {}) {
        Object.assign(packet, { id: this.id, windowName: this.windowName });
        return new Promise((resolve, reject) => {
            if (this._handlers[AppBridgeHandler.REGISTER]) {
                this._handlers[AppBridgeHandler.REGISTER](packet, (windowName) => {
                    if (windowName) {
                        resolve(windowName);
                    }
                    else {
                        resolve(null);
                    }
                });
            }
            else {
                postRobot.sendToParent(MESSAGE_TYPES.REGISTER, packet).then((event) => {
                    this._trace(`${MESSAGE_TYPES.REGISTER} (callback)`, event);
                    if (event.data) {
                        this.windowName = event.data.windowName;
                        resolve(event.data.windowName);
                    }
                    else {
                        resolve(null);
                    }
                }).catch((err) => {
                    this._trace(`${MESSAGE_TYPES.REGISTER} - FAILED - (no parent)`, err);
                    resolve(null);
                });
            }
        });
    }
    /**
     * Fires or responds to an HTTP_GET event
     * @param {?} relativeURL
     * @return {?}
     */
    httpGET(relativeURL) {
        return new Promise((resolve, reject) => {
            if (this._handlers[AppBridgeHandler.HTTP]) {
                this._handlers[AppBridgeHandler.HTTP]({ verb: HTTP_VERBS.GET, relativeURL: relativeURL }, (data, error) => {
                    resolve({ data, error });
                });
            }
            else {
                postRobot.sendToParent(MESSAGE_TYPES.HTTP_GET, { relativeURL }).then((event) => {
                    resolve({ data: event.data.data, error: event.data.error });
                }).catch((err) => {
                    reject(null);
                });
            }
        });
    }
    /**
     * Fires or responds to an HTTP_POST event
     * @param {?} relativeURL
     * @param {?} postData
     * @return {?}
     */
    httpPOST(relativeURL, postData) {
        return new Promise((resolve, reject) => {
            if (this._handlers[AppBridgeHandler.HTTP]) {
                this._handlers[AppBridgeHandler.HTTP]({ verb: HTTP_VERBS.POST, relativeURL: relativeURL, data: postData }, (data, error) => {
                    resolve({ data, error });
                });
            }
            else {
                postRobot.sendToParent(MESSAGE_TYPES.HTTP_POST, { relativeURL: relativeURL, data: postData }).then((event) => {
                    resolve({ data: event.data.data, error: event.data.error });
                }).catch((err) => {
                    reject(null);
                });
            }
        });
    }
    /**
     * Fires or responds to an HTTP_PUT event
     * @param {?} relativeURL
     * @param {?} putData
     * @return {?}
     */
    httpPUT(relativeURL, putData) {
        return new Promise((resolve, reject) => {
            if (this._handlers[AppBridgeHandler.HTTP]) {
                this._handlers[AppBridgeHandler.HTTP]({ verb: HTTP_VERBS.PUT, relativeURL: relativeURL, data: putData }, (data, error) => {
                    resolve({ data, error });
                });
            }
            else {
                postRobot.sendToParent(MESSAGE_TYPES.HTTP_PUT, { relativeURL: relativeURL, data: putData }).then((event) => {
                    resolve({ data: event.data.data, error: event.data.error });
                }).catch((err) => {
                    reject(null);
                });
            }
        });
    }
    /**
     * Fires or responds to an HTTP_DELETE event
     * @param {?} relativeURL
     * @return {?}
     */
    httpDELETE(relativeURL) {
        return new Promise((resolve, reject) => {
            if (this._handlers[AppBridgeHandler.HTTP]) {
                this._handlers[AppBridgeHandler.HTTP]({ verb: HTTP_VERBS.DELETE, relativeURL: relativeURL }, (data, error) => {
                    resolve({ data, error });
                });
            }
            else {
                postRobot.sendToParent(MESSAGE_TYPES.HTTP_DELETE, { relativeURL }).then((event) => {
                    resolve({ data: event.data.data, error: event.data.error });
                }).catch((err) => {
                    reject(null);
                });
            }
        });
    }
    /**
     * Fires a custom event to anywhere in the application
     * @param {?} event string - event name to fire
     * @param {?} data any - data to be sent along with the event
     * @return {?}
     */
    fireEvent(event, data) {
        return new Promise((resolve, reject) => {
            postRobot.sendToParent(MESSAGE_TYPES.CUSTOM_EVENT, { event, data }).then((e) => {
                resolve(e);
            }).catch((err) => {
                reject(null);
            });
        });
    }
    /**
     * Fires a custom event to all registered frames
     * @param {?} event string - event name to fire
     * @param {?} data any - data to be sent along with the event
     * @return {?}
     */
    fireEventToChildren(event, data) {
        if (this._registeredFrames.length > 0) {
            this._registeredFrames.forEach(frame => {
                postRobot.send(frame.source, MESSAGE_TYPES.CUSTOM_EVENT, {
                    eventType: event,
                    data: data
                });
            });
        }
    }
    /**
     * Adds an event listener to a custom event
     * @param {?} event string - event name to listen to
     * @param {?} callback function - callback to be fired when an event is caught
     * @return {?}
     */
    addEventListener(event, callback) {
        if (!this._eventListeners[event]) {
            this._eventListeners[event] = [];
        }
        this._eventListeners[event].push(callback);
    }
}
class DevAppBridge extends AppBridge {
    /**
     * @param {?=} traceName
     * @param {?=} http
     */
    constructor(traceName = 'DevAppBridge', http$$1) {
        super(traceName);
        this.http = http$$1;
        let cookie = this.getCookie('UlEncodedIdentity');
        if (cookie && cookie.length) {
            let identity = JSON.parse(decodeURIComponent(cookie));
            let endpoints = identity.sessions.reduce((obj, session) => {
                obj[session.name] = session.value.endpoint;
                return obj;
            }, {});
            this.baseURL = endpoints.rest;
        }
    }
    /**
     * @return {?}
     */
    _setupHandlers() { }
    /**
     * Fires or responds to an HTTP_GET event
     * @param {?} relativeURL
     * @return {?}
     */
    httpGET(relativeURL) {
        return this.http.get(`${this.baseURL}/${relativeURL}`, { withCredentials: true }).map(res => ({ data: res.json() })).toPromise();
    }
    /**
     * Fires or responds to an HTTP_POST event
     * @param {?} relativeURL
     * @param {?} postData
     * @return {?}
     */
    httpPOST(relativeURL, postData) {
        return this.http.post(`${this.baseURL}/${relativeURL}`, postData, { withCredentials: true }).map(res => ({ data: res.json() })).toPromise();
    }
    /**
     * Fires or responds to an HTTP_PUT event
     * @param {?} relativeURL
     * @param {?} putData
     * @return {?}
     */
    httpPUT(relativeURL, putData) {
        return this.http.put(`${this.baseURL}/${relativeURL}`, putData, { withCredentials: true }).map(res => ({ data: res.json() })).toPromise();
    }
    /**
     * Fires or responds to an HTTP_DELETE event
     * @param {?} relativeURL
     * @return {?}
     */
    httpDELETE(relativeURL) {
        return this.http.delete(`${this.baseURL}/${relativeURL}`, { withCredentials: true }).map(res => ({ data: res.json() })).toPromise();
    }
    /**
     * @param {?} cname
     * @return {?}
     */
    getCookie(cname) {
        if (document) {
            let /** @type {?} */ name = `${cname}=`;
            let /** @type {?} */ ca = document.cookie.split(';');
            for (let /** @type {?} */ i = 0; i < ca.length; i++) {
                let /** @type {?} */ c = ca[i];
                while (c.charAt(0) === ' ') {
                    c = c.substring(1);
                }
                if (c.indexOf(name) === 0) {
                    return c.substring(name.length, c.length);
                }
            }
        }
        return false;
    }
}

// NG2
// APP
const NOVO_ELEMENTS_PROVIDERS = [
    { provide: NovoDragulaService, useClass: NovoDragulaService },
    { provide: NovoModalRef, useClass: NovoModalRef },
    { provide: NovoModalService, useClass: NovoModalService },
    { provide: GooglePlacesService, useClass: GooglePlacesService },
    { provide: NovoToastService, useClass: NovoToastService },
    { provide: ComponentUtils, useClass: ComponentUtils },
    { provide: GlobalRef, useClass: BrowserGlobalRef },
    { provide: LocalStorageService, useClass: LocalStorageService },
    FieldInteractionApi,
    DateFormatService
];
class NovoElementProviders {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: NovoElementProviders,
            providers: [...NOVO_ELEMENTS_PROVIDERS]
        };
    }
    /**
     * @return {?}
     */
    static forChild() {
        return {
            ngModule: NovoElementProviders
        };
    }
}
NovoElementProviders.decorators = [
    { type: NgModule, args: [{
                imports: []
            },] },
];
/**
 * @nocollapse
 */
NovoElementProviders.ctorParameters = () => [];

class PopOverContent {
    /**
     * @param {?} element
     * @param {?} cdr
     */
    constructor(element, cdr) {
        this.element = element;
        this.cdr = cdr;
        this.placement = 'top';
        this.animation = true;
        this.onCloseFromOutside = new EventEmitter();
        this.top = -10000;
        this.left = -10000;
        this.displayType = 'none';
        this.isHidden = false;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.show();
        this.cdr.detectChanges();
    }
    /**
     * @return {?}
     */
    toggle() {
        if (this.isHidden) {
            this.show();
        }
        else {
            this.hide();
        }
    }
    /**
     * @return {?}
     */
    show() {
        if (!this.popover || !this.popover.getElement()) {
            return;
        }
        const /** @type {?} */ p = this.positionElements(this.popover.getElement(), this.popoverDiv.nativeElement, this.placement);
        this.displayType = 'block';
        this.top = p.top;
        this.left = p.left;
        this.isHidden = false;
    }
    /**
     * @return {?}
     */
    hide() {
        this.top = -10000;
        this.left = -10000;
        this.isHidden = true;
        this.popover.hide();
    }
    /**
     * @return {?}
     */
    hideFromPopover() {
        this.top = -10000;
        this.left = -10000;
    }
    /**
     * @param {?} hostEl
     * @param {?} targetEl
     * @param {?} positionStr
     * @param {?=} appendToBody
     * @return {?}
     */
    positionElements(hostEl, targetEl, positionStr, appendToBody = false) {
        let /** @type {?} */ positionStrParts = positionStr.split('-');
        let /** @type {?} */ mainSide = this.effectivePlacement = this.getEffectivePlacement(positionStrParts[0] || 'right', hostEl, targetEl);
        let /** @type {?} */ orientation = this.effectiveAlignment = positionStrParts[1] || 'center';
        let /** @type {?} */ hostElPos = appendToBody ? this.offset(hostEl) : this.position(hostEl);
        let /** @type {?} */ targetElWidth = targetEl.offsetWidth;
        let /** @type {?} */ targetElHeight = targetEl.offsetHeight;
        let /** @type {?} */ shiftWidth = {
            center: function () {
                return hostElPos.left + (hostElPos.width - targetElWidth) / 2;
            },
            right: function () {
                return hostElPos.left;
            },
            left: function () {
                return hostElPos.left + (hostElPos.width - targetElWidth);
            }
        };
        let /** @type {?} */ shiftHeight = {
            center: function () {
                return hostElPos.top + (hostElPos.height - targetElHeight) / 2;
            },
            bottom: function () {
                return hostElPos.top;
            },
            top: function () {
                return hostElPos.top + (hostElPos.height - targetElHeight);
            }
        };
        let /** @type {?} */ targetElPos;
        switch (mainSide) {
            case 'right':
                targetElPos = {
                    top: shiftHeight[orientation](),
                    left: hostElPos.left + hostElPos.width
                };
                break;
            case 'left':
                targetElPos = {
                    top: shiftHeight[orientation](),
                    left: hostElPos.left - targetElWidth
                };
                break;
            case 'bottom':
                targetElPos = {
                    top: hostElPos.top + hostElPos.height,
                    left: shiftWidth[orientation]()
                };
                break;
            default:
                targetElPos = {
                    top: hostElPos.top - targetElHeight,
                    left: shiftWidth[orientation]()
                };
                break;
        }
        return targetElPos;
    }
    /**
     * @param {?} nativeEl
     * @return {?}
     */
    position(nativeEl) {
        let /** @type {?} */ offsetParentBCR = { top: 0, left: 0 };
        const /** @type {?} */ elBCR = this.offset(nativeEl);
        const /** @type {?} */ offsetParentEl = this.parentOffsetEl(nativeEl);
        if (offsetParentEl !== window.document) {
            offsetParentBCR = this.offset(offsetParentEl);
            offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop;
            offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft;
        }
        const /** @type {?} */ boundingClientRect = nativeEl.getBoundingClientRect();
        return {
            width: boundingClientRect.width || nativeEl.offsetWidth,
            height: boundingClientRect.height || nativeEl.offsetHeight,
            top: elBCR.top - offsetParentBCR.top,
            left: elBCR.left - offsetParentBCR.left
        };
    }
    /**
     * @param {?} nativeEl
     * @return {?}
     */
    offset(nativeEl) {
        const /** @type {?} */ boundingClientRect = nativeEl.getBoundingClientRect();
        return {
            width: boundingClientRect.width || nativeEl.offsetWidth,
            height: boundingClientRect.height || nativeEl.offsetHeight,
            top: boundingClientRect.top + (window.pageYOffset || window.document.documentElement.scrollTop),
            left: boundingClientRect.left + (window.pageXOffset || window.document.documentElement.scrollLeft)
        };
    }
    /**
     * @param {?} nativeEl
     * @param {?} cssProp
     * @return {?}
     */
    getStyle(nativeEl, cssProp) {
        if (((nativeEl)).currentStyle) {
            return ((nativeEl)).currentStyle[cssProp];
        }
        if (window.getComputedStyle) {
            return ((window.getComputedStyle))(nativeEl)[cssProp];
        }
        return ((nativeEl.style))[cssProp];
    }
    /**
     * @param {?} nativeEl
     * @return {?}
     */
    isStaticPositioned(nativeEl) {
        return (this.getStyle(nativeEl, 'position') || 'static') === 'static';
    }
    /**
     * @param {?} nativeEl
     * @return {?}
     */
    parentOffsetEl(nativeEl) {
        let /** @type {?} */ offsetParent = nativeEl.offsetParent || window.document;
        while (offsetParent && offsetParent !== window.document && this.isStaticPositioned(offsetParent)) {
            offsetParent = offsetParent.offsetParent;
        }
        return offsetParent || window.document;
    }
    /**
     * @param {?} desiredPlacement
     * @param {?} hostElement
     * @param {?} targetElement
     * @return {?}
     */
    getEffectivePlacement(desiredPlacement, hostElement, targetElement) {
        const /** @type {?} */ hostElBoundingRect = hostElement.getBoundingClientRect();
        if (desiredPlacement === 'top' && hostElBoundingRect.top - targetElement.offsetHeight < 0) {
            return 'bottom';
        }
        if (desiredPlacement === 'bottom' && hostElBoundingRect.bottom + targetElement.offsetHeight > window.innerHeight) {
            return 'top';
        }
        if (desiredPlacement === 'left' && hostElBoundingRect.left - targetElement.offsetWidth < 0) {
            return 'right';
        }
        if (desiredPlacement === 'right' && hostElBoundingRect.right + targetElement.offsetWidth > window.innerWidth) {
            return 'left';
        }
        return desiredPlacement;
    }
}
PopOverContent.decorators = [
    { type: Component, args: [{
                selector: 'popover-content',
                template: `
        <div #popoverDiv
            class="popover {{ effectivePlacement }}"
            [style.top]="top + 'px'"
            [style.left]="left + 'px'"
            [class.fade]="animation"
            style="display: block"
            role="popover">
            <div class="arrow {{effectiveAlignment}}"></div>
            <h4 class="popover-title" [hidden]="!title">{{ title }}</h4>
            <div class="popover-content">
                <ng-content></ng-content>
                <div class="popover-content-text">{{ content }}</div>
            </div>
        </div>
    `
            },] },
];
/**
 * @nocollapse
 */
PopOverContent.ctorParameters = () => [
    { type: ElementRef, },
    { type: ChangeDetectorRef, },
];
PopOverContent.propDecorators = {
    'content': [{ type: Input },],
    'placement': [{ type: Input },],
    'title': [{ type: Input },],
    'animation': [{ type: Input },],
    'popoverDiv': [{ type: ViewChild, args: ['popoverDiv',] },],
};

// NG2
class PopOverDirective {
    /**
     * @param {?} viewContainerRef
     * @param {?} resolver
     */
    constructor(viewContainerRef, resolver) {
        this.viewContainerRef = viewContainerRef;
        this.resolver = resolver;
        this.PopoverComponent = PopOverContent;
        this.popoverOnHover = false;
        this.popoverDismissTimeout = 0;
        this.onShown = new EventEmitter();
        this.onHidden = new EventEmitter();
    }
    /**
     * @return {?}
     */
    showOrHideOnClick() {
        if (this.popoverOnHover || this.popoverDisabled) {
            return;
        }
        this.toggle();
    }
    /**
     * @return {?}
     */
    showOnHover() {
        if (!this.popoverOnHover || this.popoverDisabled) {
            return;
        }
        this.show();
    }
    /**
     * @return {?}
     */
    hideOnHover() {
        if (!this.popoverOnHover || this.popoverDisabled) {
            return;
        }
        this.hide();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes['popoverDisabled']) {
            if (changes['popoverDisabled'].currentValue) {
                this.hide();
            }
        }
        if (changes['popoverAlways']) {
            if (changes['popoverAlways'].currentValue) {
                this.show();
            }
        }
    }
    /**
     * @return {?}
     */
    toggle() {
        if (!this.visible) {
            this.show();
        }
        else {
            this.hide();
        }
    }
    /**
     * @return {?}
     */
    show() {
        if (this.visible) {
            return;
        }
        this.visible = true;
        if (typeof this.content === 'string') {
            const /** @type {?} */ factory = this.resolver.resolveComponentFactory(this.PopoverComponent);
            if (!this.visible) {
                return;
            }
            this.popover = this.viewContainerRef.createComponent(factory);
            const /** @type {?} */ popover = (this.popover.instance);
            popover.popover = this;
            popover.content = (this.content);
            if (this.popoverPlacement !== undefined) {
                popover.placement = this.popoverPlacement;
            }
            if (this.popoverAnimation !== undefined) {
                popover.animation = this.popoverAnimation;
            }
            if (this.popoverTitle !== undefined) {
                popover.title = this.popoverTitle;
            }
            popover.onCloseFromOutside.subscribe(() => this.hide());
            if (this.popoverDismissTimeout > 0) {
                setTimeout(() => this.hide(), this.popoverDismissTimeout);
            }
        }
        else {
            const /** @type {?} */ popover = (this.content);
            popover.popover = this;
            if (this.popoverPlacement !== undefined) {
                popover.placement = this.popoverPlacement;
            }
            if (this.popoverAnimation !== undefined) {
                popover.animation = this.popoverAnimation;
            }
            if (this.popoverTitle !== undefined) {
                popover.title = this.popoverTitle;
            }
            popover.onCloseFromOutside.subscribe(() => this.hide());
            if (this.popoverDismissTimeout > 0) {
                setTimeout(() => this.hide(), this.popoverDismissTimeout);
            }
            popover.show();
        }
        this.onShown.emit(this);
    }
    /**
     * @return {?}
     */
    hide() {
        if (!this.visible) {
            return;
        }
        this.visible = false;
        if (this.popover) {
            this.popover.destroy();
        }
        if (this.content instanceof PopOverContent) {
            ((this.content)).hideFromPopover();
        }
        this.onHidden.emit(this);
    }
    /**
     * @return {?}
     */
    getElement() {
        return this.viewContainerRef.element.nativeElement;
    }
}
PopOverDirective.decorators = [
    { type: Directive, args: [{
                selector: '[popover]'
            },] },
];
/**
 * @nocollapse
 */
PopOverDirective.ctorParameters = () => [
    { type: ViewContainerRef, },
    { type: ComponentFactoryResolver, },
];
PopOverDirective.propDecorators = {
    'content': [{ type: Input, args: ['popover',] },],
    'popoverDisabled': [{ type: Input },],
    'popoverAlways': [{ type: Input },],
    'popoverAnimation': [{ type: Input },],
    'popoverPlacement': [{ type: Input },],
    'popoverTitle': [{ type: Input },],
    'popoverOnHover': [{ type: Input },],
    'popoverDismissTimeout': [{ type: Input },],
    'onShown': [{ type: Output },],
    'onHidden': [{ type: Output },],
    'showOrHideOnClick': [{ type: HostListener, args: ['click',] },],
    'showOnHover': [{ type: HostListener, args: ['focusin',] }, { type: HostListener, args: ['mouseenter',] },],
    'hideOnHover': [{ type: HostListener, args: ['focusout',] }, { type: HostListener, args: ['mouseleave',] },],
};

// NG2
// APP
class NovoPopOverModule {
}
NovoPopOverModule.decorators = [
    { type: NgModule, args: [{
                declarations: [PopOverContent, PopOverDirective],
                exports: [PopOverContent, PopOverDirective],
                entryComponents: [PopOverContent]
            },] },
];
/**
 * @nocollapse
 */
NovoPopOverModule.ctorParameters = () => [];

// NG2
class PlacesListComponent {
    /**
     * @param {?} platformId
     * @param {?} _elmRef
     * @param {?} _global
     * @param {?} _googlePlacesService
     */
    constructor(platformId, _elmRef, _global, _googlePlacesService) {
        this.platformId = platformId;
        this._elmRef = _elmRef;
        this._global = _global;
        this._googlePlacesService = _googlePlacesService;
        this.term = '';
        this.termChange = new EventEmitter();
        this.select = new EventEmitter();
        this.locationInput = '';
        this.gettingCurrentLocationFlag = false;
        this.dropdownOpen = false;
        this.recentDropdownOpen = false;
        this.queryItems = [];
        this.isSettingsError = false;
        this.settingsErrorMsg = '';
        this.settings = {};
        this.moduleinit = false;
        this.selectedDataIndex = -1;
        this.recentSearchData = [];
        this.userSelectedOption = '';
        this.defaultSettings = {
            geoPredictionServerUrl: '',
            geoLatLangServiceUrl: '',
            geoLocDetailServerUrl: '',
            geoCountryRestriction: [],
            geoTypes: [],
            geoLocation: [],
            geoRadius: 0,
            serverResponseListHierarchy: [],
            serverResponseatLangHierarchy: [],
            serverResponseDetailHierarchy: [],
            resOnSearchButtonClickOnly: false,
            useGoogleGeoApi: true,
            inputPlaceholderText: 'Enter Area Name',
            inputString: '',
            showSearchButton: true,
            showRecentSearch: true,
            showCurrentLocation: true,
            recentStorageName: 'recentSearches',
            noOfRecentSearchSave: 5,
            currentLocIconUrl: '',
            searchIconUrl: '',
            locationIconUrl: ''
        };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.moduleinit) {
            this.moduleInit();
        }
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        this.moduleinit = true;
        this.moduleInit();
        this.searchinputCallback(null);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    searchinputClickCallback(event) {
        event.target.select();
        this.searchinputCallback(event);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    searchinputCallback(event) {
        let /** @type {?} */ inputVal = this.locationInput;
        if (inputVal) {
            this.getListQuery(inputVal);
        }
        else {
            this.queryItems = [];
            if (this.userSelectedOption) {
                this.userQuerySubmit('false');
            }
            this.userSelectedOption = '';
            if (this.settings.showRecentSearch) {
                this.showRecentSearch();
            }
            else {
                this.dropdownOpen = false;
            }
        }
    }
    /**
     * @param {?} index
     * @return {?}
     */
    activeListNode(index) {
        for (let /** @type {?} */ i = 0; i < this.queryItems.length; i++) {
            if (index === i) {
                this.queryItems[i].active = true;
                this.selectedDataIndex = index;
            }
            else {
                this.queryItems[i].active = false;
            }
        }
    }
    /**
     * @param {?} event
     * @param {?} index
     * @return {?}
     */
    selectedListNode(event, index) {
        this.dropdownOpen = false;
        if (this.recentDropdownOpen) {
            this.setRecentLocation(this.queryItems[index]);
        }
        else {
            this.getPlaceLocationInfo(this.queryItems[index]);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    closeAutocomplete(event) {
        if (!this._elmRef.nativeElement.contains(event.target)) {
            this.selectedDataIndex = -1;
            this.dropdownOpen = false;
        }
    }
    /**
     * @param {?=} selectedOption
     * @return {?}
     */
    userQuerySubmit(selectedOption) {
        let /** @type {?} */ _userOption = selectedOption === 'false' ? '' : this.userSelectedOption;
        if (_userOption) {
            this.select.emit(this.userSelectedOption);
        }
        else {
            //this.select.emit(false);
        }
    }
    /**
     * @return {?}
     */
    currentLocationSelected() {
        if (isPlatformBrowser(this.platformId)) {
            this.gettingCurrentLocationFlag = true;
            this.dropdownOpen = false;
            this._googlePlacesService.getGeoCurrentLocation().then((result) => {
                if (!result) {
                    this.gettingCurrentLocationFlag = false;
                }
                else {
                    this.getCurrentLocationInfo(result);
                }
            });
        }
    }
    /**
     * @return {?}
     */
    moduleInit() {
        this.settings = this.setUserSettings();
        //condition to check if Radius is set without location detail.
        if (this.settings.geoRadius) {
            if (this.settings.geoLocation.length !== 2) {
                this.isSettingsError = true;
                this.settingsErrorMsg = this.settingsErrorMsg +
                    'Radius should be used with GeoLocation. Please use "geoLocation" key to set lat and lng. ';
            }
        }
        //condition to check if lat and lng is set and radious is not set then it will set to 20,000KM by default
        if ((this.settings.geoLocation.length === 2) && !this.settings.geoRadius) {
            this.settings.geoRadius = 20000000;
        }
        if (this.settings.showRecentSearch) {
            this.getRecentLocations();
        }
        if (!this.settings.useGoogleGeoApi) {
            if (!this.settings.geoPredictionServerUrl) {
                this.isSettingsError = true;
                this.settingsErrorMsg = this.settingsErrorMsg +
                    'Prediction custom server url is not defined. Please use "geoPredictionServerUrl" key to set. ';
            }
            if (!this.settings.geoLatLangServiceUrl) {
                this.isSettingsError = true;
                this.settingsErrorMsg = this.settingsErrorMsg +
                    'Latitude and longitude custom server url is not defined. Please use "geoLatLangServiceUrl" key to set. ';
            }
            if (!this.settings.geoLocDetailServerUrl) {
                this.isSettingsError = true;
                this.settingsErrorMsg = this.settingsErrorMsg +
                    'Location detail custom server url is not defined. Please use "geoLocDetailServerUrl" key to set. ';
            }
        }
        this.locationInput = this.term;
    }
    /**
     * @return {?}
     */
    processSearchQuery() {
        if (this.queryItems.length) {
            if (this.selectedDataIndex > -1) {
                this.selectedListNode(null, this.selectedDataIndex);
            }
            else {
                this.selectedListNode(null, 0);
            }
        }
    }
    /**
     * @return {?}
     */
    setUserSettings() {
        let /** @type {?} */ _tempObj = {};
        if (this.userSettings && typeof (this.userSettings) === 'object') {
            let /** @type {?} */ keys = Object.keys(this.defaultSettings);
            for (let /** @type {?} */ value of keys) {
                _tempObj[value] = (this.userSettings[value] !== undefined) ? this.userSettings[value] : this.defaultSettings[value];
            }
            return _tempObj;
        }
        else {
            return this.defaultSettings;
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    getListQuery(value) {
        this.recentDropdownOpen = false;
        if (this.settings.useGoogleGeoApi) {
            let /** @type {?} */ _tempParams = {
                'query': value,
                'countryRestriction': this.settings.geoCountryRestriction,
                'geoTypes': this.settings.geoTypes
            };
            if (this.settings.geoLocation.length === 2) {
                _tempParams.geoLocation = this.settings.geoLocation;
                _tempParams.radius = this.settings.geoRadius;
            }
            this._googlePlacesService.getGeoPrediction(_tempParams).then((result) => {
                this.updateListItem(result);
            });
        }
        else {
            this._googlePlacesService.getPredictions(this.settings.geoPredictionServerUrl, value).then((result) => {
                result = this.extractServerList(this.settings.serverResponseListHierarchy, result);
                this.updateListItem(result);
            });
        }
    }
    /**
     * @param {?} arrayList
     * @param {?} data
     * @return {?}
     */
    extractServerList(arrayList, data) {
        if (arrayList.length) {
            let /** @type {?} */ _tempData = data;
            for (let /** @type {?} */ key of arrayList) {
                _tempData = _tempData[key];
            }
            return _tempData;
        }
        else {
            return data;
        }
    }
    /**
     * @param {?} listData
     * @return {?}
     */
    updateListItem(listData) {
        this.queryItems = listData ? listData : [];
        this.dropdownOpen = true;
    }
    /**
     * @return {?}
     */
    showRecentSearch() {
        this.recentDropdownOpen = true;
        this.dropdownOpen = true;
        this._googlePlacesService.getRecentList(this.settings.recentStorageName).then((result) => {
            if (result) {
                this.queryItems = result;
            }
            else {
                this.queryItems = [];
            }
        });
    }
    /**
     * @param {?} latlng
     * @return {?}
     */
    getCurrentLocationInfo(latlng) {
        if (this.settings.useGoogleGeoApi) {
            this._googlePlacesService.getGeoLatLngDetail(latlng).then((result) => {
                if (result) {
                    this.setRecentLocation(result);
                }
                this.gettingCurrentLocationFlag = false;
            });
        }
        else {
            this._googlePlacesService.getLatLngDetail(this.settings.geoLatLangServiceUrl, latlng.lat, latlng.lng).then((result) => {
                if (result) {
                    result = this.extractServerList(this.settings.serverResponseatLangHierarchy, result);
                    this.setRecentLocation(result);
                }
                this.gettingCurrentLocationFlag = false;
            });
        }
    }
    /**
     * @param {?} selectedData
     * @return {?}
     */
    getPlaceLocationInfo(selectedData) {
        if (this.settings.useGoogleGeoApi) {
            this._googlePlacesService.getGeoPlaceDetail(selectedData.place_id).then((data) => {
                if (data) {
                    this.setRecentLocation(data);
                }
            });
        }
        else {
            this._googlePlacesService.getPlaceDetails(this.settings.geoLocDetailServerUrl, selectedData.place_id).then((result) => {
                if (result) {
                    result = this.extractServerList(this.settings.serverResponseDetailHierarchy, result);
                    this.setRecentLocation(result);
                }
            });
        }
    }
    /**
     * @param {?} data
     * @return {?}
     */
    setRecentLocation(data) {
        data = JSON.parse(JSON.stringify(data));
        data.description = data.description ? data.description : data.formatted_address;
        data.active = false;
        this.selectedDataIndex = -1;
        this.locationInput = data.description;
        if (this.settings.showRecentSearch) {
            this._googlePlacesService.addRecentList(this.settings.recentStorageName, data, this.settings.noOfRecentSearchSave);
            this.getRecentLocations();
        }
        this.userSelectedOption = data;
        //below code will execute only when user press enter or select any option selection and it emit a callback to the parent component.
        if (!this.settings.resOnSearchButtonClickOnly) {
            this.select.emit(data);
            this.termChange.emit(data);
        }
    }
    /**
     * @return {?}
     */
    getRecentLocations() {
        this._googlePlacesService.getRecentList(this.settings.recentStorageName).then((data) => {
            this.recentSearchData = (data && data.length) ? data : [];
        });
    }
}
PlacesListComponent.decorators = [
    { type: Component, args: [{
                selector: 'google-places-list',
                template: `
        <novo-list direction="vertical">
            <novo-list-item *ngFor="let data of queryItems;let $index = index" (click)="selectedListNode($event, $index)">
                <item-header>
                    <item-avatar icon="location"></item-avatar>
                    <item-title>{{data.structured_formatting?.main_text ? data.structured_formatting.main_text : data.description}}</item-title>
                </item-header>
                <item-content>{{data.structured_formatting?.secondary_text}}</item-content>
            </novo-list-item>
        </novo-list>
    `
            },] },
];
/**
 * @nocollapse
 */
PlacesListComponent.ctorParameters = () => [
    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] },] },
    { type: ElementRef, },
    { type: GlobalRef, },
    { type: GooglePlacesService, },
];
PlacesListComponent.propDecorators = {
    'userSettings': [{ type: Input },],
    'term': [{ type: Input },],
    'termChange': [{ type: Output },],
    'select': [{ type: Output },],
};

class GooglePlacesModule {
}
GooglePlacesModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    PlacesListComponent
                ],
                imports: [
                    CommonModule,
                    HttpModule,
                    FormsModule,
                    NovoListModule
                ],
                exports: [
                    PlacesListComponent
                ],
                providers: [
                    { provide: GooglePlacesService, useClass: GooglePlacesService },
                ]
            },] },
];
/**
 * @nocollapse
 */
GooglePlacesModule.ctorParameters = () => [];

// NG2
// APP
class NovoElementsModule {
}
NovoElementsModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    ReactiveFormsModule
                ],
                exports: [
                    NovoPipesModule,
                    NovoButtonModule,
                    NovoLoadingModule,
                    NovoCardModule,
                    NovoCalendarModule,
                    NovoToastModule,
                    NovoTooltipModule,
                    NovoHeaderModule,
                    NovoTabModule,
                    NovoTilesModule,
                    NovoModalModule,
                    NovoQuickNoteModule,
                    NovoRadioModule,
                    NovoDropdownModule,
                    NovoSelectModule,
                    NovoListModule,
                    NovoSwitchModule,
                    NovoDragulaModule,
                    NovoSliderModule,
                    NovoPickerModule,
                    NovoChipsModule,
                    NovoDatePickerModule,
                    NovoTimePickerModule,
                    NovoDateTimePickerModule,
                    NovoNovoCKEditorModule,
                    NovoTipWellModule,
                    NovoTableModule,
                    NovoTableExtrasModule,
                    NovoFormModule,
                    NovoFormExtrasModule,
                    NovoCategoryDropdownModule,
                    NovoMultiPickerModule,
                    NovoPopOverModule,
                    NovoSimpleTableModule,
                    NovoSearchBoxModule,
                    NovoOverlayModule,
                    GooglePlacesModule,
                    NovoValueModule
                ],
                providers: [
                    { provide: ComponentUtils, useClass: ComponentUtils },
                    { provide: NovoLabelService, useClass: NovoLabelService },
                    { provide: NovoDragulaService, useClass: NovoDragulaService },
                    { provide: GooglePlacesService, useClass: GooglePlacesService },
                    { provide: GlobalRef, useClass: BrowserGlobalRef },
                    { provide: LocalStorageService, useClass: LocalStorageService },
                    { provide: FormUtils, useClass: FormUtils }
                ]
            },] },
];
/**
 * @nocollapse
 */
NovoElementsModule.ctorParameters = () => [];

// Export all modules

/**
 * Generated bundle index. Do not edit.
 */

export { NovoPipesModule, NovoButtonModule, NovoLoadingModule, NovoCardModule, NovoCalendarModule, NovoToastModule, NovoTooltipModule, NovoHeaderModule, NovoTabModule, NovoTilesModule, NovoModalModule, NovoQuickNoteModule, NovoRadioModule, NovoDropdownModule, NovoSelectModule, NovoListModule, NovoSwitchModule, NovoSearchBoxModule, NovoDragulaModule, NovoSliderModule, NovoPickerModule, NovoChipsModule, NovoDatePickerModule, NovoTimePickerModule, NovoDateTimePickerModule, NovoNovoCKEditorModule, NovoTipWellModule, NovoTableModule, NovoValueModule, NovoTableMode, NovoTableExtrasModule, NovoFormModule, NovoFormExtrasModule, NovoCategoryDropdownModule, NovoMultiPickerModule, NovoTable, NovoActivityTable, NovoActivityTableActions, NovoActivityTableCustomFilter, NovoActivityTableEmptyMessage, NovoActivityTableNoResultsMessage, NovoActivityTableCustomHeader, NovoSimpleCell, NovoSimpleCheckboxCell, NovoSimpleCheckboxHeaderCell, NovoSimpleHeaderCell, NovoSimpleCellDef, NovoSimpleHeaderCellDef, NovoSimpleColumnDef, NovoSimpleActionCell, NovoSimpleEmptyHeaderCell, NovoSimpleHeaderRow, NovoSimpleRow, NovoSimpleHeaderRowDef, NovoSimpleRowDef, NovoSimpleCellHeader, NovoSimpleFilterFocus, NovoSortFilter, NovoSelection, NovoSimpleTablePagination, ActivityTableDataSource, RemoteActivityTableService, StaticActivityTableService, ActivityTableRenderers, NovoActivityTableState, NovoSimpleTableModule, NovoTableElement, NovoToastService, NovoModalService, NovoLabelService, NovoDragulaService, GooglePlacesService, CollectionEvent, ArrayCollection, PagedArrayCollection, NovoModalParams, NovoModalRef, QuickNoteResults, PickerResults, BasePickerResults, EntityPickerResult, EntityPickerResults, ChecklistPickerResults, GroupedMultiPickerResults, BaseRenderer, DateCell, PercentageCell, NovoDropdownCell, FormValidators, FormUtils, NovoFile, BaseControl, ControlFactory, AddressControl, CheckListControl, CheckboxControl, DateControl, DateTimeControl, EditorControl, FileControl, NativeSelectControl, PickerControl, AppendToBodyPickerControl, TablePickerControl, QuickNoteControl, RadioControl, ReadOnlyControl, SelectControl, TextAreaControl, TextBoxControl, TilesControl, TimeControl, GroupedControl, NovoFormControl, NovoFormGroup, NovoControlGroup, FieldInteractionApi, OutsideClick, KeyCodes, Deferred, COUNTRIES, getCountries, getStateObjects, getStates, findByCountryCode, findByCountryId, findByCountryName, Helpers, ComponentUtils, AppBridge, AppBridgeHandler, AppBridgeService, DevAppBridge, DevAppBridgeService, NovoElementProviders, PluralPipe, DecodeURIPipe, GroupByPipe, RenderPipe, NovoElementsModule, NovoListElement, NOVO_VALUE_TYPE, NOVO_VALUE_THEME, CalendarEventResponse, getWeekViewEventOffset, getWeekViewHeader, getWeekView, getMonthView, getDayView, getDayViewHourGrid, NovoButtonElement as n, NovoCalendarDateChangeElement as bh, NovoEventTypeLegendElement as w, NovoCalendarAllDayEventElement as bg, NovoCalendarDayEventElement as be, NovoCalendarDayViewElement as bd, NovoCalendarHourSegmentElement as bf, NovoCalendarMonthDayElement as z, NovoCalendarMonthHeaderElement as y, NovoCalendarMonthViewElement as x, DayOfMonthPipe as bj, EndOfWeekDisplayPipe as bo, HoursPipe as bn, MonthPipe as bk, MonthDayPipe as bl, WeekdayPipe as bi, YearPipe as bm, NovoCalendarWeekEventElement as bc, NovoCalendarWeekHeaderElement as bb, NovoCalendarWeekViewElement as ba, CardActionsElement as r, CardElement as s, CardBestTimeElement as t, CardDonutChartElement as u, CardTimelineElement as v, NovoCategoryDropdownElement as ee, NovoChipElement as cv, NovoChipsElement as cw, NovoCKEditorElement as de, NovoDatePickerElement as cx, NovoDatePickerInputElement as cy, NovoDateTimePickerElement as dc, NovoDateTimePickerInputElement as dd, NovoDragulaElement as ct, NovoDropdownContainer as ce, NovoDropdownElement as cf, NovoItemElement as cg, NovoItemHeaderElement$1 as ci, NovoListElement$1 as ch, NovoAutoSize as dk, NovoControlElement as dm, NovoCustomControlContainerElement as dl, NovoControlCustom as do, NovoDynamicFormElement as dq, NovoFieldsetElement as dp, NovoFieldsetHeaderElement as dn, ControlConfirmModal as ds, ControlPromptModal as dt, NovoFormElement as dr, NovoAddressElement as dg, NovoCheckListElement as di, NovoCheckboxElement as dh, NovoFileInputElement as dj, NovoHeaderElement as bs, UtilActionElement as br, UtilsElement as bq, NovoItemAvatarElement as e, NovoItemContentElement as i, NovoItemDateElement as h, NovoItemEndElement as j, NovoItemHeaderElement as g, NovoItemTitleElement as f, NovoListItemElement as d, NovoLoadingElement as o, NovoSpinnerElement as p, NovoModalContainerElement as a, NovoModalElement as b, NovoModalNotificationElement as c, NovoMultiPickerElement as ef, DEFAULT_OVERLAY_SCROLL_STRATEGY as ck, DEFAULT_OVERLAY_SCROLL_STRATEGY_PROVIDER as cm, DEFAULT_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY as cl, NovoOverlayTemplate as cn, NovoOverlayModule as cj, NovoPickerElement as cq, NovoPickerContainer as cr, PlacesListComponent as en, GooglePlacesModule as em, PopOverDirective as el, NovoPopOverModule as ej, PopOverContent as ek, QuickNoteElement as cb, NovoRadioElement as cd, NovoRadioGroup as cc, NovoSearchBoxElement as cs, NovoSelectElement as co, NovoSliderElement as cu, NovoSwitchElement as cp, NovoTableKeepFilterFocus as dx, Pagination as dy, RowDetails as dz, NovoTableActionsElement as dw, TableCell as ea, TableFilter as eb, NovoTableFooterElement as dv, NovoTableHeaderElement as du, ThOrderable as ec, ThSortable as ed, NovoNavContentElement as by, NovoNavElement as bt, NovoNavHeaderElement as bz, NovoNavOutletElement as bx, NovoTabButtonElement as bv, NovoTabElement as bu, NovoTabLinkElement as bw, NovoTilesElement as ca, NovoTimePickerElement as da, NovoTimePickerInputElement as db, NovoTipWellElement as df, NovoToastElement as bp, TooltipDirective as q, NovoValueElement as m, NovoValueEmail as l, NovoValuePhone as k, DateFormatService as cz, BrowserGlobalRef as eh, GlobalRef as eg, LocalStorageService as ei };
//# sourceMappingURL=novo-elements.js.map
